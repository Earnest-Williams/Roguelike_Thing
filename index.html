<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Self-Playing Roguelike Dungeon Simulator</title>
    <style>
        body {
            font-family: monospace;
            background-color: #1a1a1a;
            color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: clamp(16px, 4vh, 40px) clamp(20px, 5vw, 80px);
            overflow: auto;
            box-sizing: border-box;
        }
        #app-container {
            display: flex;
            gap: clamp(16px, 3vw, 32px);
            align-items: stretch;
            justify-content: center;
            flex-wrap: wrap;
            width: min(1200px, 100%);
            margin: 0 auto;
            padding: clamp(12px, 2vw, 28px);
            box-sizing: border-box;
        }
        #container {
            text-align: center;
            background-color: #2b2b2b;
            padding: clamp(16px, 2.5vw, 28px);
            border-radius: 14px;
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.55);
            flex: 1 1 540px;
            max-width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            box-sizing: border-box;
        }
        h1 {
            margin-top: 0;
            color: #00bcd4;
        }
        #maze-viewport {
            overflow: hidden;
            position: relative;
            border: 2px solid #00bcd4;
            margin: 0 auto;
            border-radius: 12px;
            background-color: #111; /* Fallback for unexplored */
            transition: transform 0.25s ease-out, box-shadow 0.25s ease-out;
            box-shadow: 0 10px 28px rgba(0, 0, 0, 0.45);
        }
        #maze-canvas {
            position: absolute;
            top: 0;
            left: 0;
            will-change: transform;
            background-color: #111;
        }
        #status {
            font-size: clamp(16px, 1.8vw, 18px);
            color: #e0e0e0;
            min-height: 25px;
        }
        #controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 12px;
            color: #ccc;
            flex-wrap: wrap;
        }
        #speed-slider {
            width: clamp(140px, 16vw, 200px);
        }
        #pause-indicator {
            color: #ffeb3b;
            font-weight: bold;
            height: 20px;
            margin-top: 5px;
        }
        #restartBtn {
            margin-top: 5px; padding: 10px 20px; font-size: 16px; font-family: monospace;
            cursor: pointer; border: none; border-radius: 6px; background-color: #00bcd4;
            color: #1a1a1a; font-weight: bold; transition: background-color 0.2s, transform 0.2s;
        }
        #restartBtn:hover { background-color: #0097a7; transform: translateY(-1px); }
        /* UI Panel Styling */
        #ui-panel {
            width: min(320px, 100%);
            background-color: #2b2b2b;
            padding: clamp(16px, 2.4vw, 26px);
            border-radius: 14px;
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.55);
            flex: 1 1 280px;
            max-height: min(80vh, 720px);
            overflow: auto;
            box-sizing: border-box;
        }
        .ui-section h2 {
            color: #00bcd4;
            border-bottom: 1px solid #00bcd4;
            padding-bottom: 5px;
            margin-top: 0;
            margin-bottom: 10px;
        }
        .slot-container {
            display: grid;
            gap: clamp(8px, 1vw, 12px);
        }
        .equipment-slots {
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        }
        @media (max-width: 600px) {
            .equipment-slots {
                grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
            }
        }
        .inventory-slots {
            grid-template-columns: repeat(auto-fill, minmax(clamp(70px, 18vw, 110px), 1fr));
            grid-auto-rows: minmax(60px, auto);
            grid-auto-flow: row;
        }
        .slot {
            min-height: 60px;
            background-color: #333;
            border: 1px solid #555;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: clamp(12px, 1.3vw, 14px);
            padding: 6px;
            overflow: hidden;
            white-space: nowrap;
        }
        .slot-label {
            font-size: clamp(10px, 1vw, 11px);
            color: #aaa;
            width: 100%;
            text-align: left;
            margin-bottom: 4px;
        }
        .slot-item {
            font-weight: bold;
        }
        /* Minimap modal */
        #minimapModal {
          position: fixed;
          inset: 0;
          background: rgba(0,0,0,0.65);
          display: none;             /* toggled by JS */
          align-items: center;
          justify-content: center;
          z-index: 9999;
        }
        #minimapPanel {
          background: #222;
          border: 1px solid #00bcd4;
          border-radius: 10px;
          padding: 10px 10px 14px 10px;
          box-shadow: 0 12px 40px rgba(0,0,0,0.6);
          max-width: 100vw;
          max-height: 100vh;
          display: flex;
          flex-direction: column;
          gap: 8px;
        }
        #minimapHeader {
          display: flex;
          align-items: center;
          justify-content: space-between;
          color: #00bcd4;
          font-weight: bold;
          padding: 4px 2px 8px 2px;
        }
        #minimapClose {
          background: transparent;
          border: none;
          color: #ccc;
          font-size: 22px;
          cursor: pointer;
        }
        #minimapClose:hover { color: #fff; }

        #minimapCanvas {
          image-rendering: pixelated;
          width: min(94vw, 94vh);  /* square that fits either width or height */
          height: min(94vw, 94vh);
          border: 1px solid #444;
          background: #111;
        }
        #minimapHint {
          color: #aaa;
          font-size: 12px;
          text-align: center;
        }

        @media (max-width: 1100px) {
            body {
                padding: clamp(16px, 6vh, 40px) clamp(16px, 5vw, 40px);
            }
            #app-container {
                flex-direction: column;
                align-items: center;
            }
            #container,
            #ui-panel {
                width: min(100%, 700px);
                max-width: 100%;
            }
            #ui-panel {
                max-height: none;
                order: 3;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 16px;
            }
            #container,
            #ui-panel {
                width: 100%;
            }
            #controls {
                justify-content: space-between;
            }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="container">
            <h1>Roguelike Dungeon Simulator</h1>
            <div id="maze-viewport">
                <canvas id="maze-canvas"></canvas>
            </div>
            <div id="status">Generating dungeon...</div>
            <div id="controls">
                <label for="speed-slider">Speed:</label>
                <input type="range" id="speed-slider" min="1" max="50" value="12">
                <span id="speed-value">12 tps</span>
            </div>
            <div id="pause-indicator"></div>
            <button id="restartBtn" style="display: none;">Restart</button>
        </div>
        <div id="ui-panel">
            <div class="ui-section">
                <h2>Equipment</h2>
                <div id="equipment-slots" class="slot-container equipment-slots"></div>
            </div>
            <div class="ui-section" style="margin-top: 20px;">
                <h2>Inventory</h2>
                <div id="inventory-slots" class="slot-container inventory-slots"></div>
            </div>
        </div>
    </div>
    <!-- Minimap Modal -->
    <div id="minimapModal" aria-hidden="true">
      <div id="minimapPanel">
        <div id="minimapHeader">
          <span>Minimap</span>
          <button id="minimapClose" title="Close (Esc)">×</button>
        </div>
        <canvas id="minimapCanvas" width="640" height="640"></canvas>
        <div id="minimapHint">Press “m” to toggle, “Esc” to close</div>
      </div>
    </div>
    <script>
        const CONFIG = {
            visual: {
                view: { width: 41, height: 41 },
                cellSize: 20,
                minCellSize: 12,
                colors: {
                    unseen: '#111',
                    wall: '#3a2a23',
                    floor: '#222',
                    floorGlyph: '#444',
                    defaultText: '#d3d3d3',
                    start: '#4caf50',
                    end: '#f44336',
                    player: '#2196f3',
                    playerGlyph: '#fff',
                    visibleOverlay: 'rgba(255,255,102,0.20)'
                },
                light: {
                    fallbackColor: '#ffe9a6',
                    fallbackFlickerRate: 0,
                    baseOverlayAlpha: 0.20,
                    flickerVariance: 0.12
                }
            },
            ai: {
                ticksPerSecond: 12,
                shortTermMemory: 30
            },
            generator: {
                hybrid: {
                    large: {
                        roomCountRange: [1, 11],
                        areaRange: [300, 750],
                        minSide: 8,
                        minL1EdgeSpacing: 30,
                        border: 15,
                        maxAttemptsPerRoom: 600
                    },
                    small: {
                        candidateCount: 320,
                        minSize: { w: 5, h: 5 },
                        maxSize: { w: 14, h: 12 },
                        separationIters: 80,
                        keepRatio: 1.0,
                        clearanceFromLarge: 2
                    },
                    corridors: {
                        extraEdgeFraction: 0.15,
                        rescueConnectivity: true
                    }
                }
            },
            minimap: {
                padding: 1,
                colors: {
                    wall: '#3a2a23',
                    floor: '#111',
                    floorExplored: '#1a1a1a',
                    player: '#2196f3',
                    viewport: '#00bcd4',
                    border: '#333'
                }
            },
            general: {
                maxInitRetries: 10
            }
        };

        const TILE_FLOOR = 0;
        const TILE_WALL = 1;
        const DEFAULT_LIGHT_RADIUS = 1;
        const DEFAULT_MOB_HP = 10;
        const DEFAULT_MOB_SPEED = 1;
        const DEFAULT_INVENTORY_CAPACITY = 20;
        const DEFAULT_MONSTER_AGGRO_RANGE = 8;
        const SHORT_TERM_MEMORY_PENALTY = 15;
        const MINIMAP_DEFAULT_DIMENSION = 640;
        const CARDINAL_DIRECTIONS = Object.freeze([
            { dx: 1, dy: 0 },
            { dx: -1, dy: 0 },
            { dx: 0, dy: 1 },
            { dx: 0, dy: -1 },
        ]);
        const WEAPON_CATEGORY = Object.freeze({
            MELEE: 'melee',
            BOW: 'bow',
            CROSSBOW: 'crossbow',
            SLING: 'sling',
            THROWN: 'thrown',
        });
        const RANGED_WEAPON_CATEGORIES = new Set([
            WEAPON_CATEGORY.BOW,
            WEAPON_CATEGORY.CROSSBOW,
            WEAPON_CATEGORY.SLING,
            WEAPON_CATEGORY.THROWN,
        ]);
        // Transformation matrices for the eight octants used during shadowcasting
        // field-of-view calculations. Each entry is [xx, xy, yx, yy] for one octant.
        const FOV_TRANSFORMS = [
            [1, 0, 0, 1],
            [0, 1, 1, 0],
            [0, -1, 1, 0],
            [-1, 0, 0, 1],
            [-1, 0, 0, -1],
            [0, -1, -1, 0],
            [0, 1, -1, 0],
            [1, 0, 0, -1],
        ];

        // ===================== STATUS SYSTEM =====================

        const DAMAGE_TYPE = Object.freeze({
            PHYSICAL: "physical",
            FIRE: "fire",
            COLD: "cold",
            LIGHTNING: "lightning",
            POISON: "poison",
            ARCANE: "arcane",
        });

        const STATUS_IDS = Object.freeze([
            "burn", "bleed", "poisoned", "frozen", "shocked",
            "stunned", "slowed", "silenced", "weakened", "confused",
            "haste"
        ]);

        const STACKING_RULE = Object.freeze({
            REFRESH: "refresh",
            ADD_STACKS: "add_stacks",
            INDEPENDENT: "independent",
        });

        function createEmptyDamageTypeMap() {
            return Object.create(null);
        }

        function createEmptyStatusDerivedMods() {
            return {
                moveAPDelta: 0,
                actionSpeedPct: 0,
                accuracyFlat: 0,
                critChancePct: 0,
                canAct: true,
                damageDealtMult: createEmptyDamageTypeMap(),
                damageTakenMult: createEmptyDamageTypeMap(),
                resistDelta: createEmptyDamageTypeMap(),
            };
        }

        function createDefaultStatusModCache() {
            return {
                inflictBonus: Object.create(null),
                inflictDurMult: Object.create(null),
                recvDurMult: Object.create(null),
                resistBonus: Object.create(null),
                freeAction: {
                    ignore: new Set(),
                },
            };
        }

        function createDefaultModCache() {
            return {
                status: createDefaultStatusModCache(),
            };
        }

        const StatusRegistry = new Map();

        function registerStatus(def) {
            if (!def || !def.id) {
                throw new Error("registerStatus requires an id");
            }
            StatusRegistry.set(def.id, def);
        }

        function getStatus(id) {
            if (!StatusRegistry.has(id)) {
                throw new Error(`Unknown status definition: ${id}`);
            }
            return StatusRegistry.get(id);
        }

        function rebuildStatusDerivedCache(actor) {
            if (!actor) return;
            const agg = createEmptyStatusDerivedMods();
            const statuses = Array.isArray(actor.statuses) ? actor.statuses : [];
            for (const st of statuses) {
                const def = StatusRegistry.get(st.id);
                if (!def || typeof def.derive !== "function") continue;
                const derived = def.derive({ target: actor, stacks: st.stacks ?? 1, potency: st.potency });
                if (!derived) continue;
                if (typeof derived.canAct === "boolean") {
                    agg.canAct = agg.canAct && derived.canAct;
                }
                if (typeof derived.moveAPDelta === "number") {
                    agg.moveAPDelta += derived.moveAPDelta;
                }
                if (typeof derived.actionSpeedPct === "number") {
                    agg.actionSpeedPct += derived.actionSpeedPct;
                }
                if (typeof derived.accuracyFlat === "number") {
                    agg.accuracyFlat += derived.accuracyFlat;
                }
                if (typeof derived.critChancePct === "number") {
                    agg.critChancePct += derived.critChancePct;
                }
                if (derived.damageDealtMult) {
                    for (const [k, v] of Object.entries(derived.damageDealtMult)) {
                        if (typeof v !== "number") continue;
                        agg.damageDealtMult[k] = (agg.damageDealtMult[k] ?? 0) + v;
                    }
                }
                if (derived.damageTakenMult) {
                    for (const [k, v] of Object.entries(derived.damageTakenMult)) {
                        if (typeof v !== "number") continue;
                        agg.damageTakenMult[k] = (agg.damageTakenMult[k] ?? 0) + v;
                    }
                }
                if (derived.resistDelta) {
                    for (const [k, v] of Object.entries(derived.resistDelta)) {
                        if (typeof v !== "number") continue;
                        agg.resistDelta[k] = (agg.resistDelta[k] ?? 0) + v;
                    }
                }
            }
            actor.statusDerived = agg;
        }

        function tickStatusesAtTurnStart(actor, turn) {
            if (!actor) return;
            if (!Array.isArray(actor.statuses)) {
                actor.statuses = [];
            }
            const expired = [];
            for (const st of actor.statuses) {
                const def = StatusRegistry.get(st.id);
                if (!def) continue;
                if (def.tickEvery && st.nextTickAt != null) {
                    while (turn >= st.nextTickAt) {
                        def.onTick?.({
                            target: actor,
                            source: st.source,
                            stacks: st.stacks ?? 1,
                            potency: st.potency,
                            turn: st.nextTickAt,
                        });
                        actor.__log?.statusTick?.(st.id, {
                            turn: st.nextTickAt,
                            stacks: st.stacks ?? 1,
                            potency: st.potency,
                        });
                        st.nextTickAt += def.tickEvery;
                    }
                }
                if (turn >= st.endsAtTurn) {
                    def.onExpire?.({
                        target: actor,
                        source: st.source,
                        stacks: st.stacks ?? 1,
                        potency: st.potency,
                        turn,
                    });
                    actor.__log?.statusExpire?.(st.id, {
                        turn,
                        stacks: st.stacks ?? 1,
                        potency: st.potency,
                    });
                    expired.push(st);
                }
            }
            if (expired.length) {
                actor.statuses = actor.statuses.filter(s => !expired.includes(s));
            }
            rebuildStatusDerivedCache(actor);
        }

        function applyStatuses(ctx, S, D, turn) {
            if (!D) return [];
            if (!Array.isArray(D.statuses)) {
                D.statuses = [];
            }
            if (!D.modCache) {
                D.modCache = createDefaultModCache();
            }
            if (!S.modCache) {
                S.modCache = createDefaultModCache();
            }
            if (!D.modCache.status) {
                D.modCache.status = createDefaultStatusModCache();
            }
            if (!S.modCache.status) {
                S.modCache.status = createDefaultStatusModCache();
            }
            const applied = [];
            const attempts = ctx?.statusAttempts ?? [];
            const defenderStatusMods = D.modCache.status ?? createDefaultStatusModCache();

            for (const a of attempts) {
                const def = StatusRegistry.get(a.id);
                if (!def) continue;

                let p = a.baseChance ?? 0;
                const attackerMods = S.modCache.status ?? createDefaultStatusModCache();
                p += attackerMods.inflictBonus?.[a.id] ?? 0;
                p -= defenderStatusMods.resistBonus?.[a.id] ?? 0;
                p = Math.max(0, Math.min(1, p));
                if (p <= 0) continue;

                if (defenderStatusMods.freeAction?.ignore instanceof Set && defenderStatusMods.freeAction.ignore.has(a.id)) {
                    continue;
                }

                if (Math.random() >= p) continue;

                const attackerDurMult = attackerMods.inflictDurMult?.[a.id] ?? 1;
                const defenderDurMult = defenderStatusMods.recvDurMult?.[a.id] ?? 1;
                const baseDur = Math.max(1, Math.ceil((a.baseDuration ?? 1) * attackerDurMult * defenderDurMult));

                if (def.stacking === STACKING_RULE.INDEPENDENT) {
                    const inst = {
                        id: a.id,
                        stacks: 1,
                        potency: undefined,
                        nextTickAt: def.tickEvery ? turn + def.tickEvery : undefined,
                        endsAtTurn: turn + baseDur,
                        source: S?.id,
                    };
                    const appliedData = def.onApply?.({ target: D, source: S, stacks: 1, turn });
                    if (appliedData && appliedData.potency !== undefined) {
                        inst.potency = appliedData.potency;
                    }
                    D.statuses.push(inst);
                    applied.push(inst);
                    D.__log?.statusApply?.(a.id, { chance: p, baseChance: a.baseChance ?? 0, duration: baseDur });
                } else {
                    let ex = D.statuses.find(s => s.id === a.id);
                    if (!ex) {
                        const stacks = a.stacks ?? 1;
                        ex = {
                            id: a.id,
                            stacks,
                            potency: undefined,
                            nextTickAt: def.tickEvery ? turn + def.tickEvery : undefined,
                            endsAtTurn: turn + baseDur,
                            source: S?.id,
                        };
                        const appliedData = def.onApply?.({ target: D, source: S, stacks, turn });
                        if (appliedData && appliedData.potency !== undefined) {
                            ex.potency = appliedData.potency;
                        }
                        D.statuses.push(ex);
                        applied.push(ex);
                        D.__log?.statusApply?.(a.id, { chance: p, baseChance: a.baseChance ?? 0, duration: baseDur, stacks });
                    } else {
                        if (def.stacking === STACKING_RULE.REFRESH) {
                            ex.endsAtTurn = Math.max(ex.endsAtTurn, turn + baseDur);
                        } else if (def.stacking === STACKING_RULE.ADD_STACKS) {
                            const addStacks = a.stacks ?? 1;
                            const maxStacks = def.maxStacks ?? 999;
                            ex.stacks = Math.min((ex.stacks ?? 1) + addStacks, maxStacks);
                            ex.endsAtTurn = Math.max(ex.endsAtTurn, turn + baseDur);
                        }
                        D.__log?.statusApply?.(a.id, { chance: p, baseChance: a.baseChance ?? 0, duration: baseDur, stacks: ex.stacks });
                    }
                }
            }

            if (applied.length) {
                rebuildStatusDerivedCache(D);
            }
            return applied;
        }

        class RingBuffer {
            constructor(capacity = 64) {
                this.capacity = capacity;
                this.buffer = [];
            }
            push(value) {
                if (this.buffer.length >= this.capacity) {
                    this.buffer.shift();
                }
                this.buffer.push(value);
            }
            toArray() {
                return this.buffer.slice();
            }
        }

        function attachDebug(mob) {
            if (!mob || mob.__log) return;
            const rb = new RingBuffer(128);
            mob.__log = {
                push: (event) => rb.push(event),
                attackStep: (step, data) => rb.push({ kind: "attack_step", step, data }),
                statusApply: (id, data) => rb.push({ kind: "status_apply", id, data }),
                statusTick: (id, data) => rb.push({ kind: "status_tick", id, data }),
                statusExpire: (id, data) => rb.push({ kind: "status_expire", id, data }),
                dump: () => rb.toArray(),
            };
        }

        window.attachDebug = attachDebug;
        window.StatusRegistry = StatusRegistry;
        window.getStatus = getStatus;
        window.applyStatuses = applyStatuses;

        registerStatus({
            id: "burn",
            label: "Burning",
            harmful: true,
            stacking: STACKING_RULE.ADD_STACKS,
            maxStacks: 5,
            tickEvery: 1,
            onTick: ({ target, stacks = 1 }) => {
                const dot = 1 + stacks;
                if (typeof target.hp === "number") {
                    target.hp -= dot;
                }
                target.__log?.statusTick?.("burn", { dot, stacks });
            },
            derive: ({ stacks = 1 }) => ({
                damageTakenMult: { cold: -0.1, fire: 0.25 },
            }),
        });

        registerStatus({
            id: "poisoned",
            label: "Poisoned",
            harmful: true,
            stacking: STACKING_RULE.INDEPENDENT,
            tickEvery: 1,
            onTick: ({ target, potency = 1 }) => {
                const dot = Math.ceil(1.5 * potency);
                if (typeof target.hp === "number") {
                    target.hp -= dot;
                }
                target.__log?.statusTick?.("poisoned", { dot, potency });
            },
            onApply: () => ({ potency: 1 }),
        });

        registerStatus({
            id: "slowed",
            label: "Slowed",
            harmful: true,
            stacking: STACKING_RULE.REFRESH,
            derive: ({ stacks = 1 }) => ({
                actionSpeedPct: 0.10 * stacks,
                moveAPDelta: 0.1,
            }),
        });

        registerStatus({
            id: "stunned",
            label: "Stunned",
            harmful: true,
            stacking: STACKING_RULE.REFRESH,
            derive: () => ({ canAct: false }),
        });

        registerStatus({
            id: "haste",
            label: "Haste",
            harmful: false,
            stacking: STACKING_RULE.REFRESH,
            derive: ({ stacks = 1 }) => ({ actionSpeedPct: 0.15 * stacks }),
        });

        const Game = (() => {
            const viewportEl = document.getElementById('maze-viewport');
            const canvas = document.getElementById('maze-canvas');
            const ctx = canvas.getContext('2d');
            const statusDiv = document.getElementById('status');
            const restartBtn = document.getElementById('restartBtn');
            const equipmentSlotsDiv = document.getElementById('equipment-slots');
            const inventorySlotsDiv = document.getElementById('inventory-slots');
            const speedSlider = document.getElementById('speed-slider');
            const speedValue = document.getElementById('speed-value');
            const pauseIndicator = document.getElementById('pause-indicator');
            const containerEl = document.getElementById('container');

        let minimapModalEl, minimapCanvas, minimapCtx, minimapCloseBtn;

        const simState = {
            timeout: null,
            loopFn: null,
            isPaused: false,
            speed: CONFIG.ai.ticksPerSecond,
            isReady: false,
            turnCounter: 0,
        };

        const mapState = {
            width: 0,
            height: 0,
            grid: [],
            explored: [],
            known: [],
        };

        const fovState = {
            currentVisible: new Set(),
            prevVisible: new Set(),
            lastCache: { key: null, radius: null, visible: null },
            overlayStyle: CONFIG.visual.colors.visibleOverlay,
        };

        const explorationState = {
            frontiers: new Set(),
            newlyExplored: [],
        };

        let player = {};
        let mobManager = null;
        let isEndRendered = false;
        const INVALID_POSITION_COORD = -1;
        let prevPlayerPos = { x: INVALID_POSITION_COORD, y: INVALID_POSITION_COORD };
        let hasPrevPlayerPos = false;
        let currentEndPos = null;
        let initRetries = 0;

        const rawLightConfig = CONFIG.visual.light || {};
        const LIGHT_CONFIG = {
            fallbackColor: rawLightConfig.fallbackColor || '#ffe9a6',
            fallbackFlickerRate: (typeof rawLightConfig.fallbackFlickerRate === 'number') ? rawLightConfig.fallbackFlickerRate : 0,
            baseOverlayAlpha: (typeof rawLightConfig.baseOverlayAlpha === 'number') ? rawLightConfig.baseOverlayAlpha : 0.20,
            flickerVariance: (typeof rawLightConfig.flickerVariance === 'number') ? rawLightConfig.flickerVariance : 0.12
        };

        
        const VIEW_W = CONFIG.visual.view.width;
        const VIEW_H = CONFIG.visual.view.height;
        const MIN_CELL_SIZE = CONFIG.visual.minCellSize;
        let CELL_SIZE = CONFIG.visual.cellSize;
        let HALF_CELL = CELL_SIZE / 2;
        const MAX_INIT_RETRIES = CONFIG.general.maxInitRetries;
        
        // ===================== EQUIPMENT MODEL =====================

        // ---- Slot enum (canonical names)
        const SLOT = {
            Head: "Head",
            LeftHand: "LeftHand",
            RightHand: "RightHand",
            LeftRing: "LeftRing",
            RightRing: "RightRing",
            Amulet: "Amulet",
            BodyArmor: "BodyArmor",
            Cloak: "Cloak",
            Boots: "Boots",
            Gloves: "Gloves",
            Belt: "Belt",        // the belt garment itself
            Belt1: "Belt1",      // attachments on belt
            Belt2: "Belt2",
            Belt3: "Belt3",
            Belt4: "Belt4",
            Backpack: "Backpack",
            Quiver: "Quiver",
        };

        // Legacy aliases so existing UI keeps showing something
        const LEGACY_SLOT_ALIAS = new Map([
            ["Left", SLOT.LeftHand],
            ["Right", SLOT.RightHand],
            ["Body", SLOT.BodyArmor],
        ]);

        // Order for rendering later
        const ALL_SLOTS_ORDER = [
            SLOT.Head,
            SLOT.Amulet,
            SLOT.LeftRing, SLOT.RightRing,
            SLOT.Cloak,
            SLOT.BodyArmor,
            SLOT.Gloves, SLOT.Boots,
            SLOT.LeftHand, SLOT.RightHand,
            SLOT.Belt, SLOT.Belt1, SLOT.Belt2, SLOT.Belt3, SLOT.Belt4,
            SLOT.Backpack,
            SLOT.Quiver,
        ];

        const SLOT_LABELS = {
            [SLOT.Head]: 'Head',
            [SLOT.Amulet]: 'Amulet',
            [SLOT.LeftRing]: 'Left Ring',
            [SLOT.RightRing]: 'Right Ring',
            [SLOT.Cloak]: 'Cloak',
            [SLOT.BodyArmor]: 'Body',
            [SLOT.Gloves]: 'Gloves',
            [SLOT.Boots]: 'Boots',
            [SLOT.LeftHand]: 'Left Hand',
            [SLOT.RightHand]: 'Right Hand',
            [SLOT.Belt]: 'Belt',
            [SLOT.Belt1]: 'Belt Slot 1',
            [SLOT.Belt2]: 'Belt Slot 2',
            [SLOT.Belt3]: 'Belt Slot 3',
            [SLOT.Belt4]: 'Belt Slot 4',
            [SLOT.Backpack]: 'Backpack',
            [SLOT.Quiver]: 'Quiver',
        };

        function labelForSlot(slot) {
            if (SLOT_LABELS[slot]) return SLOT_LABELS[slot];
            return slot
                .replace(/([a-z])([A-Z])/g, '$1 $2')
                .replace(/\b(\w)/g, (_, c) => c.toUpperCase());
        }

        // ---- Physical helpers (dimensions in cm, mass in kg)
        function dimsVolumeL(d) { return (d.l * d.w * d.h) / 1000.0; } // cm^3 to liters
        function dimsLongest(d) { return Math.max(d.l, d.w, d.h); }

        function clamp01(value) {
            if (!Number.isFinite(value)) return 0;
            if (value <= 0) return 0;
            if (value >= 1) return 1;
            return value;
        }

        function normalizeDamageProfile(dmg) {
            if (!dmg) {
                return { diceCount: 1, diceSides: 4, bonus: 0 };
            }
            const diceCount = Math.max(0, Math.floor(dmg.diceCount ?? dmg.dice ?? 1));
            const diceSides = Math.max(1, Math.floor(dmg.diceSides ?? dmg.sides ?? 6));
            const bonus = Math.floor(dmg.bonus ?? dmg.flat ?? 0);
            return { diceCount, diceSides, bonus };
        }

        function computeHeftScore(item) {
            if (!item) return 0.5;
            const dims = item.dims || { l: 1, w: 1, h: 1 };
            const longest = Math.max(dims.l || 1, dims.w || 1, dims.h || 1);
            const mass = Math.max(0.05, item.mass ?? 0.1);
            // Heft combines mass with the leverage granted by item length.
            return mass * (0.6 + longest / 60);
        }

        function defaultThrowDamageForItem(item) {
            const heft = computeHeftScore(item);
            let diceSides = 2;
            if (heft <= 0.75) diceSides = 2;
            else if (heft <= 1.5) diceSides = 3;
            else if (heft <= 2.5) diceSides = 4;
            else if (heft <= 4) diceSides = 6;
            else if (heft <= 6) diceSides = 8;
            else if (heft <= 8) diceSides = 10;
            else diceSides = 12;
            const bonus = Math.max(0, Math.floor((heft - 2.5) / 2));
            return { diceCount: 1, diceSides, bonus };
        }

        function defaultThrowRangeForItem(item) {
            const dims = (item && item.dims) ? item.dims : { l: 1, w: 1, h: 1 };
            const longest = Math.max(dims.l || 1, dims.w || 1, dims.h || 1);
            const optimal = Math.max(2, Math.min(5, Math.round(1 + longest / 60)));
            const max = Math.max(optimal + 1, Math.min(7, optimal + Math.round(longest / 50)));
            return { min: 1, optimal, max };
        }

        function normalizeThrowProfile(profile, item) {
            const baseRange = profile?.range || {};
            const defaults = defaultThrowRangeForItem(item);
            const min = Math.max(1, Math.floor(baseRange.min ?? defaults.min));
            const optimal = Math.max(min, Math.floor(baseRange.optimal ?? defaults.optimal));
            const max = Math.max(optimal, Math.floor(baseRange.max ?? defaults.max));
            const damage = normalizeDamageProfile(profile?.damage ?? defaultThrowDamageForItem(item));
            const accuracy = typeof profile?.accuracy === 'number' ? profile.accuracy : 0;
            const consumesItem = profile?.consumesItem !== undefined ? !!profile.consumesItem : true;
            const recoveryChance = clamp01(profile?.recoveryChance ?? 0);
            const notes = profile?.notes || null;
            return {
                range: { min, optimal, max },
                damage,
                accuracy,
                consumesItem,
                recoveryChance,
                notes,
            };
        }

        function cloneThrowProfile(profile) {
            if (!profile) return null;
            return {
                range: profile.range ? { ...profile.range } : null,
                damage: profile.damage ? { ...profile.damage } : null,
                accuracy: profile.accuracy,
                consumesItem: profile.consumesItem,
                recoveryChance: profile.recoveryChance,
                notes: profile.notes || null,
            };
        }

        function normalizeAmmoProfile(ammo) {
            if (!ammo) return null;
            if (typeof ammo === 'string') {
                return { type: ammo, typePrefix: ammo, perShot: 1, consumesItem: false };
            }
            return {
                type: ammo.type ?? null,
                typePrefix: ammo.typePrefix ?? ammo.type ?? null,
                itemId: ammo.itemId ?? null,
                perShot: Math.max(1, ammo.perShot ?? 1),
                consumesItem: !!ammo.consumesItem,
                label: ammo.label || null,
            };
        }

        function normalizeWeaponProfile(profile) {
            if (!profile) return null;
            const category = profile.category || WEAPON_CATEGORY.MELEE;
            const rangeIn = profile.range || {};
            const min = Math.max(0, Math.floor(rangeIn.min ?? 0));
            const optimal = Math.max(min, Math.floor(rangeIn.optimal ?? rangeIn.ideal ?? min));
            const max = Math.max(optimal, Math.floor(rangeIn.max ?? rangeIn.long ?? optimal));
            return {
                category,
                isRanged: RANGED_WEAPON_CATEGORIES.has(category),
                range: { min, optimal, max },
                reloadTime: Math.max(0, Math.floor(profile.reloadTime ?? profile.reload ?? 0)),
                aimTime: Math.max(0, Math.floor(profile.aimTime ?? profile.aim ?? 0)),
                volley: Math.max(1, Math.floor(profile.volley ?? 1)),
                ammo: normalizeAmmoProfile(profile.ammo),
                damage: normalizeDamageProfile(profile.damage),
                accuracy: typeof profile.accuracy === 'number' ? profile.accuracy : 0,
                consumeWeaponOnUse: profile.consumeWeaponOnUse ?? (category === WEAPON_CATEGORY.THROWN && !profile.ammo),
                recoveryChance: clamp01(profile.recoveryChance ?? 0),
                notes: profile.notes || null,
            };
        }

        function cloneWeaponProfile(profile) {
            if (!profile) return null;
            return {
                category: profile.category,
                isRanged: profile.isRanged,
                range: profile.range ? { ...profile.range } : null,
                reloadTime: profile.reloadTime,
                aimTime: profile.aimTime,
                volley: profile.volley,
                ammo: profile.ammo ? { ...profile.ammo } : null,
                damage: profile.damage ? { ...profile.damage } : null,
                accuracy: profile.accuracy,
                consumeWeaponOnUse: profile.consumeWeaponOnUse,
                recoveryChance: profile.recoveryChance,
                notes: profile.notes,
            };
        }

        // ===== GAME MODELS =====
        // ---- Items ----

        class Item {
            // id: stable id; name: label; kind: "weapon","armor","jewelry","container","tool","ammo","misc"
            // equipSlots: array of SLOT names where this can be equipped
            // handsRequired: 1 or 2 for weapons
            // dims: {l,w,h} in cm; mass: kg
            // stackable/maxStack: for things like arrows, torches
            // lightRadius: tiles if lit (lantern/torch); lightColor: CSS color string for emitted light
            // flickerRate: oscillations per second controlling light intensity flicker
            // container: optional { volumeL, maxMassKg, maxItemLengthCm, accepts: fn(item) -> boolean }
            constructor(o) {
                this.id = o.id;
                this.name = o.name;
                this.kind = o.kind;
                this.equipSlots = Array.isArray(o.equipSlots) ? o.equipSlots.slice() : [];
                this.handsRequired = o.handsRequired ?? 0;
                this.dims = o.dims ?? { l: 1, w: 1, h: 1 };
                this.mass = o.mass ?? 0.1;
                this.stackable = !!o.stackable;
                this.maxStack = o.maxStack ?? (this.stackable ? 99 : 1);
                this.lightRadius = o.lightRadius ?? 0;
                this.lightColor = o.lightColor ?? null;
                this.flickerRate = (typeof o.flickerRate === 'number') ? o.flickerRate : 0;
                this.container = o.container ? { ...o.container } : null;
                // Runtime state for containers (contents as stacks)
                if (this.container) this.contents = [];
                this.throwProfile = normalizeThrowProfile(o.throwProfile || null, this);
                this.weaponProfile = normalizeWeaponProfile(o.weaponProfile);
            }
            isWeapon() { return this.kind === "weapon" || !!this.weaponProfile; }
            isRangedWeapon() { return !!(this.weaponProfile && this.weaponProfile.isRanged); }
            isThrowable() { return !!this.throwProfile; }
            getThrowProfile() {
                return this.throwProfile ? cloneThrowProfile(this.throwProfile) : null;
            }
            clone() {
                const copy = {
                    id: this.id,
                    name: this.name,
                    kind: this.kind,
                    equipSlots: Array.isArray(this.equipSlots) ? this.equipSlots.slice() : this.equipSlots,
                    handsRequired: this.handsRequired,
                    dims: this.dims ? { ...this.dims } : undefined,
                    mass: this.mass,
                    stackable: this.stackable,
                    maxStack: this.maxStack,
                    lightRadius: this.lightRadius,
                    lightColor: this.lightColor,
                    flickerRate: this.flickerRate,
                    container: null,
                    throwProfile: this.throwProfile ? cloneThrowProfile(this.throwProfile) : null,
                    weaponProfile: cloneWeaponProfile(this.weaponProfile),
                };

                if (this.container) {
                    copy.container = { ...this.container };
                }

                const cloned = new Item(copy);

                if (Array.isArray(this.contents)) {
                    cloned.contents = this.contents.slice();
                }

                return cloned;
            }
            canEquipTo(slot) { return this.equipSlots.includes(slot); }
            volumeLPerUnit() { return dimsVolumeL(this.dims); }
            longestCm() { return dimsLongest(this.dims); }
        }

        // Stack of identical items
        class ItemStack {
            constructor(item, qty = 1) {
                if (!(item instanceof Item)) throw new Error("ItemStack needs Item");
                this.item = item;
                this.qty = qty;
            }
            get id() { return this.item.id; }
            get name() { return this.item.name; }
            get stackable() { return this.item.stackable; }
            get maxStack() { return this.item.maxStack; }
            totalMassKg() { return this.item.mass * this.qty; }
            totalVolumeL() { return this.item.volumeLPerUnit() * this.qty; }
            canMerge(other) { return this.stackable && other.stackable && this.id === other.id; }
            consume(n = 1) {
                if (!this.stackable) return false;
                const amount = Number.isFinite(n) ? Math.max(0, Math.floor(n)) : 0;
                if (amount === 0) return true;
                if (this.qty < amount) return false;
                this.qty -= amount;
                return true;
            }
        }

        // Registry
        const ItemRegistry = new Map();
        function registerItem(def) { ItemRegistry.set(def.id, new Item(def)); }
        function makeItem(id) {
            const t = ItemRegistry.get(id);
            if (!t) throw new Error("Unknown item: " + id);
            return t.clone();
        }

        // ---- Inventory ----
        // This represents the carried inventory. Capacity is enforced by the equipped Backpack.

        class Inventory {
            constructor(slotCount = 20) {
                this.capacitySlots = slotCount;             // UI slots; you can raise this later
                this.stacks = Array.from({ length: slotCount }, () => null);
                this.constraints = null;                     // set from equipped backpack
            }
            setConstraints(c) { this.constraints = c ? { ...c } : null; }
            list() { return this.stacks; }

            usedMassKg() {
                let m = 0;
                for (const s of this.stacks) if (s) m += s.totalMassKg();
                return m;
                }
            usedVolumeL() {
                let v = 0;
                for (const s of this.stacks) if (s) v += s.totalVolumeL();
                return v;
            }
            longestItemCm() {
                let L = 0;
                for (const s of this.stacks) if (s) L = Math.max(L, s.item.longestCm());
                return L;
            }

            // capacity check vs backpack constraints
            fitsConstraints(stack) {
                if (!this.constraints) return true; // no backpack equipped => unrestricted (you may change this)
                const cap = this.constraints;
                const massAfter = this.usedMassKg() + stack.totalMassKg();
                const volAfter  = this.usedVolumeL() + stack.totalVolumeL();
                const longest   = Math.max(this.longestItemCm(), stack.item.longestCm());
                if (massAfter > cap.maxMassKg) return false;
                if (volAfter  > cap.volumeL) return false;
                if (longest   > cap.maxItemLengthCm) return false;
                if (typeof cap.accepts === "function" && !cap.accepts(stack.item)) return false;
                return true;
            }

            add(itemOrStack) {
                const incoming = (itemOrStack instanceof ItemStack) ? itemOrStack : new ItemStack(itemOrStack, 1);
                const merges = [];
                const newSlots = [];
                let mergedTotalQty = 0;
                let placedTotalQty = 0;
                const rollback = () => {
                    for (const { index, added } of merges) {
                        const stack = this.stacks[index];
                        if (stack) {
                            stack.qty -= added;
                            if (stack.qty === 0) this.stacks[index] = null;
                        }
                    }
                    for (const { index } of newSlots) {
                        this.stacks[index] = null;
                    }
                    incoming.qty += mergedTotalQty + placedTotalQty;
                    merges.length = 0;
                    newSlots.length = 0;
                    mergedTotalQty = 0;
                    placedTotalQty = 0;
                };
                // Try merge first
                if (incoming.stackable) {
                    for (let i = 0; i < this.stacks.length && incoming.qty > 0; i++) {
                        const s = this.stacks[i];
                        if (s && s.canMerge(incoming) && s.qty < s.maxStack) {
                            const space = s.maxStack - s.qty;
                            const moved = Math.min(space, incoming.qty);
                            const tmp = new ItemStack(incoming.item.clone(), moved);
                            if (!this.fitsConstraints(tmp)) { rollback(); return false; }
                            s.qty += moved;
                            merges.push({ index: i, added: moved });
                            mergedTotalQty += moved;
                            incoming.qty -= moved;
                        }
                    }
                    if (incoming.qty <= 0) return true;
                }
                // Place into free slots, respecting stack limits
                for (let i = 0; i < this.stacks.length && incoming.qty > 0; i++) {
                    if (!this.stacks[i]) {
                        const maxPerSlot = (typeof incoming.maxStack === 'number' && incoming.maxStack > 0)
                            ? incoming.maxStack
                            : 1;
                        const qtyToStore = Math.min(incoming.qty, maxPerSlot);
                        if (qtyToStore <= 0) { rollback(); return false; }
                        const tmp = new ItemStack(incoming.item.clone(), qtyToStore);
                        if (!this.fitsConstraints(tmp)) { rollback(); return false; }
                        this.stacks[i] = tmp;
                        newSlots.push({ index: i });
                        placedTotalQty += qtyToStore;
                        incoming.qty -= qtyToStore;
                    }
                }
                if (incoming.qty <= 0) return true;
                rollback();
                return false;
            }

            removeByIndex(idx, qty = Infinity) {
                const s = this.stacks[idx];
                if (!s) return null;
                const take = Math.min(qty, s.qty);
                s.qty -= take;
                if (s.qty <= 0) this.stacks[idx] = null;
                return new ItemStack(s.item.clone(), take);
            }
            findStack(predicate) {
                if (typeof predicate !== 'function') return null;
                for (let i = 0; i < this.stacks.length; i++) {
                    const stack = this.stacks[i];
                    if (stack && predicate(stack, i)) {
                        return { index: i, stack };
                    }
                }
                return null;
            }
            consumeAt(index, qty = 1) {
                if (index < 0 || index >= this.stacks.length) return false;
                const stack = this.stacks[index];
                if (!stack) return false;
                if (qty <= 0) return true;
                if (stack.qty < qty) return false;
                stack.qty -= qty;
                if (stack.qty === 0) this.stacks[index] = null;
                return true;
            }
            consumeMatching(predicate, qty = 1) {
                const found = this.findStack(predicate);
                if (!found) return false;
                return this.consumeAt(found.index, qty);
            }
        }

        // ---- Equipment ----
        // Enforces slot compatibility and 2H weapon occupancy.

        class Equipment {
            constructor() {
                this.slots = new Map();
                for (const s of ALL_SLOTS_ORDER) this.slots.set(s, null);
                // Derived occupancy marker for two-handed
                this._twoHandOccupantId = null;
            }

            get(slot) { return this.slots.get(slot) || null; }
            all() { return Array.from(this.slots.entries()); }

            // For legacy UI; maps to the 5 old labels
            asLegacyRecord() {
                return {
                    Head: this.get(SLOT.Head),
                    Body: this.get(SLOT.BodyArmor),
                    Left: this.get(SLOT.LeftHand),
                    Right: this.get(SLOT.RightHand),
                    Belt: this.get(SLOT.Belt),
                };
            }

            canEquipTo(slot, item) {
                if (!(item instanceof Item)) return false;
                if (!this.slots.has(slot)) return false;
                if (!item.canEquipTo(slot)) return false;
                // Two-handed weapon needs both hands free
                if ((slot === SLOT.LeftHand || slot === SLOT.RightHand) && item.handsRequired === 2) {
                    const other = (slot === SLOT.LeftHand) ? SLOT.RightHand : SLOT.LeftHand;
                    if (this.get(other)) return false;
                }
                return true;
            }

            equipTo(slot, item) {
                if (!this.canEquipTo(slot, item)) return false;
                // Clear any two-hand occupancy first
                if (this._twoHandOccupantId && (slot === SLOT.LeftHand || slot === SLOT.RightHand)) {
                    this.slots.set(SLOT.LeftHand, null);
                    this.slots.set(SLOT.RightHand, null);
                    this._twoHandOccupantId = null;
                }
                this.slots.set(slot, item);
                // If 2H, occupy both hands
                if ((slot === SLOT.LeftHand || slot === SLOT.RightHand) && item.handsRequired === 2) {
                    const other = (slot === SLOT.LeftHand) ? SLOT.RightHand : SLOT.LeftHand;
                    this.slots.set(other, item); // same reference
                    this._twoHandOccupantId = item.id;
                }
                return true;
            }

            unequip(slot) {
                const it = this.get(slot);
                // If removing a 2H item from either hand, clear both
                if (it && (slot === SLOT.LeftHand || slot === SLOT.RightHand) && it.handsRequired === 2) {
                    this.slots.set(SLOT.LeftHand, null);
                    this.slots.set(SLOT.RightHand, null);
                    this._twoHandOccupantId = null;
                    return it;
                }
                this.slots.set(slot, null);
                return it;
            }
            removeItemInstance(item) {
                if (!item) return false;
                for (const [slot, equipped] of this.slots.entries()) {
                    if (equipped === item) {
                        this.unequip(slot);
                        return true;
                    }
                }
                return false;
            }

            getLightSourceProperties(defaults = null) {
                const fallback = defaults ? { ...defaults } : {
                    radius: DEFAULT_LIGHT_RADIUS,
                    color: LIGHT_CONFIG.fallbackColor,
                    flickerRate: LIGHT_CONFIG.fallbackFlickerRate
                };
                let best = { ...fallback };
                let usingFallback = true;
                for (const [, it] of this.slots) {
                    if (!it || !it.lightRadius) continue;
                    const candidate = {
                        radius: it.lightRadius,
                        color: it.lightColor || fallback.color,
                        flickerRate: (typeof it.flickerRate === 'number') ? it.flickerRate : fallback.flickerRate
                    };
                    if (candidate.radius > best.radius || (usingFallback && candidate.radius === best.radius)) {
                        best = candidate;
                        usingFallback = false;
                    }
                }
                return best;
            }

            getLightRadius() {
                return this.getLightSourceProperties().radius;
            }

            getLightColor() {
                return this.getLightSourceProperties().color;
            }

            getLightFlickerRate() {
                return this.getLightSourceProperties().flickerRate;
            }

            currentBackpackConstraints() {
                const pack = this.get(SLOT.Backpack);
                return pack && pack.container ? {
                    volumeL: pack.container.volumeL,
                    maxMassKg: pack.container.maxMassKg,
                    maxItemLengthCm: pack.container.maxItemLengthCm,
                    accepts: pack.container.accepts || null
                } : null;
            }
        }

        // ---- Mobs ----

        let __mobAutoId = 1;

        class Mob {
            constructor(o) {
                this.id = __mobAutoId++;
                this.kind = o.kind;
                this.name = o.name;
                this.x = o.x | 0;
                this.y = o.y | 0;
                this.hp = o.hp ?? DEFAULT_MOB_HP;
                this.maxHp = this.hp;
                this.speed = o.speed ?? DEFAULT_MOB_SPEED;
                this.glyph = o.glyph ?? "?";
                this.color = o.color ?? "#fff";
                this.equipment = new Equipment();
                this.inventory = new Inventory(DEFAULT_INVENTORY_CAPACITY);
                this.statuses = [];
                this.statusDerived = createEmptyStatusDerivedMods();
                this.modCache = createDefaultModCache();
                this.__log = null;
            }
            get pos() { return { x: this.x, y: this.y }; }
            set pos(p) { this.x = p.x | 0; this.y = p.y | 0; }
            lightRadius() { return this.equipment.getLightRadius(); }

            canOccupy(x, y, maze, mobManager = null) {
                if (y < 0 || y >= maze.length || x < 0 || x >= maze[0].length) return false;
                if (maze[y][x] === TILE_WALL) return false;
                if (mobManager && mobManager.getMobAt(x, y)) return false;
                return true;
            }
            tryMove(dx, dy, maze, mobManager = null) {
                const nx = this.x + dx, ny = this.y + dy;
                if (this.canOccupy(nx, ny, maze, mobManager)) { this.x = nx; this.y = ny; return true; }
                return false;
            }
            takeTurn(gameCtx) { /* no-op base */ }
        }

        class Player extends Mob {
            constructor(o) { super({ kind: "player", glyph: "@", color: "#fff", ...o }); }
        }

        class Monster extends Mob {
            constructor(o) {
                super({ kind: "monster", glyph: "m", color: "#f99", ...o });
                this.aggroRange = o.aggroRange ?? DEFAULT_MONSTER_AGGRO_RANGE;
            }
            takeTurn(gameCtx) {
                const { player, maze } = gameCtx;
                const dx = player.x - this.x, dy = player.y - this.y;
                const dist = Math.abs(dx) + Math.abs(dy);
                if (dist === 0) return;
                if (dist <= this.aggroRange) {
                    const step = Math.abs(dx) > Math.abs(dy) ? { dx: Math.sign(dx), dy: 0 } : { dx: 0, dy: Math.sign(dy) };
                    if (!this.tryMove(step.dx, step.dy, maze, gameCtx.mobManager)) {
                        const alt = (step.dx !== 0) ? { dx: 0, dy: Math.sign(dy) } : { dx: Math.sign(dx), dy: 0 };
                        this.tryMove(alt.dx, alt.dy, maze, gameCtx.mobManager);
                    }
                } else {
                    const { dx, dy } = CARDINAL_DIRECTIONS[(Math.random() * CARDINAL_DIRECTIONS.length) | 0];
                    this.tryMove(dx, dy, maze, gameCtx.mobManager);
                }
            }
        }

        class MobManager {
            constructor() { this.list = []; this.index = new Map(); }
            add(m) { this.list.push(m); this.reindex(); return m; }
            removeById(id) { this.list = this.list.filter(x => x.id !== id); this.reindex(); }
            getMobAt(x, y) { return this.index.get(`${x},${y}`) || null; }
            reindex() { this.index.clear(); for (const m of this.list) this.index.set(`${m.x},${m.y}`, m); }
            tick(gameCtx, turn) {
                for (const m of this.list) {
                    if (m.kind === "player") continue;
                    tickStatusesAtTurnStart(m, turn);
                    m.takeTurn(gameCtx);
                }
                this.reindex();
            }
        }

        // ===================== RANGED COMBAT HELPERS =====================

        function isRangedWeapon(item) {
            return item instanceof Item && item.isRangedWeapon();
        }

        function chebyshevDistance(a, b) {
            if (!a || !b) return Infinity;
            return Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y));
        }

        function hasLineOfSight(grid, from, to) {
            if (!grid) return true;
            if (!from || !to) return false;
            let x0 = from.x | 0;
            let y0 = from.y | 0;
            const x1 = to.x | 0;
            const y1 = to.y | 0;
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;
            const width = grid[0]?.length || 0;
            const height = grid.length || 0;
            const isBlocked = (x, y) => {
                if (x === x1 && y === y1) return false;
                if (y < 0 || y >= height || x < 0 || x >= width) return true;
                return grid[y][x] === TILE_WALL;
            };
            while (!(x0 === x1 && y0 === y1)) {
                if (!(x0 === from.x && y0 === from.y) && isBlocked(x0, y0)) return false;
                const e2 = err * 2;
                if (e2 > -dy) { err -= dy; x0 += sx; }
                if (e2 < dx) { err += dx; y0 += sy; }
            }
            return true;
        }

        function damageExpectation(dmgProfile) {
            if (!dmgProfile) return { min: 0, max: 0, avg: 0, diceCount: 0, diceSides: 0, bonus: 0 };
            const { diceCount, diceSides, bonus } = dmgProfile;
            const min = diceCount * 1 + bonus;
            const max = diceCount * diceSides + bonus;
            const avg = diceCount * (diceSides + 1) / 2 + bonus;
            return { min, max, avg, diceCount, diceSides, bonus };
        }

        function rollDamage(dmgProfile) {
            const { diceCount, diceSides, bonus } = dmgProfile || { diceCount: 0, diceSides: 0, bonus: 0 };
            const rolls = [];
            let total = bonus;
            for (let i = 0; i < diceCount; i++) {
                const roll = 1 + Math.floor(Math.random() * Math.max(1, diceSides));
                rolls.push(roll);
                total += roll;
            }
            return { total, rolls, bonus };
        }

        function describeDamage(dmgProfile) {
            if (!dmgProfile) return '';
            const { diceCount, diceSides, bonus } = dmgProfile;
            let parts = '';
            if (diceCount > 0) {
                parts = `${diceCount}d${diceSides}`;
            }
            if (bonus) {
                parts += bonus > 0 ? `+${bonus}` : `${bonus}`;
            }
            return parts || `${bonus || 0}`;
        }

        function describeAmmo(ammoProfile) {
            if (!ammoProfile) return '';
            if (ammoProfile.label) return ammoProfile.label;
            if (ammoProfile.itemId) return ammoProfile.itemId;
            if (ammoProfile.type) return ammoProfile.type;
            if (ammoProfile.typePrefix) return `${ammoProfile.typePrefix}*`;
            return '';
        }

        function ammoMatchesProfile(ammoProfile, stack) {
            if (!ammoProfile || !stack) return false;
            const id = stack.item.id;
            if (ammoProfile.itemId) return id === ammoProfile.itemId;
            if (ammoProfile.type) return id === ammoProfile.type;
            if (ammoProfile.typePrefix) return id.startsWith(ammoProfile.typePrefix);
            return false;
        }

        function findAmmoStackForProfile(mob, weaponProfile) {
            if (!weaponProfile?.ammo) return null;
            if (!mob || !mob.inventory || typeof mob.inventory.findStack !== 'function') return null;
            return mob.inventory.findStack(stack => ammoMatchesProfile(weaponProfile.ammo, stack));
        }

        function consumeThrownItemFromAttacker(attacker, item, context = {}) {
            if (!attacker) return false;
            if (context && typeof context.consumeSource === 'function') {
                const result = context.consumeSource();
                if (result) return true;
            }
            if (context && typeof context.inventoryIndex === 'number' && attacker.inventory) {
                if (attacker.inventory.consumeAt(context.inventoryIndex, 1)) return true;
            }
            if (context && context.stack && typeof context.stack.consume === 'function') {
                const consumed = context.stack.consume(1);
                if (consumed) return true;
            }
            if (context && context.equipmentSlot && attacker.equipment) {
                const equipped = attacker.equipment.get(context.equipmentSlot);
                if (equipped && (equipped === item || equipped.id === item.id)) {
                    attacker.equipment.unequip(context.equipmentSlot);
                    return true;
                }
            }
            if (attacker.equipment && attacker.equipment.slots instanceof Map) {
                for (const [slot, equipped] of attacker.equipment.slots.entries()) {
                    if (!equipped) continue;
                    if (equipped === item || equipped.id === item.id) {
                        attacker.equipment.unequip(slot);
                        return true;
                    }
                }
            }
            if (attacker.inventory && typeof attacker.inventory.consumeMatching === 'function') {
                if (attacker.inventory.consumeMatching(stack => stack.item === item || stack.item.id === item.id, 1)) return true;
            }
            return false;
        }

        function evaluateRangedAttack(attacker, target, weapon, context = {}) {
            if (!isRangedWeapon(weapon)) {
                return { ok: false, reason: 'not_ranged' };
            }
            if (!attacker || !target) {
                return { ok: false, reason: 'invalid_actor' };
            }
            const profile = weapon.weaponProfile;
            const distance = chebyshevDistance(attacker.pos, target.pos);
            const result = {
                ok: false,
                weapon,
                profile,
                distance,
                reason: null,
            };
            if (distance < profile.range.min) {
                result.reason = 'too_close';
                return result;
            }
            if (distance > profile.range.max) {
                result.reason = 'out_of_range';
                return result;
            }
            const requireLoS = context.requireLineOfSight !== false;
            const mazeRef = context.maze || context.grid || null;
            if (requireLoS && mazeRef && !hasLineOfSight(mazeRef, attacker.pos, target.pos)) {
                result.reason = 'no_los';
                return result;
            }
            if (profile.ammo) {
                const ammoStack = findAmmoStackForProfile(attacker, profile);
                if (!ammoStack) {
                    result.reason = 'no_ammo';
                    return result;
                }
                result.ammoStack = ammoStack;
            }
            result.damage = damageExpectation(profile.damage);
            result.timeCost = profile.aimTime + profile.reloadTime + Math.max(1, profile.volley);
            result.ok = true;
            return result;
        }

        function performRangedAttack(attacker, target, weapon, context = {}) {
            const evaluation = evaluateRangedAttack(attacker, target, weapon, context);
            if (!evaluation.ok) return evaluation;
            const profile = weapon.weaponProfile;
            if (profile.ammo) {
                const ammoInfo = evaluation.ammoStack || findAmmoStackForProfile(attacker, profile);
                if (!ammoInfo) {
                    return { ok: false, reason: 'no_ammo' };
                }
                if (!attacker.inventory) {
                    return { ok: false, reason: 'no_inventory' };
                }
                const consumed = attacker.inventory.consumeAt?.(ammoInfo.index, profile.ammo.perShot ?? 1);
                if (!consumed) {
                    return { ok: false, reason: 'no_ammo' };
                }
                evaluation.ammoUsed = profile.ammo.perShot ?? 1;
            }
            const roll = rollDamage(profile.damage);
            evaluation.roll = roll;
            evaluation.damageApplied = roll.total;
            if (typeof target.hp === 'number') {
                target.hp -= roll.total;
                evaluation.targetHp = target.hp;
                evaluation.targetDefeated = target.hp <= 0;
            }
            if (profile.category === WEAPON_CATEGORY.THROWN && profile.consumeWeaponOnUse) {
                const consumed = consumeThrownItemFromAttacker(attacker, weapon, context);
                evaluation.weaponConsumed = consumed;
            }
            return evaluation;
        }

        function describeRangedWeapon(item) {
            if (!isRangedWeapon(item)) {
                return item ? item.name : '';
            }
            const profile = item.weaponProfile;
            const parts = [item.name, `(${profile.category})`];
            const rangePart = `Range ${profile.range.min}-${profile.range.max}` +
                (profile.range.optimal !== profile.range.min && profile.range.optimal !== profile.range.max
                    ? ` (opt ${profile.range.optimal})`
                    : '');
            parts.push(rangePart);
            parts.push(`Damage ${describeDamage(profile.damage)}`);
            if (profile.ammo) {
                const ammoPart = describeAmmo(profile.ammo);
                if (ammoPart) parts.push(`Ammo ${ammoPart}×${profile.ammo.perShot ?? 1}`);
            }
            if (profile.category === WEAPON_CATEGORY.THROWN && profile.consumeWeaponOnUse) {
                const recover = profile.recoveryChance > 0
                    ? ` (recover ${Math.round(profile.recoveryChance * 100)}%)`
                    : '';
                parts.push(`Consumes weapon${recover}`);
            }
            if (profile.reloadTime) {
                parts.push(`Reload ${profile.reloadTime}t`);
            }
            if (profile.volley > 1) {
                parts.push(`Volley ${profile.volley}`);
            }
            if (profile.notes) {
                parts.push(profile.notes);
            }
            return parts.join(' • ');
        }

        const RangedCombat = {
            isRangedWeapon,
            chebyshevDistance,
            hasLineOfSight,
            damageExpectation,
            rollDamage,
            describeDamage,
            describeAmmo,
            findAmmoStackForProfile,
            evaluateRangedAttack,
            performRangedAttack,
            describeRangedWeapon,
        };

        function getThrowProfileForItem(item) {
            if (!(item instanceof Item)) return null;
            return item.getThrowProfile?.() || null;
        }

        function describeThrowProfile(profile) {
            if (!profile) return '';
            const parts = [];
            if (profile.range) {
                parts.push(`Range ${profile.range.min}/${profile.range.optimal}/${profile.range.max}`);
            }
            if (profile.damage) {
                parts.push(`Damage ${describeDamage(profile.damage)}`);
            }
            if (profile.consumesItem) {
                const recover = (profile.recoveryChance > 0)
                    ? ` (recover ${Math.round(profile.recoveryChance * 100)}%)`
                    : '';
                parts.push(`Consumes item${recover}`);
            }
            if (!profile.consumesItem) {
                parts.push('Reusable');
            }
            if (profile.notes) {
                parts.push(profile.notes);
            }
            return parts.join(' • ');
        }

        function describeThrowable(item) {
            const profile = getThrowProfileForItem(item);
            if (!profile) return '';
            return describeThrowProfile(profile);
        }

        function evaluateThrow(attacker, target, item, context = {}) {
            if (!(item instanceof Item)) {
                return { ok: false, reason: 'invalid_item' };
            }
            if (!attacker || !target) {
                return { ok: false, reason: 'invalid_actor' };
            }
            const profile = getThrowProfileForItem(item);
            if (!profile) {
                return { ok: false, reason: 'not_throwable' };
            }
            const distance = chebyshevDistance(attacker.pos, target.pos);
            const result = {
                ok: false,
                item,
                profile,
                distance,
                reason: null,
            };
            if (distance < profile.range.min) {
                result.reason = 'too_close';
                return result;
            }
            if (distance > profile.range.max) {
                result.reason = 'out_of_range';
                return result;
            }
            const requireLoS = context.requireLineOfSight !== false;
            const mazeRef = context.maze || context.grid || null;
            if (requireLoS && mazeRef && !hasLineOfSight(mazeRef, attacker.pos, target.pos)) {
                result.reason = 'no_los';
                return result;
            }
            result.damage = damageExpectation(profile.damage);
            result.timeCost = Math.max(1, Math.floor(context.timeCost ?? 1));
            result.ok = true;
            return result;
        }

        function performThrow(attacker, target, item, context = {}) {
            const evaluation = evaluateThrow(attacker, target, item, context);
            if (!evaluation.ok) return evaluation;
            const profile = evaluation.profile;
            const roll = rollDamage(profile.damage);
            evaluation.roll = roll;
            evaluation.damageApplied = roll.total;
            if (typeof target.hp === 'number') {
                target.hp -= roll.total;
                evaluation.targetHp = target.hp;
                evaluation.targetDefeated = target.hp <= 0;
            }
            if (profile.consumesItem) {
                evaluation.itemConsumed = consumeThrownItemFromAttacker(attacker, item, context);
            }
            return evaluation;
        }

        const Throwing = {
            getThrowProfile: getThrowProfileForItem,
            describeThrowProfile,
            describeThrowable,
            evaluateThrow,
            performThrow,
        };

        // --- ITEM TEMPLATES ---
        // Weapons
        registerItem({
            id:"dagger", name:"Dagger", kind:"weapon",
            equipSlots:[SLOT.LeftHand, SLOT.RightHand, SLOT.Belt1, SLOT.Belt2, SLOT.Belt3, SLOT.Belt4],
            handsRequired:1,
            dims:{l:30,w:4,h:2}, mass:0.4
        });
        registerItem({
            id:"short_sword", name:"Short Sword", kind:"weapon",
            equipSlots:[SLOT.LeftHand, SLOT.RightHand, SLOT.Belt1, SLOT.Belt2, SLOT.Belt3, SLOT.Belt4],
            handsRequired:1,
            dims:{l:75,w:5,h:3}, mass:1.2
        });
        registerItem({
            id:"long_sword", name:"Longsword", kind:"weapon",
            equipSlots:[SLOT.LeftHand, SLOT.RightHand, SLOT.Belt1, SLOT.Belt2],
            handsRequired:1,
            dims:{l:110,w:5,h:3}, mass:1.6
        });
        registerItem({
            id:"halberd", name:"Halberd", kind:"weapon",
            equipSlots:[SLOT.LeftHand, SLOT.RightHand], // cannot belt-carry or backpack
            handsRequired:2,
            dims:{l:210,w:20,h:4}, mass:3.5
        });
        registerItem({
            id:"bow_short", name:"Shortbow", kind:"weapon",
            equipSlots:[SLOT.LeftHand, SLOT.RightHand, SLOT.Belt1, SLOT.Belt2],
            handsRequired:2,
            dims:{l:150,w:6,h:4}, mass:1.1,
            weaponProfile:{
                category:WEAPON_CATEGORY.BOW,
                range:{min:2, optimal:7, max:12},
                reloadTime:1,
                ammo:{ typePrefix:"arrow_", label:"arrows" },
                damage:{ diceCount:1, diceSides:6, bonus:0 }
            }
        });
        registerItem({
            id:"bow_long", name:"Longbow", kind:"weapon",
            equipSlots:[SLOT.LeftHand, SLOT.RightHand],
            handsRequired:2,
            dims:{l:180,w:7,h:4}, mass:1.4,
            weaponProfile:{
                category:WEAPON_CATEGORY.BOW,
                range:{min:3, optimal:9, max:15},
                reloadTime:1,
                ammo:{ typePrefix:"arrow_", label:"arrows" },
                damage:{ diceCount:1, diceSides:8, bonus:0 }
            }
        });
        registerItem({
            id:"crossbow_light", name:"Light Crossbow", kind:"weapon",
            equipSlots:[SLOT.LeftHand, SLOT.RightHand, SLOT.Belt1],
            handsRequired:2,
            dims:{l:110,w:18,h:12}, mass:2.7,
            weaponProfile:{
                category:WEAPON_CATEGORY.CROSSBOW,
                range:{min:1, optimal:8, max:14},
                reloadTime:3,
                ammo:{ typePrefix:"bolt_", label:"bolts" },
                damage:{ diceCount:1, diceSides:8, bonus:1 },
                notes:"Mechanical reload between shots"
            }
        });
        registerItem({
            id:"sling_leather", name:"Leather Sling", kind:"weapon",
            equipSlots:[SLOT.LeftHand, SLOT.RightHand, SLOT.Belt1, SLOT.Belt2, SLOT.Belt3, SLOT.Belt4],
            handsRequired:1,
            dims:{l:90,w:4,h:2}, mass:0.2,
            weaponProfile:{
                category:WEAPON_CATEGORY.SLING,
                range:{min:2, optimal:6, max:10},
                reloadTime:1,
                ammo:{ typePrefix:"sling_stone", label:"stones" },
                damage:{ diceCount:1, diceSides:4, bonus:1 }
            }
        });
        registerItem({
            id:"throwing_knife", name:"Throwing Knife", kind:"weapon",
            equipSlots:[SLOT.LeftHand, SLOT.RightHand, SLOT.Belt1, SLOT.Belt2, SLOT.Belt3, SLOT.Belt4],
            handsRequired:1,
            dims:{l:28,w:3,h:2}, mass:0.25, stackable:true, maxStack:6,
            throwProfile:{
                range:{min:1, optimal:3, max:6},
                damage:{ diceCount:1, diceSides:4, bonus:1 },
                consumesItem:true,
                recoveryChance:0.4,
            },
            weaponProfile:{
                category:WEAPON_CATEGORY.THROWN,
                range:{min:1, optimal:3, max:6},
                reloadTime:0,
                damage:{ diceCount:1, diceSides:4, bonus:1 },
                consumeWeaponOnUse:true,
                recoveryChance:0.4,
                notes:"Designed to be thrown; may be recovered after a fight"
            }
        });
        registerItem({
            id:"javelin", name:"Javelin", kind:"weapon",
            equipSlots:[SLOT.LeftHand, SLOT.RightHand, SLOT.Belt1, SLOT.Belt2],
            handsRequired:1,
            dims:{l:150,w:5,h:5}, mass:1.0,
            throwProfile:{
                range:{min:1, optimal:5, max:8},
                damage:{ diceCount:1, diceSides:6, bonus:2 },
                consumesItem:true,
                recoveryChance:0.35,
            },
            weaponProfile:{
                category:WEAPON_CATEGORY.THROWN,
                range:{min:1, optimal:5, max:8},
                reloadTime:0,
                damage:{ diceCount:1, diceSides:6, bonus:2 },
                consumeWeaponOnUse:true,
                recoveryChance:0.35,
                notes:"A heavy spear meant for throwing; the javelin itself is expended on impact"
            }
        });

        // Armor and wearables
        registerItem({ id:"leather_cap", name:"Leather Cap", kind:"armor",
            equipSlots:[SLOT.Head], dims:{l:25,w:20,h:15}, mass:0.6
        });
        registerItem({ id:"basic_clothes", name:"Basic Clothes", kind:"armor",
            equipSlots:[SLOT.BodyArmor], dims:{l:40,w:30,h:10}, mass:1.0
        });
        registerItem({ id:"cloak", name:"Cloak", kind:"armor",
            equipSlots:[SLOT.Cloak], dims:{l:50,w:35,h:10}, mass:1.2
        });
        registerItem({ id:"boots", name:"Boots", kind:"armor",
            equipSlots:[SLOT.Boots], dims:{l:35,w:25,h:15}, mass:1.5
        });
        registerItem({ id:"gloves", name:"Gloves", kind:"armor",
            equipSlots:[SLOT.Gloves], dims:{l:20,w:12,h:6}, mass:0.3
        });

        // Jewelry
        registerItem({ id:"ring_plain", name:"Plain Ring", kind:"jewelry",
            equipSlots:[SLOT.LeftRing, SLOT.RightRing], dims:{l:3,w:3,h:1}, mass:0.02, stackable:false
        });
        registerItem({ id:"amulet_simple", name:"Amulet", kind:"jewelry",
            equipSlots:[SLOT.Amulet], dims:{l:5,w:4,h:1}, mass:0.05
        });

        // Light sources
        registerItem({ id:"torch", name:"Torch", kind:"tool",
            equipSlots:[SLOT.LeftHand, SLOT.RightHand, SLOT.Belt1, SLOT.Belt2, SLOT.Belt3, SLOT.Belt4],
            dims:{l:30,w:4,h:4}, mass:0.5, stackable:true, maxStack:20, lightRadius:2,
            lightColor:'#ffb347', flickerRate:3.5
        });
        registerItem({ id:"lantern", name:"Lantern", kind:"tool",
            equipSlots:[SLOT.LeftHand, SLOT.RightHand, SLOT.Belt1, SLOT.Belt2, SLOT.Belt3, SLOT.Belt4],
            dims:{l:18,w:12,h:12}, mass:0.9, lightRadius:5,
            lightColor:'#fff4c1', flickerRate:1.2
        });

        // Belt garment and attachments
        registerItem({ id:"belt_leather", name:"Leather Belt", kind:"armor",
            equipSlots:[SLOT.Belt], dims:{l:20,w:10,h:5}, mass:0.3
        });

        // Pouch that sits on a belt slot; we treat it as “equipped” to Belt1–4 and it is a tiny container
        registerItem({
            id:"pouch_small", name:"Small Pouch", kind:"container",
            equipSlots:[SLOT.Belt1, SLOT.Belt2, SLOT.Belt3, SLOT.Belt4],
            dims:{l:10,w:8,h:4}, mass:0.1,
            container:{ volumeL: 0.6, maxMassKg: 1.0, maxItemLengthCm: 12,
                        accepts: (it)=> it.kind==="ammo" || it.mass<=0.2 }
        });

        // Backpacks (choose one equipped at SLOT.Backpack). Capacity and length gates enforced.
        registerItem({
            id:"pack_sack", name:"Cloth Sack", kind:"container",
            equipSlots:[SLOT.Backpack],
            dims:{l:40,w:30,h:10}, mass:0.6,
            container:{ volumeL: 20, maxMassKg: 12, maxItemLengthCm: 60,
                        accepts: (it)=> it.longestCm() <= 60 }
        });
        registerItem({
            id:"pack_rucksack", name:"Rucksack", kind:"container",
            equipSlots:[SLOT.Backpack],
            dims:{l:60,w:35,h:20}, mass:1.8,
            container:{ volumeL: 45, maxMassKg: 25, maxItemLengthCm: 80,
                        accepts: (it)=> it.longestCm() <= 80 }
        });
        registerItem({
            id:"pack_frame", name:"Frame Pack", kind:"container",
            equipSlots:[SLOT.Backpack],
            dims:{l:80,w:40,h:25}, mass:2.6,
            container:{ volumeL: 65, maxMassKg: 30, maxItemLengthCm: 120,
                        accepts: (it)=> it.longestCm() <= 120 }
        });

        // Quiver and ammo
        registerItem({
            id:"quiver_std", name:"Quiver", kind:"container",
            equipSlots:[SLOT.Quiver],
            dims:{l:70,w:15,h:8}, mass:0.5,
            container:{ volumeL: 6, maxMassKg: 5, maxItemLengthCm: 80,
                        accepts: (it)=> it.kind==="ammo" && it.id.startsWith("arrow_") }
        });
        registerItem({
            id:"arrow_wood", name:"Wooden Arrow", kind:"ammo",
            equipSlots:[], stackable:true, maxStack:99,
            dims:{l:75,w:1,h:1}, mass:0.03
        });
        registerItem({
            id:"bolt_wood", name:"Wooden Bolt", kind:"ammo",
            equipSlots:[], stackable:true, maxStack:99,
            dims:{l:35,w:1.2,h:1.2}, mass:0.04
        });
        registerItem({
            id:"sling_stone", name:"Smooth Stone", kind:"ammo",
            equipSlots:[], stackable:true, maxStack:120,
            dims:{l:4,w:4,h:4}, mass:0.05
        });


        // --- UTILITY FUNCTIONS ---
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        function posKey(pos) {
            return `${pos.x},${pos.y}`;
        }
        function posKeyFromCoords(x, y) {
            return `${x},${y}`;
        }
        
        const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
        const randChoice = (arr) => arr[Math.floor(Math.random() * arr.length)];

        function colorStringToRgb(color) {
            if (typeof color !== 'string') {
                return colorStringToRgb(LIGHT_CONFIG.fallbackColor);
            }
            const trimmed = color.trim();
            if (trimmed.startsWith('#')) {
                let hex = trimmed.slice(1);
                if (hex.length === 3) {
                    hex = hex.split('').map(ch => ch + ch).join('');
                }
                if (hex.length === 6) {
                    const value = parseInt(hex, 16);
                    if (!Number.isNaN(value)) {
                        return {
                            r: (value >> 16) & 0xff,
                            g: (value >> 8) & 0xff,
                            b: value & 0xff,
                        };
                    }
                }
            }
            const match = trimmed.match(/rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)/i);
            if (match) {
                return {
                    r: Math.max(0, Math.min(255, parseInt(match[1], 10) || 0)),
                    g: Math.max(0, Math.min(255, parseInt(match[2], 10) || 0)),
                    b: Math.max(0, Math.min(255, parseInt(match[3], 10) || 0)),
                };
            }
            if (trimmed !== LIGHT_CONFIG.fallbackColor) {
                return colorStringToRgb(LIGHT_CONFIG.fallbackColor);
            }
            return { r: 255, g: 255, b: 255 };
        }

        function getLightProperties() {
            const defaults = {
                radius: DEFAULT_LIGHT_RADIUS,
                color: LIGHT_CONFIG.fallbackColor,
                flickerRate: LIGHT_CONFIG.fallbackFlickerRate
            };
            if (!player || !player.equipment || typeof player.equipment.getLightSourceProperties !== 'function') {
                return defaults;
            }
            return player.equipment.getLightSourceProperties(defaults);
        }

        // Cache the best available timing function to avoid repeated feature detection
        const getNow = (typeof performance !== 'undefined' && performance && typeof performance.now === 'function')
            ? () => performance.now()
            : () => Date.now();

        function computeLightOverlayAlpha(flickerRate) {
            let alpha = LIGHT_CONFIG.baseOverlayAlpha;
            const variance = LIGHT_CONFIG.flickerVariance;
            if (typeof flickerRate === 'number' && flickerRate > 0 && variance > 0) {
                const now = getNow();
                const t = now / 1000;
                const primary = Math.sin(t * flickerRate * 2 * Math.PI);
                const secondary = Math.sin(t * flickerRate * 2 * Math.PI * 0.63 + Math.PI / 3);
                alpha += primary * variance * 0.5;
                alpha += secondary * variance * 0.25;
            }
            if (alpha < 0) alpha = 0;
            else if (alpha > 1) alpha = 1;
            return alpha;
        }

        function computeLightOverlayStyle() {
            const props = getLightProperties();
            const rgb = colorStringToRgb(props.color || LIGHT_CONFIG.fallbackColor);
            const alpha = computeLightOverlayAlpha(props.flickerRate);
            return ['rgba(', rgb.r, ',', rgb.g, ',', rgb.b, ',', alpha.toFixed(3), ')'].join('');
        }

        function refreshLightingVisuals() {
            fovState.overlayStyle = computeLightOverlayStyle();
        }

        function getLightRadius() {
            return getLightProperties().radius;
        }

        function tileBlocksLight(x, y, useKnownGrid = false) {
            if (x < 0 || x >= mapState.width || y < 0 || y >= mapState.height) return true;
            const grid = useKnownGrid ? mapState.known : mapState.grid;
            const row = grid[y];
            if (!row) return true;
            const val = row[x];
            if (useKnownGrid && val === -1) return false;
            return val === TILE_WALL;
        }
        function computeFieldOfView(pos, radius, useKnownGrid = false) {
            const visible = new Set();
            const radiusSq = radius * radius;
            visible.add(posKey(pos));
            const setVisible = (x, y) => {
                if (x < 0 || x >= mapState.width || y < 0 || y >= mapState.height) return;
                visible.add(posKey({ x, y }));
            };
            function castLight(row, startSlope, endSlope, xx, xy, yx, yy) {
                if (startSlope < endSlope) return;
                for (let i = row; i <= radius; i++) {
                    let dx = -i - 1;
                    let dy = -i;
                    let blocked = false;
                    let newStart = startSlope;
                    while (dx <= 0) {
                        dx += 1;
                        const mx = pos.x + dx * xx + dy * xy;
                        const my = pos.y + dx * yx + dy * yy;
                        const lSlope = (dx - 0.5) / (dy + 0.5);
                        const rSlope = (dx + 0.5) / (dy - 0.5);
                        if (startSlope < rSlope) {
                            continue;
                        }
                        if (endSlope > lSlope) {
                            break;
                        }
                        const distSq = dx * dx + dy * dy;
                        if (distSq <= radiusSq) {
                            setVisible(mx, my);
                        }
                        const blockedTile = tileBlocksLight(mx, my, useKnownGrid);
                        if (blocked) {
                            if (blockedTile) {
                                newStart = rSlope;
                                continue;
                            }
                            blocked = false;
                            startSlope = newStart;
                        } else if (blockedTile && i < radius) {
                            blocked = true;
                            castLight(i + 1, startSlope, lSlope, xx, xy, yx, yy);
                            newStart = rSlope;
                        }
                    }
                    if (blocked) {
                        break;
                    }
                }
            }
            for (let oct = 0; oct < 8; oct++) {
                const [xx, xy, yx, yy] = FOV_TRANSFORMS[oct];
                castLight(1, 1.0, 0.0, xx, xy, yx, yy);
            }
            return visible;
        }
        function computeVisibleCells(pos) {
            const key = posKey(pos);
            const radius = getLightRadius();
            if (fovState.lastCache.visible && fovState.lastCache.key === key && fovState.lastCache.radius === radius) {
                return fovState.lastCache.visible;
            }
            const visible = computeFieldOfView(pos, radius, false);
            fovState.lastCache = { key, radius, visible };
            return visible;
        }
        // --- A* PATHFINDING FOR MAP VALIDATION ---
        function inBounds(grid, x, y) {
            return y >= 0 && y < grid.length && x >= 0 && x < grid[0].length;
        }
        function aStarPath(grid, start, end) {
            // Straightforward A* over the 4-connected grid. The map generator only uses this to
            // verify connectivity, so we prioritise readability over micro-optimisations – the
            // grids are small enough that the classic textbook implementation is plenty fast.
            const heuristic = (a, b) => Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
            const openSet = [];
            const closedSet = new Set();
            const cameFrom = new Map();
            const gScore = new Map();
            const fScore = new Map();
            const startKey = posKey(start);
            gScore.set(startKey, 0);
            fScore.set(startKey, heuristic(start, end));
            openSet.push(start);
            while (openSet.length > 0) {
                let lowestIndex = 0;
                for (let i = 1; i < openSet.length; i++) {
                    const fA = fScore.get(posKey(openSet[i])) || Infinity;
                    const fB = fScore.get(posKey(openSet[lowestIndex])) || Infinity;
                    if (fA < fB) {
                        lowestIndex = i;
                    }
                }
                const current = openSet.splice(lowestIndex, 1)[0];
                const currentKey = posKey(current);
                if (current.x === end.x && current.y === end.y) {
                    const path = [];
                    let temp = current;
                    while (temp) {
                        path.unshift(temp);
                        temp = cameFrom.get(posKey(temp));
                    }
                    return path;
                }
                closedSet.add(currentKey);
                const neighbors = [
                    {x: current.x, y: current.y - 1}, {x: current.x, y: current.y + 1},
                    {x: current.x - 1, y: current.y}, {x: current.x + 1, y: current.y}
                ];
                for (const neighbor of neighbors) {
                    if (!inBounds(grid, neighbor.x, neighbor.y) || grid[neighbor.y][neighbor.x] === TILE_WALL) {
                        continue;
                    }
                    const neighborKey = posKey(neighbor);
                    if (closedSet.has(neighborKey)) {
                        continue;
                    }
                    const tentativeGScore = (gScore.get(currentKey) || 0) + 1;
                    if (!openSet.some(node => posKey(node) === neighborKey) || tentativeGScore < (gScore.get(neighborKey) || Infinity)) {
                        cameFrom.set(neighborKey, current);
                        gScore.set(neighborKey, tentativeGScore);
                        fScore.set(neighborKey, tentativeGScore + heuristic(neighbor, end));
                        if (!openSet.some(node => posKey(node) === neighborKey)) {
                            openSet.push(neighbor);
                        }
                    }
                }
            }
            return null; // No path found
        }
        
        // --- DUNGEON SHAPE GENERATION HELPERS ---
        function manhattanEdgeDistanceRect(A, B) {
            const dx = Math.max(0, B.x0 - A.x1, A.x0 - B.x1);
            const dy = Math.max(0, B.y0 - A.y1, A.y0 - B.y1);
            return dx + dy;
        }
        function pointInPoly(x, y, poly) {
            let inside = false;
            for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
                const xi = poly[i].x, yi = poly[i].y;
                const xj = poly[j].x, yj = poly[j].y;
                const intersect =
                    ((yi > y) !== (yj > y)) &&
                    (x < ((xj - xi) * (y - yi)) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }
        function rasterizeRegularPolygon(n, targetArea, minSide) {
            const twoPi = Math.PI * 2;
            const sin = Math.sin;
            const areaToR = (A) => Math.sqrt((2 * A) / (n * sin(twoPi / n)));
            const Rmin = minSide / (2 * sin(Math.PI / n));
            let R = Math.max(areaToR(targetArea), Rmin);
            const tryBuild = (Rtry) => {
                const w = Math.ceil(2 * Rtry) + 2; const h = w;
                const cx = w / 2, cy = h / 2;
                const verts = [];
                for (let i = 0; i < n; i++) {
                    const ang = (twoPi * i) / n - Math.PI / n;
                    verts.push({ x: cx + Rtry * Math.cos(ang), y: cy + Rtry * Math.sin(ang) });
                }
                const tiles = [];
                for (let ty = 0; ty < h; ty++) {
                    for (let tx = 0; tx < w; tx++) {
                        const cxCell = tx + 0.5, cyCell = ty + 0.5;
                        if (pointInPoly(cxCell, cyCell, verts)) {
                            tiles.push({ x: tx, y: ty });
                        }
                    }
                }
                return { tiles, width: w, height: h };
            };
            let out = tryBuild(R);
            const measured = out.tiles.length;
            if (measured < 0.9 * targetArea || measured > 1.1 * targetArea) {
                const scale = Math.sqrt(targetArea / Math.max(1, measured));
                R = Math.max(R * scale, Rmin);
                out = tryBuild(R);
            }
            return out;
        }
        function rasterizeDisc(targetArea, minSide) {
            let R = Math.sqrt(targetArea / Math.PI);
            R = Math.max(R, minSide);
            const w = Math.ceil(2 * R) + 2; const h = w;
            const cx = w / 2, cy = h / 2;
            const R2 = R * R;
            const tiles = [];
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const dx = (x + 0.5) - cx;
                    const dy = (y + 0.5) - cy;
                    if (dx * dx + dy * dy <= R2) tiles.push({ x, y });
                }
            }
            const measured = tiles.length;
            if (measured < 0.9 * targetArea || measured > 1.1 * targetArea) {
                const scale = Math.sqrt(targetArea / Math.max(1, measured));
                const R2b = Math.max(R * scale, minSide);
                return rasterizeDisc(Math.PI * R2b * R2b, minSide);
            }
            return { tiles, width: w, height: h };
        }
        function rasterizeRectLike(targetArea, minSide, kind) {
            let w, h;
            if (kind === 'square') {
                const s = Math.max(minSide, Math.round(Math.sqrt(targetArea)));
                w = s; h = s;
            } else {
                const ratio = 1 + Math.random() * 1.5; // 1.0..2.5
                w = Math.max(minSide, Math.round(Math.sqrt(targetArea * ratio)));
                h = Math.max(minSide, Math.round(targetArea / w));
                if (w * h < targetArea) {
                    if (w < h) w = Math.max(w + 1, minSide);
                    else h = Math.max(h + 1, minSide);
                }
            }
            const tiles = [];
            for (let y = 0; y < h; y++) { for (let x = 0; x < w; x++) tiles.push({ x, y }); }
            return { tiles, width: w, height: h };
        }
        function rasterizeCross(targetArea, minSide) {
            const armWidth = Math.max(3, Math.round(clamp(minSide / 2, 3, 10)));
            // Area = 2 * L * armWidth - armWidth^2
            const L = Math.round((targetArea + armWidth * armWidth) / (2 * armWidth));
            const size = Math.max(L, minSide, armWidth * 3);
            const halfSize = Math.floor(size / 2);
            const halfArm = Math.floor(armWidth / 2);

            const tiles = [];
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const isHorizontal = Math.abs(y - halfSize) <= halfArm;
                    const isVertical = Math.abs(x - halfSize) <= halfArm;
                    if (isHorizontal || isVertical) {
                        tiles.push({ x, y });
                    }
                }
            }
            return { width: size, height: size, tiles };
        }
        function rasterizeX(targetArea, minSide) {
            let size = Math.max(minSide, Math.round(Math.sqrt(targetArea * 0.9))); // Initial guess

            const countFor = (S) => {
                const armWidth = Math.max(3, Math.round(clamp(S / 5, 3, 9)));
                const tiles = new Set();
                const halfArm = Math.floor(armWidth / 2);
                for (let i = 0; i < S; i++) {
                    for (let w = -halfArm; w <= halfArm; w++) {
                        // Main diagonal segment
                        if (i + w >= 0 && i + w < S) tiles.add(`${i},${i+w}`);
                        // Anti-diagonal segment
                        if ((S - 1 - i) + w >= 0 && (S - 1 - i) + w < S) tiles.add(`${i},${(S - 1 - i) + w}`);
                    }
                }
                return tiles.size;
            };
            
            let areaNow = countFor(size);
            let guard = 0;
            const within = (val, tgt) => Math.abs(val - tgt) <= Math.max(15, Math.floor(tgt * 0.15));
            while (!within(areaNow, targetArea) && guard++ < 50) {
                const ratio = Math.sqrt(targetArea / areaNow);
                let nextSize = Math.round(size * ratio);
                if (nextSize === size) nextSize = areaNow < targetArea ? size + 1 : size -1;
                size = Math.max(minSide, nextSize);
                areaNow = countFor(size);
            }

            const finalTiles = [];
            const armWidth = Math.max(3, Math.round(clamp(size / 5, 3, 9)));
            const tileSet = new Set();
            const halfArm = Math.floor(armWidth / 2);
             for (let i = 0; i < size; i++) {
                for (let w = -halfArm; w <= halfArm; w++) {
                    if (i + w >= 0 && i + w < size) tileSet.add(`${i},${i+w}`);
                    if ((size - 1 - i) + w >= 0 && (size - 1 - i) + w < size) tileSet.add(`${i},${(size - 1 - i) + w}`);
                }
            }
            tileSet.forEach(key => {
                const [x, y] = key.split(',').map(Number);
                finalTiles.push({x, y});
            });

            return { width: size, height: size, tiles: finalTiles };
        }
        function rasterizeRingHub(targetArea, minSide) {
            const orient = randChoice(['h', 'v']);
            const cw = Math.max(1, Math.floor(Math.max(2, minSide / 6)));

            let R = Math.max(minSide, Math.ceil(Math.sqrt(targetArea / Math.PI)));

            const chooseParams = (R) => {
                const w = clamp(Math.floor(R / 4), 2, Math.max(2, Math.floor(minSide / 2)));
                const rcMax = Math.max(2, R - w - 3);
                const rc = clamp(Math.floor(R / 3), 2, rcMax);
                return { w, rc };
            };

            const countFor = (R) => {
                const { w, rc } = chooseParams(R);
                const S = 2 * R + 1;
                const half = R;
                let c = 0;

                const tInner2 = (R - w) * (R - w);
                const tOuter2 = R * R;
                const hub2 = rc * rc;
                const halfCW = Math.floor((cw - 1) / 2);

                if (orient === 'h') {
                    for (let y = -half; y <= half; y++) {
                        for (let x = -half; x <= half; x++) {
                            const r2 = x * x + y * y;
                            const inRing = (r2 <= tOuter2) && (r2 >= tInner2);
                            const inHub = (r2 <= hub2);
                            const inCorr = (Math.abs(y) <= halfCW && x >= rc && x <= (R - w));
                            if (inRing || inHub || inCorr) c++;
                        }
                    }
                } else {
                    for (let y = -half; y <= half; y++) {
                        for (let x = -half; x <= half; x++) {
                            const r2 = x * x + y * y;
                            const inRing = (r2 <= tOuter2) && (r2 >= tInner2);
                            const inHub = (r2 <= hub2);
                            const inCorr = (Math.abs(x) <= halfCW && y >= rc && y <= (R - w));
                            if (inRing || inHub || inCorr) c++;
                        }
                    }
                }
                return c;
            };

            const within = (val, tgt) => Math.abs(val - tgt) <= Math.max(12, Math.floor(tgt * 0.10));
            let areaNow = countFor(R);
            let guard = 0;
            while (!within(areaNow, targetArea) && guard++ < 200) {
                if (areaNow < targetArea) R += 1;
                else if (R > minSide + 2) R -= 1;
                else break;
                areaNow = countFor(R);
            }

            const { w, rc } = chooseParams(R);
            const S = 2 * R + 1;
            const half = R;
            const tiles = [];

            const tInner2 = (R - w) * (R - w);
            const tOuter2 = R * R;
            const hub2 = rc * rc;
            const halfCW = Math.floor((cw - 1) / 2);

            if (orient === 'h') {
                for (let y = -half; y <= half; y++) {
                    for (let x = -half; x <= half; x++) {
                        const r2 = x * x + y * y;
                        const inRing = (r2 <= tOuter2) && (r2 >= tInner2);
                        const inHub = (r2 <= hub2);
                        const inCorr = (Math.abs(y) <= halfCW && x >= rc && x <= (R - w));
                        if (inRing || inHub || inCorr) tiles.push({ x: x + half, y: y + half });
                    }
                }
            } else {
                for (let y = -half; y <= half; y++) {
                    for (let x = -half; x <= half; x++) {
                        const r2 = x * x + y * y;
                        const inRing = (r2 <= tOuter2) && (r2 >= tInner2);
                        const inHub = (r2 <= hub2);
                        const inCorr = (Math.abs(x) <= halfCW && y >= rc && y <= (R - w));
                        if (inRing || inHub || inCorr) tiles.push({ x: x + half, y: y + half });
                    }
                }
            }

            return { width: S, height: S, tiles };
        }
        function makeShape(targetArea, minSide) {
            const shape = randChoice(['square', 'rectangle', 'round', 'hex', 'oct', 'cross', 'x', 'ringhub']);
            if (shape === 'square')    return { kind: 'square',    ...rasterizeRectLike(targetArea, minSide, 'square') };
            if (shape === 'rectangle') return { kind: 'rectangle', ...rasterizeRectLike(targetArea, minSide, 'rectangle') };
            if (shape === 'round')     return { kind: 'round',     ...rasterizeDisc(targetArea, minSide) };
            if (shape === 'hex')       return { kind: 'hex',       ...rasterizeRegularPolygon(6, targetArea, minSide) };
            if (shape === 'oct')       return { kind: 'oct',       ...rasterizeRegularPolygon(8, targetArea, minSide) };
            if (shape === 'cross')     return { kind: 'cross',     ...rasterizeCross(targetArea, minSide) };
            if (shape === 'x')         return { kind: 'x',         ...rasterizeX(targetArea, minSide) };
            return { kind: 'ringhub', ...rasterizeRingHub(targetArea, minSide) };
        }
        function canPlace(bbox, placed, minSpacing) {
            for (const r of placed) {
                const overlap = !(bbox.x1 < r.x0 || bbox.x0 > r.x1 || bbox.y1 < r.y0 || bbox.y0 > r.y1);
                if (overlap) return false;
                const l1 = manhattanEdgeDistanceRect(bbox, r);
                if (l1 < minSpacing) return false;
            }
            return true;
        }

        // -------------------------------------------------------------
        // Large-Rooms-Only Dungeon Generator (dynamic map, wall buffer)
        // Floors = 0, Walls = 1
        // -------------------------------------------------------------
        function generateLargeRoomsMap(options = {}) {
            /*
             * High level algorithm:
             *   1. Randomly pick a target area and silhouette for each desired room (square,
             *      round, polygonal, etc.) using the rasterize helpers above.
             *   2. Scatter the rooms in an expanding search radius until they no longer overlap,
             *      keeping a large Manhattan buffer so big chambers do not bleed into each other.
             *   3. After all rooms are placed, normalise the co-ordinates so the outer border is
             *      padded with solid walls and emit a single grid where 0 = floor, 1 = wall.
             *
             * The function returns both the finished tile grid and metadata about every room so
             * downstream systems (path validation, loot placement, etc.) do not need to reverse
             * engineer the layout again.
             */
            const cfg = {
                roomCountRange: [1, 11],
                areaRange: [300, 750],
                minSide: 8, // tiles; for round => diameter >= 2*minSide
                minL1EdgeSpacing: 30, // tiles; Manhattan edge-to-edge distance
                border: 15, // outer wall buffer thickness
                maxAttemptsPerRoom: 600,
                ...options
            };
            const randInt = (a, b) => a + Math.floor(Math.random() * (b - a + 1));
            
            const desiredRooms = randInt(cfg.roomCountRange[0], cfg.roomCountRange[1]);
            const bigRooms = [];
            for (let i = 0; i < desiredRooms; i++) {
                const area = randInt(cfg.areaRange[0], cfg.areaRange[1]);
                bigRooms.push(makeShape(area, cfg.minSide));
            }
            const placed = [];
            let searchRadius = 0;
            for (const room of bigRooms) {
                let placedOK = false;
                const baseR = (searchRadius += Math.max(room.width, room.height) + cfg.minL1EdgeSpacing);
                for (let attempt = 0; attempt < cfg.maxAttemptsPerRoom; attempt++) {
                    const R = baseR + Math.floor(attempt / 10) * 10;
                    const tx = randInt(-R, R);
                    const ty = randInt(-R, R);
                    const bbox = { x0: tx, y0: ty, x1: tx + room.width - 1, y1: ty + room.height - 1 };
                    if (!canPlace(bbox, placed, cfg.minL1EdgeSpacing)) continue;
                    placed.push({ ...room, x0: bbox.x0, y0: bbox.y0, x1: bbox.x1, y1: bbox.y1, tiles: room.tiles.map(t => ({ x: tx + t.x, y: ty + t.y })), });
                    placedOK = true;
                    break;
                }
            }
            if (placed.length === 0) {
                const fallback = rasterizeRectLike(
                    clamp((cfg.areaRange[0] + cfg.areaRange[1]) >> 1, 300, 750),
                    cfg.minSide,
                    'square'
                );
                placed.push({ kind: 'square', ...fallback, x0: 0, y0: 0, x1: fallback.width - 1, y1: fallback.height - 1, tiles: fallback.tiles.map(t => ({ x: t.x, y: t.y })), });
            }
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            for (const r of placed) {
                minX = Math.min(minX, r.x0); minY = Math.min(minY, r.y0);
                maxX = Math.max(maxX, r.x1); maxY = Math.max(maxY, r.y1);
            }
            const innerW = maxX - minX + 1; const innerH = maxY - minY + 1;
            const W = innerW + 2 * cfg.border; const H = innerH + 2 * cfg.border;
            const grid = Array.from({ length: H }, () => Array(W).fill(TILE_WALL));
            const ox = -minX + cfg.border; const oy = -minY + cfg.border;
            for (const r of placed) {
                for (const t of r.tiles) {
                    const gx = t.x + ox; const gy = t.y + oy;
                    if (gy >= 0 && gy < H && gx >= 0 && gx < W) grid[gy][gx] = TILE_FLOOR;
                }
            }
            return {
                grid, width: W, height: H,
                rooms: placed.map(r => ({
                    kind: r.kind,
                    bbox: { x0: r.x0 + ox, y0: r.y0 + oy, x1: r.x1 + ox, y1: r.y1 + oy },
                    center: { x: Math.floor((r.x0 + r.x1) / 2) + ox, y: Math.floor((r.y0 + r.y1) / 2) + oy }
                })),
                meta: {
                    border: cfg.border, minL1EdgeSpacing: cfg.minL1EdgeSpacing,
                    minSide: cfg.minSide, requestedRooms: desiredRooms, placedRooms: placed.length
                }
            };
        }
        // --- DELAUNAY TRIANGULATION IMPLEMENTATION ---
        class Vertex {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
            equals(vertex) {
                return this.x === vertex.x && this.y === vertex.y;
            }
        }

        class Edge {
            constructor(v0, v1) {
                this.v0 = v0;
                this.v1 = v1;
            }
            equals(edge) {
                return (this.v0.equals(edge.v0) && this.v1.equals(edge.v1)) ||
                       (this.v0.equals(edge.v1) && this.v1.equals(edge.v0));
            }
        }

        class Triangle {
            constructor(v0, v1, v2) {
                this.v0 = v0;
                this.v1 = v1;
                this.v2 = v2;
                this.circumCirc = calcCircumCirc(v0, v1, v2);
            }
            inCircumcircle(v) {
                const dx = this.circumCirc.c.x - v.x;
                const dy = this.circumCirc.c.y - v.y;
                return Math.sqrt(dx * dx + dy * dy) <= this.circumCirc.r;
            }
        }

        function calcCircumCirc(v0, v1, v2) {
            const ax = v0.x, ay = v0.y;
            const bx = v1.x, by = v1.y;
            const cx = v2.x, cy = v2.y;
            const d = 2 * (ax*(by - cy) + bx*(cy - ay) + cx*(ay - by));
            if (d === 0) return {c: {x:0,y:0}, r: Infinity}; // collinear
            const ux = ((ax*ax + ay*ay)*(by - cy) + (bx*bx + by*by)*(cy - ay) + (cx*cx + cy*cy)*(ay - by)) / d;
            const uy = ((ax*ax + ay*ay)*(cx - bx) + (bx*bx + by*by)*(ax - cx) + (cx*cx + cy*cy)*(bx - ax)) / d;
            const center = {x: ux, y: uy};
            const r = Math.sqrt( (ax - ux)**2 + (ay - uy)**2 );
            return {c: center, r: r};
        }
        function superTriangle(vertices) {
            var minx = Infinity, miny = Infinity, maxx = -Infinity, maxy = -Infinity;
            vertices.forEach(function(vertex) {
                minx = Math.min(minx, vertex.x);
                miny = Math.min(miny, vertex.y);
                maxx = Math.max(maxx, vertex.x);
                maxy = Math.max(maxy, vertex.y);
            });
            var dx = (maxx - minx) * 10, dy = (maxy - miny) * 10;
            var v0 = new Vertex(minx - dx, miny - dy * 3),
                v1 = new Vertex(minx - dx, maxy + dy),
                v2 = new Vertex(maxx + dx * 3, maxy + dy);
            return new Triangle(v0, v1, v2);
        }
        function addVertex(vertex, triangles) {
            var edges = [];
            triangles = triangles.filter(function(triangle) {
                if (triangle.inCircumcircle(vertex)) {
                    edges.push(new Edge(triangle.v0, triangle.v1));
                    edges.push(new Edge(triangle.v1, triangle.v2));
                    edges.push(new Edge(triangle.v2, triangle.v0));
                    return false;
                }
                return true;
            });
            edges = uniqueEdges(edges);
            edges.forEach(function(edge) {
                triangles.push(new Triangle(edge.v0, edge.v1, vertex));
            });
            return triangles;
        }
        function uniqueEdges(edges) {
            const uniqueEdgesMap = new Map();
            for (const edge of edges) {
                // Create a consistent key regardless of vertex order
                const key = edge.v0.x < edge.v1.x || (edge.v0.x === edge.v1.x && edge.v0.y < edge.v1.y)
                    ? `${posKey(edge.v0)}-${posKey(edge.v1)}`
                    : `${posKey(edge.v1)}-${posKey(edge.v0)}`;
                
                if (uniqueEdgesMap.has(key)) {
                    uniqueEdgesMap.delete(key); // Found a pair, so it's not unique
                } else {
                    uniqueEdgesMap.set(key, edge); // First time seeing this edge
                }
            }
            return Array.from(uniqueEdgesMap.values());
        }
        function triangulate(vertices) {
            var st = superTriangle(vertices);
            var triangles = [st];
            vertices.forEach(function(vertex) {
                triangles = addVertex(vertex, triangles);
            });
            triangles = triangles.filter(function(triangle) {
                return !(triangle.v0.equals(st.v0) || triangle.v0.equals(st.v1) || triangle.v0.equals(st.v2) ||
                       triangle.v1.equals(st.v0) || triangle.v1.equals(st.v1) || triangle.v1.equals(st.v2) ||
                       triangle.v2.equals(st.v0) || triangle.v2.equals(st.v1) || triangle.v2.equals(st.v2));
            });
            return triangles;
        }
        // ============================================================
        // HYBRID DUNGEON GENERATOR
        // Large-room scaffold (test2) + small-room fill (test) + corridors at the end
        // Floors = 0, Walls = 1
        // ============================================================
        // ----- CONFIG -----
        const HYBRID_CFG = CONFIG.generator.hybrid;
        // Utility
        const clamp01 = (v) => Math.max(0, Math.min(1, v));
        const manhattan = (a, b) => Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        // -------------------------
        // Phase A: Large rooms
        // -------------------------
        function generateLargeRoomsScaffold(cfg = HYBRID_CFG.large) {
          // Reuse your test2 "generateLargeRoomsMap" internals,
          // but return both the grid and normalized room descriptors.
          const out = generateLargeRoomsMap({
            roomCountRange: cfg.roomCountRange,
            areaRange: cfg.areaRange,
            minSide: cfg.minSide,
            minL1EdgeSpacing: cfg.minL1EdgeSpacing,
            border: cfg.border,
            maxAttemptsPerRoom: cfg.maxAttemptsPerRoom,
          });
          // Normalize large rooms to a common format
          const largeRooms = out.rooms.map(r => ({
            kind: r.kind,
            x0: r.bbox.x0,
            y0: r.bbox.y0,
            x1: r.bbox.x1,
            y1: r.bbox.y1,
            w: r.bbox.x1 - r.bbox.x0 + 1,
            h: r.bbox.y1 - r.bbox.y0 + 1,
            center: { x: r.center.x, y: r.center.y }
          }));
          return {
            grid: out.grid,
            width: out.width,
            height: out.height,
            border: cfg.border,
            largeRooms
          };
        }
        // -------------------------
        // Phase B: Fill with small rooms
        // -------------------------
        function rectsGenerateCandidates(count, sizeMin, sizeMax, spawnRadius) {
          // Similar to test.html: biased sizes, later rounded
          const normal = () => (Math.random() + Math.random() + Math.random()) / 3; // 0..1
          const rects = [];
          for (let i = 0; i < count; i++) {
            const w = sizeMin.w + Math.round(normal() * (sizeMax.w - sizeMin.w));
            const h = sizeMin.h + Math.round(normal() * (sizeMax.h - sizeMin.h));
            rects.push({
              x: Math.random() * spawnRadius - spawnRadius / 2,
              y: Math.random() * spawnRadius - spawnRadius / 2,
              w: Math.max(sizeMin.w, w),
              h: Math.max(sizeMin.h, h),
            });
          }
          return rects;
        }
        function rectsSeparate(rects, iterations = 80) {
          // Push-apart pass, then round to ints
          for (let iter = 0; iter < iterations; iter++) {
            let moved = false;
            for (let j = 0; j < rects.length; j++) {
              const r1 = rects[j];
              for (let k = j + 1; k < rects.length; k++) {
                const r2 = rects[k];
                const dx = (r1.x + r1.w / 2) - (r2.x + r2.w / 2);
                const dy = (r1.y + r1.h / 2) - (r2.y + r2.h / 2);
                const halfW = (r1.w + r2.w) / 2;
                const halfH = (r1.h + r2.h) / 2;
                if (Math.abs(dx) < halfW && Math.abs(dy) < halfH) {
                  moved = true;
                  const ox = halfW - Math.abs(dx);
                  const oy = halfH - Math.abs(dy);
                  if (ox < oy) {
                    const m = (ox / 2) * (dx > 0 ? 1 : -1);
                    r1.x += m; r2.x -= m;
                  } else {
                    const m = (oy / 2) * (dy > 0 ? 1 : -1);
                    r1.y += m; r2.y -= m;
                  }
                }
              }
            }
            if (!moved && iter > 10) break;
          }
          // Round to integer grid
          return rects.map(r => ({
            x: Math.round(r.x),
            y: Math.round(r.y),
            w: Math.max(1, Math.round(r.w)),
            h: Math.max(1, Math.round(r.h)),
          }));
        }
        function rectIntersects(a, b) {
          return !(a.x + a.w - 1 < b.x || b.x + b.w - 1 < a.x || a.y + a.h - 1 < b.y || b.y + b.h - 1 < a.y);
        }
        function inflateRect(r, d) { return { x: r.x - d, y: r.y - d, w: r.w + 2*d, h: r.h + 2*d }; }
        function carveRoomIntoGrid(grid, r) {
            const H = grid.length, W = grid[0].length;
            for (let y = r.y + 1; y < r.y + r.h - 1; y++) {
                if (y <= 0 || y >= H - 1) continue;
                for (let x = r.x + 1; x < r.x + r.w - 1; x++) {
                    if (x <= 0 || x >= W - 1) continue;
                    grid[y][x] = TILE_FLOOR; // floor
                }
            }
        }
        function smallRoomsFillIntoGrid(grid, largeRooms, border, cfg = HYBRID_CFG.small) {
            const H = grid.length, W = grid[0].length;
            // Build a combined forbidden mask = outside interior OR within clearance of any large room
            const forbidden = (x, y) => {
                if (x < border || y < border || x >= W - border || y >= H - border) return true;
                return false;
            };
            // Inflate large rooms by clearance and treat them as blocked for small room placement
            const inflatedLarge = largeRooms.map(L => inflateRect({ x: L.x0, y: L.y0, w: L.w, h: L.h }, cfg.clearanceFromLarge));
            // Spawn candidates in a radius around map center
            const spawnRadius = Math.max(W, H);
            let candidates = rectsGenerateCandidates(cfg.candidateCount, cfg.minSize, cfg.maxSize, spawnRadius);
            candidates = rectsSeparate(candidates, cfg.separationIters);
            // Translate candidates from local space to map space: center them roughly at map center
            const ox = Math.floor(W / 2), oy = Math.floor(H / 2);
            candidates = candidates.map(r => ({ x: r.x + ox, y: r.y + oy, w: r.w, h: r.h }));
            // Filter candidates:
            const kept = [];
            for (const r of candidates) {
                // 1) Intersects interior?
                const inside =
                    r.x >= border && r.y >= border &&
                    r.x + r.w <= W - border && r.y + r.h <= H - border;
                if (!inside) continue;
                // 2) Avoid overlap with any inflated large room
                const overlapsLarge = inflatedLarge.some(L => rectIntersects(
                  { x: r.x, y: r.y, w: r.w, h: r.h }, L
                ));
                if (overlapsLarge) continue;
                // 3) Avoid carving into existing floors poorly: optional
                // We allow overlap with empty space; it is fine to merge.
                kept.push(r);
            }
            // Optionally thin out density
            const targetCount = Math.round(kept.length * clamp01(cfg.keepRatio));
            const smallRooms = shuffle(kept).slice(0, targetCount);
            // Carve
            for (const r of smallRooms) carveRoomIntoGrid(grid, r);
            // Return normalized descriptors for graph building
            const smallNormalized = smallRooms.map(r => ({
              kind: 'rect',
              x0: r.x, y0: r.y, x1: r.x + r.w - 1, y1: r.y + r.h - 1,
              w: r.w, h: r.h,
              center: { x: r.x + Math.floor(r.w / 2), y: r.y + Math.floor(r.h / 2) }
            }));
            return smallNormalized;
        }
        // -------------------------
        // Phase C: Corridors and connectivity
        // -------------------------
        function kruskal(edges, pointCount) {
            const mst = [];
            const parent = Array.from({ length: pointCount }, (_, i) => i);
            const find = i => parent[i] === i ? i : (parent[i] = find(parent[i]));
            const unite = (i, j) => {
                const a = find(i), b = find(j);
                if (a !== b) { parent[a] = b; return true; }
                return false;
            };
            edges.sort((a, b) => a.dist - b.dist);
            for (const e of edges) if (unite(e.p1, e.p2)) mst.push(e);
            return mst;
        }
        function buildEdgesFromDelaunay(points) {
            const vertices = points.map((p, i) => {
                const v = new Vertex(p.x, p.y);
                v.id = i;
                return v;
            });
            const triangleObjects = triangulate(vertices);
            const tri = [];
            for (const t of triangleObjects) {
                tri.push(t.v0.id, t.v1.id, t.v2.id);
            }
            const set = new Map();
            for (let i = 0; i < tri.length; i += 3) {
                const a = tri[i], b = tri[i + 1], c = tri[i + 2];
                const add = (i1, i2) => {
                    const key = i1 < i2 ? `${i1}-${i2}` : `${i2}-${i1}`;
                    if (!set.has(key)) {
                        const p = points[i1], q = points[i2];
                        set.set(key, { p1: i1, p2: i2, dist: Math.hypot(p.x - q.x, p.y - q.y) });
                    }
                };
                add(a, b); add(b, c); add(c, a);
            }
            return Array.from(set.values());
        }
        function carveLCorridor(grid, p1, p2) {
            let x = p1.x, y = p1.y;
            const tx = p2.x, ty = p2.y;

            if (Math.random() > 0.5) { // Go X then Y
                while (x !== tx) {
                    if (inBounds(grid, x, y)) grid[y][x] = TILE_FLOOR;
                    x += Math.sign(tx - x);
                }
                while (y !== ty) {
                    if (inBounds(grid, x, y)) grid[y][x] = TILE_FLOOR; // x is now tx
                    y += Math.sign(ty - y);
                }
            } else { // Go Y then X
                while (y !== ty) {
                    if (inBounds(grid, x, y)) grid[y][x] = TILE_FLOOR;
                    y += Math.sign(ty - y);
                }
                while (x !== tx) {
                    if (inBounds(grid, x, y)) grid[y][x] = TILE_FLOOR; // y is now ty
                    x += Math.sign(tx - x);
                }
            }
            // Always carve the final destination tile to guarantee connection
            if (inBounds(grid, tx, ty)) grid[ty][tx] = TILE_FLOOR;
        }
        function floodFillOpen(grid, start) {
            const H = grid.length, W = grid[0].length;
            const key = (x,y)=>`${x},${y}`;
            const seen = new Set();
            const q = [];
            if (start.x<0||start.y<0||start.x>=W||start.y>=H) return seen;
            if (grid[start.y][start.x] === TILE_WALL) return seen;
            q.push(start); seen.add(key(start.x,start.y));
            while (q.length) {
                const p = q.shift();
                for (const { dx, dy } of CARDINAL_DIRECTIONS) {
                    const nx = p.x + dx;
                    const ny = p.y + dy;
                    const k = key(nx, ny);
                    if (nx < 0 || ny < 0 || nx >= W || ny >= H) continue;
                    if (grid[ny][nx] === TILE_FLOOR && !seen.has(k)) {
                        seen.add(k);
                        q.push({ x: nx, y: ny });
                    }
                }
            }
            return seen;
        }
        function ensureConnectivity(grid, nodes) {
            // BFS from first node center; if a node is isolated, connect it to nearest reachable cell.
            if (nodes.length === 0) return;
            const start = nodes[0];
            let reachable = floodFillOpen(grid, {x: Math.round(start.center.x), y: Math.round(start.center.y)});
            const key = (x,y)=>`${x},${y}`;
            const has = (p)=>reachable.has(key(Math.round(p.center.x), Math.round(p.center.y)));
            for (const n of nodes) {
                if (has(n)) continue;
                // find nearest reachable cell
                let best = null, bestD = Infinity;
                for (const k of reachable) {
                    const [x,y] = k.split(',').map(Number);
                    const d = Math.abs(x - Math.round(n.center.x)) + Math.abs(y - Math.round(n.center.y));
                    if (d < bestD) { bestD = d; best = {x, y}; }
                }
                if (best) {
                    carveLCorridor(grid, {x: Math.round(n.center.x), y: Math.round(n.center.y)}, best);
                    reachable = floodFillOpen(grid, {x: Math.round(start.center.x), y: Math.round(start.center.y)});
                }
            }
        }
        // -------------------------
        // Master generator
        // -------------------------
        function generateDungeon() {
            // Phase A: large-room scaffold
            const largeOut = generateLargeRoomsScaffold(HYBRID_CFG.large);
            // Adopt dynamic map sizing from scaffold
            mapState.width = largeOut.width;
            mapState.height = largeOut.height;
            const grid = largeOut.grid.map(row => row.slice()); // copy
            const allLarge = largeOut.largeRooms;
            // Phase B: small rooms filling
            const smallRooms = smallRoomsFillIntoGrid(grid, allLarge, largeOut.border, HYBRID_CFG.small);
            // Unified node list (centers)
            const allRooms = [
                ...allLarge.map(R => ({ kind: R.kind, center: { x: R.center.x, y: R.center.y } })),
                ...smallRooms.map(r => ({ kind: r.kind, center: r.center }))
            ];
            // Phase C: corridors (only now)
            const points = allRooms.map(r => ({ x: r.center.x, y: r.center.y }));
            const edges = buildEdgesFromDelaunay(points);
            const mst = kruskal(edges, points.length);
            // Add sparse extra edges
            const extrasCount = Math.floor(edges.length * HYBRID_CFG.corridors.extraEdgeFraction);
            const extraEdges = shuffle(edges.filter(e => !mst.includes(e))).slice(0, extrasCount);
            const finalEdges = mst.concat(extraEdges);
            // Carve corridors
            for (const e of finalEdges) {
                carveLCorridor(grid, points[e.p1], points[e.p2]);
            }
            // Rescue connectivity if any isolated parts remain
            if (HYBRID_CFG.corridors.rescueConnectivity) {
                ensureConnectivity(grid, allRooms);
            }
            // Choose start/end on far rooms
            const start = allRooms[0]?.center || { x: Math.floor(mapState.width/2), y: Math.floor(mapState.height/2) };
            let farIdx = 0, farDist = -1;
            for (let i = 0; i < allRooms.length; i++) {
                const d = manhattan(start, allRooms[i].center);
                if (d > farDist) { farDist = d; farIdx = i; }
            }
            const end = allRooms[farIdx]?.center || start;
            // Force floors at start/end
            if (grid[Math.round(start.y)]?.[Math.round(start.x)] === TILE_WALL) grid[Math.round(start.y)][Math.round(start.x)] = TILE_FLOOR;
            if (grid[Math.round(end.y)]?.[Math.round(end.x)] === TILE_WALL) grid[Math.round(end.y)][Math.round(end.x)] = TILE_FLOOR;
            return {
                grid,
                start: { x: Math.round(start.x), y: Math.round(start.y) },
                end: { x: Math.round(end.x), y: Math.round(end.y) }
            };
        }
        function applyCellSize(size) {
            const clamped = Math.max(MIN_CELL_SIZE, Math.floor(size));
            CELL_SIZE = clamped;
            HALF_CELL = CELL_SIZE / 2;
            if (viewportEl) {
                viewportEl.style.width = `${VIEW_W * CELL_SIZE}px`;
                viewportEl.style.height = `${VIEW_H * CELL_SIZE}px`;
            }
            if (canvas) {
                canvas.width = mapState.width * CELL_SIZE;
                canvas.height = mapState.height * CELL_SIZE;
            }
        }
        function updateResponsiveLayout(forceRedraw = true) {
            if (!mapState.width || !mapState.height) return;
            if (!containerEl || !viewportEl || !canvas) return;
            const appContainer = document.getElementById('app-container');
            const uiPanel = document.getElementById('ui-panel');
            if (!appContainer || !uiPanel) return;

            const measure = () => {
                const containerRect = containerEl.getBoundingClientRect();
                const viewportRect = viewportEl.getBoundingClientRect();
                const appRect = appContainer.getBoundingClientRect();
                const uiRect = uiPanel.getBoundingClientRect();
                return { containerRect, viewportRect, appRect, uiRect };
            };

            applyCellSize(CONFIG.visual.cellSize);
            let metrics = measure();
            const viewportWidth = metrics.viewportRect.width || (VIEW_W * CELL_SIZE);
            const viewportHeight = metrics.viewportRect.height || (VIEW_H * CELL_SIZE);
            const nonViewportWidth = metrics.appRect.width - viewportWidth;
            const nonViewportHeight = metrics.containerRect.height - viewportHeight;

            const widthBudget = window.innerWidth - nonViewportWidth;
            const heightBudget = window.innerHeight - nonViewportHeight;

            const widthRatio = viewportWidth > 0 ? Math.max(0, widthBudget / viewportWidth) : 1;
            const heightRatio = viewportHeight > 0 ? Math.max(0, heightBudget / viewportHeight) : 1;
            let scale = Math.min(1, widthRatio, heightRatio);
            if (!Number.isFinite(scale) || scale <= 0) {
                const safeWidth = widthRatio > 0 ? widthRatio : 1;
                const safeHeight = heightRatio > 0 ? heightRatio : 1;
                scale = Math.min(1, safeWidth, safeHeight);
            }

            const targetSize = Math.max(
                MIN_CELL_SIZE,
                Math.min(CONFIG.visual.cellSize, Math.floor(CONFIG.visual.cellSize * scale))
            );
            applyCellSize(targetSize);
            metrics = measure();

            let safety = 0;
            while (safety < 25) {
                const totalWidth = metrics.appRect.width;
                const totalHeight = Math.max(metrics.containerRect.height, metrics.uiRect.height);
                if ((totalWidth <= window.innerWidth || CELL_SIZE <= MIN_CELL_SIZE) &&
                    (totalHeight <= window.innerHeight || CELL_SIZE <= MIN_CELL_SIZE)) {
                    break;
                }
                if (CELL_SIZE <= MIN_CELL_SIZE) break;
                applyCellSize(CELL_SIZE - 1);
                metrics = measure();
                safety++;
            }

            if (forceRedraw) redrawAfterResize();
        }
        function redrawAfterResize() {
            if (!mapState.grid || !mapState.grid.length) return;
            if (!player || !player.pos) return;
            refreshLightingVisuals();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let y = 0; y < mapState.height; y++) {
                for (let x = 0; x < mapState.width; x++) {
                    if (!mapState.explored[y][x]) continue;
                    const key = posKey({ x, y });
                    const isVisible = fovState.currentVisible.has(key);
                    const isStart = player.startPos && x === player.startPos.x && y === player.startPos.y;
                    const isEnd = currentEndPos && x === currentEndPos.x && y === currentEndPos.y && isEndRendered;
                    drawCell(x, y, isVisible, false, isStart, isEnd);
                }
            }
            const playerKey = posKey(player.pos);
            const isPlayerVisible = fovState.currentVisible.has(playerKey);
            const isStart = player.startPos && player.pos.x === player.startPos.x && player.pos.y === player.startPos.y;
            const isEnd = currentEndPos && player.pos.x === currentEndPos.x && player.pos.y === currentEndPos.y;
            drawCell(player.pos.x, player.pos.y, isPlayerVisible, true, isStart, isEnd);
            updateCamera(player.pos);
            if (minimapModalEl && minimapModalEl.style.display === 'flex') {
                renderMinimapDynamic();
            }
        }
        function handleResize() {
            if (!mapState.grid || !mapState.grid.length) return;
            updateResponsiveLayout(true);
        }
        // --- UI & RENDER FUNCTIONS ---
        function setupDOM() {
            equipmentSlotsDiv.innerHTML = '';
            inventorySlotsDiv.innerHTML = '';
            ALL_SLOTS_ORDER.forEach(slotName => {
                const slot = document.createElement('div');
                slot.classList.add('slot');
                slot.id = `equip-${slotName}`;
                slot.dataset.slot = slotName;
                const label = labelForSlot(slotName);
                slot.innerHTML = `<div class="slot-label">${label}</div><div class="slot-item"></div>`;
                equipmentSlotsDiv.appendChild(slot);
            });
            const inventory = player?.inventory;
            const capacity = typeof inventory?.capacitySlots === 'number' ? inventory.capacitySlots : 0;
            const stackLength = Array.isArray(inventory?.stacks) ? inventory.stacks.length : 0;
            const invCapacity = Math.max(capacity, stackLength);
            for (let i = 0; i < invCapacity; i++) {
                const slot = document.createElement('div');
                slot.classList.add('slot');
                slot.id = `inv-${i}`;
                inventorySlotsDiv.appendChild(slot);
            }
            updateResponsiveLayout(false);
        }

        function tooltipForItem(item) {
            if (!item) return '';
            const throwInfo = describeThrowable(item);
            if (isRangedWeapon(item)) {
                const base = RangedCombat.describeRangedWeapon(item);
                return throwInfo ? `${base}\nThrow: ${throwInfo}` : base;
            }
            const name = item.name || '';
            return throwInfo ? `${name}\nThrow: ${throwInfo}` : name;
        }

        function tooltipForStack(stack) {
            if (!stack) return '';
            return tooltipForItem(stack.item);
        }

        function renderUI() {
            for (const slotName of ALL_SLOTS_ORDER) {
                const itemDiv = document.querySelector(`#equip-${slotName} .slot-item`);
                if (!itemDiv) continue;
                const it = player.equipment.get(slotName);
                itemDiv.textContent = it ? it.name : '-';
                const slotEl = document.getElementById(`equip-${slotName}`);
                if (slotEl) {
                    const tip = tooltipForItem(it);
                    if (tip) slotEl.title = tip; else slotEl.removeAttribute('title');
                }
            }
            for (let i=0; i<player.inventory.capacitySlots; i++) {
                const slotDiv = document.getElementById(`inv-${i}`);
                if (!slotDiv) break;
                const st = player.inventory.stacks[i];
                slotDiv.innerHTML = st ? `<div class="slot-item">${st.name}${st.item.stackable ? ` ×${st.qty}` : ''}</div>` : '';
                const tip = tooltipForStack(st);
                if (tip) slotDiv.title = tip; else slotDiv.removeAttribute('title');
            }
        }

        // Keep the viewport centred on the player without allowing the camera to
        // drift past the map edges. This is effectively a clamped translation
        // that mimics a traditional roguelike "camera" following the hero.
        function updateCamera(playerPos) {
            const mapPxW = mapState.width * CELL_SIZE;
            const mapPxH = mapState.height * CELL_SIZE;
            const vw = VIEW_W * CELL_SIZE;
            const vh = VIEW_H * CELL_SIZE;
            const desiredX = vw / 2 - (playerPos.x + 0.5) * CELL_SIZE;
            const desiredY = vh / 2 - (playerPos.y + 0.5) * CELL_SIZE;
            const tx = Math.round(Math.max(vw - mapPxW, Math.min(0, desiredX)));
            const ty = Math.round(Math.max(vh - mapPxH, Math.min(0, desiredY)));
            canvas.style.transform = `translate3d(${tx}px, ${ty}px, 0)`;
        }
        // Render a single map tile. The function intentionally duplicates a bit
        // of style logic (instead of delegating to CSS classes) so we can keep
        // rendering on the canvas fast and free from layout thrashing.
        function drawCell(x, y, isVisible, isPlayer = false, isStart = false, isEnd = false) {
            const cellX = x * CELL_SIZE;
            const cellY = y * CELL_SIZE;
            if (!mapState.explored[y][x]) return; // Unexplored cells retain the base background color
            const { colors } = CONFIG.visual;
            let bgColor = colors.unseen;
            let text = '';
            let textColor = colors.defaultText;
            let fontWeight = '';
            const isWall = mapState.grid[y][x] === TILE_WALL;
            if (isWall) {
                bgColor = colors.wall;
                textColor = 'transparent';
            } else {
                bgColor = colors.floor;
                text = '·';
                textColor = colors.floorGlyph;
            }
            if (isStart) bgColor = colors.start;
            if (isEnd) bgColor = colors.end;
            if (isPlayer) {
                bgColor = colors.player;
                text = '@';
                textColor = colors.playerGlyph;
                fontWeight = 'bold ';
            }
            ctx.fillStyle = bgColor;
            if (isPlayer) {
                ctx.beginPath();
                ctx.arc(cellX + HALF_CELL, cellY + HALF_CELL, HALF_CELL, 0, 2 * Math.PI);
                ctx.fill();
            } else {
                ctx.fillRect(cellX, cellY, CELL_SIZE, CELL_SIZE);
            }
            if (text) {
                const glyphSize = Math.max(10, Math.floor(CELL_SIZE * 0.85));
                ctx.font = `${fontWeight}${glyphSize}px monospace`;
                ctx.fillStyle = textColor;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, cellX + HALF_CELL, cellY + HALF_CELL);
            }
            if (isVisible) {
                ctx.fillStyle = fovState.overlayStyle;
                ctx.fillRect(cellX, cellY, CELL_SIZE, CELL_SIZE);
            }
        }
        // Updates the persistent fog-of-war state as the player moves. This both
        // records which tiles were ever seen (explorationState) and promotes nearby
        // floor cells to "frontiers" so the explorer knows where to head next.
        function updateVisionAndExploration(pos) {
            const lightRadius = getLightRadius();
            const radiusSq = lightRadius * lightRadius;
            explorationState.newlyExplored = [];
            const visibleCells = computeFieldOfView(pos, lightRadius, false);
            fovState.lastCache = { key: posKey(pos), radius: lightRadius, visible: visibleCells };
            const cellsToUpdate = new Set(visibleCells);
            for (const cellKey of visibleCells) {
                const [x, y] = cellKey.split(',').map(Number);
                if (mapState.grid[y][x] === TILE_FLOOR) {
                    for (const { dx, dy } of CARDINAL_DIRECTIONS) {
                        const n = { x: x + dx, y: y + dy };
                        const withinRadius = (n.x - pos.x) * (n.x - pos.x) + (n.y - pos.y) * (n.y - pos.y) <= radiusSq;
                        if (withinRadius && n.x >= 0 && n.x < mapState.width && n.y >= 0 && n.y < mapState.height && mapState.grid[n.y][n.x] === TILE_WALL) {
                            cellsToUpdate.add(posKey(n));
                        }
                    }
                }
            }
            for (const cellKey of cellsToUpdate) {
                const [x, y] = cellKey.split(',').map(Number);
                if (!mapState.explored[y][x]) {
                    explorationState.newlyExplored.push({x, y});
                }
                mapState.explored[y][x] = true;
                mapState.known[y][x] = mapState.grid[y][x];
                if (mapState.known[y][x] === TILE_FLOOR) {
                    const neighbors = [
                        {x: x, y: y-1}, {x: x, y: y+1}, {x: x-1, y: y}, {x: x+1, y: y},
                        {x: x-1, y: y-1}, {x: x-1, y: y+1}, {x: x+1, y: y-1}, {x: x+1, y: y+1}
                    ];
                    const hasUnknown = neighbors.some(n =>
                        n.x >= 0 && n.x < mapState.width && n.y >= 0 && n.y < mapState.height && mapState.known[n.y][n.x] === -1
                    );
                    if (hasUnknown) {
                        explorationState.frontiers.add(posKey({x, y}));
                    } else {
                        explorationState.frontiers.delete(posKey({x, y}));
                    }
                }
            }
        }
        // Heuristic scoring for neighbouring tiles when no direct goal is
        // available. Higher scores favour cells that reveal new territory while
        // penalising ones we recently stepped on (shortTermMemory) to reduce
        // aimless oscillation.
        function explorationScore(pos, shortTermMemory) {
            let score = 0;
            const lightRadius = getLightRadius();
            const visibleCells = computeFieldOfView(pos, lightRadius, true);
            for (const cellKey of visibleCells) {
                const [x, y] = cellKey.split(',').map(Number);
                if (mapState.known[y][x] === -1) {
                    score++;
                }
            }
            if (shortTermMemory.includes(posKey(pos))) {
                score -= SHORT_TERM_MEMORY_PENALTY;
            }
            return score;
        }
        // Classic breadth-first search that respects the knowledge gathered so
        // far. We allow the caller to provide a short-term memory blacklist so
        // the AI can temporarily avoid tiles that caused recent backtracking.
        // Callers can explicitly disable this penalty via the ignoreShortTermMemory
        // option when a full backtrack is desired.
        function bfsToTarget(start, target, shortTermMemory, options = {}) {
            const { ignoreShortTermMemory = false } = options;
            const startKey = posKey(start);
            const targetKey = posKey(target);
            if (startKey === targetKey) {
                return [];
            }

            const restricted = (!ignoreShortTermMemory && shortTermMemory && shortTermMemory.length > 0)
                ? new Set(shortTermMemory)
                : null;

            const queue = [start];
            let head = 0;
            const visited = new Set([startKey]);
            const parents = new Map();

            while (head < queue.length) {
                const current = queue[head++];
                const currentKey = posKey(current);

                if (currentKey === targetKey) {
                    const path = [];
                    let key = targetKey;
                    while (key !== startKey) {
                        const parentKey = parents.get(key);
                        if (!parentKey) {
                            throw new Error(`BFS logic error: No parent found for key ${key} when reconstructing path from ${startKey} to ${targetKey}`);
                        }
                        const [x, y] = key.split(',').map(Number);
                        path.unshift({ x, y });
                        key = parentKey;
                    }
                    return path;
                }

                for (const { dx, dy } of CARDINAL_DIRECTIONS) {
                    const nx = current.x + dx;
                    const ny = current.y + dy;
                    if (nx < 0 || nx >= mapState.width || ny < 0 || ny >= mapState.height) {
                        continue;
                    }

                    if (mapState.known[ny][nx] !== TILE_FLOOR) {
                        continue;
                    }

                    const neighborKey = posKey({ x: nx, y: ny });
                    if (visited.has(neighborKey)) {
                        continue;
                    }

                    if (restricted && restricted.has(neighborKey)) {
                        continue;
                    }

                    visited.add(neighborKey);
                    parents.set(neighborKey, currentKey);
                    queue.push({ x: nx, y: ny });
                }
            }
            return null;
        }
        function renderInitial(playerPos, startPos, endPos) {
            refreshLightingVisuals();
            fovState.currentVisible = computeVisibleCells(playerPos);
            // Draw all initially explored cells
            for (const pos of explorationState.newlyExplored) {
                const key = posKey(pos);
                const isVis = fovState.currentVisible.has(key);
                const isS = pos.x === startPos.x && pos.y === startPos.y;
                const isE = pos.x === endPos.x && pos.y === endPos.y;
                if (isE) isEndRendered = true;
                drawCell(pos.x, pos.y, isVis, false, isS, isE);
            }
            // Draw player
            drawCell(playerPos.x, playerPos.y, true, true, true, false); // Start is player pos initially
        }
        function renderDelta(prevPlayerPos, playerPos, endPos) {
            refreshLightingVisuals();
            // Redraw cells where visibility turned off
            for (const key of fovState.prevVisible) {
                if (!fovState.currentVisible.has(key)) {
                    const [x, y] = key.split(',').map(Number);
                    const isS = x === player.startPos.x && y === player.startPos.y;
                    const isE = x === endPos.x && y === endPos.y;
                    drawCell(x, y, false, false, isS, isE);
                }
            }
            // Redraw old player position (without player)
            if (prevPlayerPos) {
                const oldKey = posKey(prevPlayerPos);
                const isVis = fovState.currentVisible.has(oldKey);
                const isS = prevPlayerPos.x === player.startPos.x && prevPlayerPos.y === player.startPos.y;
                const isE = prevPlayerPos.x === endPos.x && prevPlayerPos.y === endPos.y;
                drawCell(prevPlayerPos.x, prevPlayerPos.y, isVis, false, isS, isE);
            }
            // Draw newly explored cells
            for (const pos of explorationState.newlyExplored) {
                const key = posKey(pos);
                const isVis = fovState.currentVisible.has(key);
                const isS = pos.x === player.startPos.x && pos.y === player.startPos.y;
                let isE = pos.x === endPos.x && pos.y === endPos.y;
                if (isE && !isEndRendered) {
                    isEndRendered = true;
                }
                drawCell(pos.x, pos.y, isVis, false, isS, isE);
            }
            // Draw newly visible cells that were already explored
            for (const key of fovState.currentVisible) {
                if (!fovState.prevVisible.has(key)) {
                    const [x, y] = key.split(',').map(Number);
                    const alreadyNew = explorationState.newlyExplored.some(p => p.x === x && p.y === y);
                    if (!alreadyNew) {
                        const isS = x === player.startPos.x && y === player.startPos.y;
                        const isE = x === endPos.x && y === endPos.y;
                        drawCell(x, y, true, false, isS, isE);
                    }
                }
            }
            // Draw new player position
            const newKey = posKey(playerPos);
            const isVis = fovState.currentVisible.has(newKey);
            const isS = playerPos.x === player.startPos.x && playerPos.y === player.startPos.y;
            const isE = playerPos.x === endPos.x && playerPos.y === endPos.y;
            drawCell(playerPos.x, playerPos.y, isVis, true, isS, isE);
        }
        // --- SIMULATION LOGIC ---
        // Main autonomous exploration loop. The routine alternates between three
        // behaviours: beeline to the exit once discovered, opportunistically
        // explore high-value neighbours, and finally backtrack via the frontier
        // stack when no better move exists.
        function simulate(startPos, endPos) {
            statusDiv.textContent = 'AI exploring...';
            restartBtn.style.display = 'none';
            player.x = startPos.x;
            player.y = startPos.y;
            const stack = [];
            const visitedForPathfinding = new Set([posKeyFromCoords(player.x, player.y)]);
            let shortTermMemory = [];
            explorationState.frontiers.clear();
            simState.turnCounter = 0;
            if (!mobManager) {
                mobManager = new MobManager();
                // Removed redundant mobManager.add(player); to prevent duplicate addition
            }
            const gameCtx = {
                player,
                mobManager,
                maze: mapState.grid,
            };
            function gameLoop() {
                clearTimeout(simState.timeout);
                if (!simState.isPaused) {
                    const turn = ++simState.turnCounter;
                    tickStatusesAtTurnStart(player, turn);
                    if (mobManager) {
                        mobManager.tick(gameCtx, turn);
                    }
                    const currentPlayerX = player.x;
                    const currentPlayerY = player.y;
                    const currentPos = { x: currentPlayerX, y: currentPlayerY };
                    if (currentPlayerX === endPos.x && currentPlayerY === endPos.y) {
                        clearTimeout(simState.timeout);
                        simState.timeout = null;
                        simState.loopFn = null;
                        statusDiv.textContent = 'Exit found!';
                        renderDelta(hasPrevPlayerPos ? prevPlayerPos : null, currentPos, endPos);
                        restartBtn.style.display = 'block';
                        return;
                    }
                    // Track a short trail of recently visited tiles so the explorer does not keep
                    // oscillating in the same small loop.
                    const currentKey = posKeyFromCoords(currentPlayerX, currentPlayerY);
                    shortTermMemory.push(currentKey);
                    if (shortTermMemory.length > CONFIG.ai.shortTermMemory) {
                        shortTermMemory.shift();
                    }
                    let nextMove = null;
                    let nextX = currentPlayerX;
                    let nextY = currentPlayerY;
                    let nextPos = currentPos;
                    if (mapState.known[endPos.y][endPos.x] === TILE_FLOOR) {
                        // Once the exit has been discovered we greedily follow the fastest path to
                        // it, ignoring the short-term memory so backtracking is allowed.
                        const pathToExit = bfsToTarget(currentPos, endPos, shortTermMemory, { ignoreShortTermMemory: true });
                        if (pathToExit && pathToExit.length > 0) {
                            nextMove = pathToExit[0];
                        }
                    }
                    if (!nextMove) {
                        const neighbors = CARDINAL_DIRECTIONS.map(({ dx, dy }) => ({
                            x: currentPlayerX + dx,
                            y: currentPlayerY + dy
                        }));
                        const unvisitedNeighbors = neighbors.filter(n =>
                            n.x >= 0 && n.x < mapState.width && n.y >= 0 && n.y < mapState.height &&
                            mapState.known[n.y][n.x] === TILE_FLOOR &&
                            !visitedForPathfinding.has(posKey(n))
                        );
                        const potentialMoves = unvisitedNeighbors.map(n => ({pos: n, score: explorationScore(n, shortTermMemory)}));
                        potentialMoves.sort((a, b) => b.score - a.score + (Math.random() - 0.5));
                        if (potentialMoves.length > 0 && potentialMoves[0].score > 0) {
                            stack.push({ x: currentPlayerX, y: currentPlayerY });
                            nextMove = potentialMoves[0].pos;
                        }
                    }
                    if (!nextMove && explorationState.frontiers.size > 0) {
                        // When no enticing neighbour exists we fall back to the nearest frontier:
                        // a lit floor tile that borders unexplored darkness. BFS charts a safe
                        // course to the chosen frontier.
                        let closestFrontier = null;
                        let minDist = Infinity;
                        for (const fKey of explorationState.frontiers) {
                            const [fx, fy] = fKey.split(',').map(Number);
                            const dist = Math.abs(currentPlayerX - fx) + Math.abs(currentPlayerY - fy);
                            if (dist < minDist) {
                                minDist = dist;
                                closestFrontier = {x: fx, y: fy};
                            }
                        }
                        // When traveling to a distant frontier we must allow full backtracking,
                        // so ignore the short-term memory penalty during pathfinding.
                        const pathToFrontier = bfsToTarget(currentPos, closestFrontier, shortTermMemory, { ignoreShortTermMemory: true });
                        if (pathToFrontier && pathToFrontier.length > 0) {
                            nextMove = pathToFrontier[0];
                        }
                    }
                    if (!nextMove && stack.length > 0) {
                        // The depth-first stack gives us deterministic backtracking when every
                        // other heuristic is exhausted.
                        nextMove = stack.pop();
                    }
                    if (nextMove) {
                        prevPlayerPos.x = currentPlayerX;
                        prevPlayerPos.y = currentPlayerY;
                        if (!hasPrevPlayerPos) hasPrevPlayerPos = true;
                        player.pos = nextMove;
                        player.x = nextMove.x;
                        player.y = nextMove.y;
                        if (mobManager) {
                            mobManager.reindex();
                        }
                        nextX = player.x;
                        nextY = player.y;
                        nextPos = { x: nextX, y: nextY };
                        const stepKey = posKeyFromCoords(nextX, nextY);
                        if (!visitedForPathfinding.has(stepKey)) {
                            visitedForPathfinding.add(stepKey);
                        }
                    } else {
                        clearTimeout(simState.timeout);
                        simState.timeout = null;
                        simState.loopFn = null;
                        statusDiv.textContent = 'AI is trapped!';
                        restartBtn.style.display = 'block';
                        return;
                    }
                    updateVisionAndExploration(nextPos);
                    fovState.currentVisible = computeVisibleCells(nextPos);
                    renderDelta(hasPrevPlayerPos ? prevPlayerPos : null, nextPos, endPos);
                    updateCamera(nextPos);
                    fovState.prevVisible = new Set(fovState.currentVisible);
                    minimapMaybeRefreshOnTick();
                }
                const speedMultiplier = 1 - (player.statusDerived?.actionSpeedPct ?? 0);
                const safeMultiplier = Math.max(0.1, speedMultiplier);
                const delay = Math.max(16, (1000 / simState.speed) * safeMultiplier);
                simState.timeout = setTimeout(gameLoop, delay);
            }
            simState.loopFn = gameLoop;
            gameLoop();
        }
        function togglePause() {
            simState.isPaused = !simState.isPaused;
            if (simState.isPaused) {
                pauseIndicator.textContent = 'PAUSED';
            } else {
                pauseIndicator.textContent = '';
                if (typeof simState.loopFn === 'function') {
                    simState.timeout = setTimeout(simState.loopFn, 1000 / simState.speed); // Resume the loop
                }
            }
        }
        function resetSimulationStateForInit() {
            clearTimeout(simState.timeout);
            simState.loopFn = null;
            simState.isPaused = false;
            pauseIndicator.textContent = '';
            statusDiv.textContent = 'Generating dungeon...';
            restartBtn.style.display = 'none';
            currentEndPos = null;
            hasPrevPlayerPos = false;
            simState.turnCounter = 0;
        }

        function setupPlayer() {
            const newPlayer = new Player({ name: "Player", x: 0, y: 0 });

            if (!mobManager) {
                throw new Error("mobManager is not initialized before setupPlayer() is called.");
            }
            mobManager.add(newPlayer);

            // Wearables
            newPlayer.equipment.equipTo(SLOT.Head,       makeItem("leather_cap"));
            newPlayer.equipment.equipTo(SLOT.BodyArmor,  makeItem("basic_clothes"));
            newPlayer.equipment.equipTo(SLOT.Cloak,      makeItem("cloak"));
            newPlayer.equipment.equipTo(SLOT.Belt,       makeItem("belt_leather"));
            newPlayer.equipment.equipTo(SLOT.Backpack,   makeItem("pack_rucksack")); // choose pack
            newPlayer.equipment.equipTo(SLOT.LeftHand,   makeItem("torch"));
            newPlayer.equipment.equipTo(SLOT.RightHand,  makeItem("short_sword"));
            // Belt attachments
            newPlayer.equipment.equipTo(SLOT.Belt1,      makeItem("pouch_small"));
            newPlayer.equipment.equipTo(SLOT.Belt2,      makeItem("bow_short"));
            newPlayer.equipment.equipTo(SLOT.Quiver,     makeItem("quiver_std"));

            // Inventory constraints come from backpack
            newPlayer.inventory = new Inventory(DEFAULT_INVENTORY_CAPACITY);
            newPlayer.inventory.setConstraints(newPlayer.equipment.currentBackpackConstraints());

            // Seed inventory
            newPlayer.inventory.add(new ItemStack(makeItem("torch"), 3));
            newPlayer.inventory.add(new ItemStack(makeItem("arrow_wood"), 20));
            newPlayer.inventory.add(new ItemStack(makeItem("bolt_wood"), 15));
            newPlayer.inventory.add(new ItemStack(makeItem("sling_stone"), 40));
            newPlayer.inventory.add(new ItemStack(makeItem("dagger")));
            newPlayer.inventory.add(makeItem("crossbow_light"));
            newPlayer.inventory.add(new ItemStack(makeItem("sling_leather")));
            newPlayer.inventory.add(new ItemStack(makeItem("throwing_knife"), 4));
            newPlayer.inventory.add(new ItemStack(makeItem("javelin"), 3));
            newPlayer.inventory.add(new ItemStack(makeItem("boots")));
            newPlayer.inventory.add(new ItemStack(makeItem("gloves")));
            newPlayer.inventory.add(new ItemStack(makeItem("amulet_simple")));
            newPlayer.inventory.add(new ItemStack(makeItem("pouch_small")));

            return newPlayer;
        }

        function generateAndValidateDungeon() {
            statusDiv.textContent = 'Generating hybrid dungeon...';
            const dungeonData = generateDungeon();
            if (!dungeonData) {
                return { success: false, reason: 'generation' };
            }

            mapState.grid = dungeonData.grid;
            mapState.width = mapState.grid[0].length;
            mapState.height = mapState.grid.length;

            const isConnected = !!aStarPath(mapState.grid, dungeonData.start, dungeonData.end);
            if (!isConnected) {
                return { success: false, reason: 'connectivity' };
            }

            return { success: true, dungeonData };
        }

        function handleDungeonFailure(reason) {
            if (reason === 'generation') {
                statusDiv.textContent = 'Map generation failed, retrying...';
                initRetries++;
                setTimeout(init, 100);
            } else if (reason === 'connectivity') {
                statusDiv.textContent = 'Map is not fully connected, regenerating...';
                initRetries++;
                setTimeout(init, 50);
            }
        }

        function initializeSimulation(dungeonData) {
            const startPos = dungeonData.start;
            const endPos = dungeonData.end;
            currentEndPos = endPos;

            mapState.explored = Array.from({ length: mapState.height }, () => Array(mapState.width).fill(false));
            mapState.known = Array.from({ length: mapState.height }, () => Array(mapState.width).fill(-1));

            setupDOM();

            player.pos = startPos;
            player.startPos = startPos;
            isEndRendered = false;
            fovState.prevVisible = new Set();
            hasPrevPlayerPos = false;
            fovState.currentVisible = new Set();
            explorationState.newlyExplored = [];
            fovState.lastCache = { key: null, radius: null, visible: null };

            updateVisionAndExploration(player.startPos);
            renderInitial(player.startPos, player.startPos, endPos);
            updateCamera(player.startPos);
            renderUI();
            fovState.prevVisible = computeVisibleCells(player.startPos);
            prevPlayerPos.x = player.startPos.x;
            prevPlayerPos.y = player.startPos.y;
            hasPrevPlayerPos = true;
            initRetries = 0;
            simState.isReady = true;

            setTimeout(() => simulate(player.startPos, endPos), 500);
        }

        function init() {
            if (initRetries > MAX_INIT_RETRIES) {
                statusDiv.textContent = 'Fatal Error: Map generation failed repeatedly.';
                console.error('Map generation failed after multiple retries.');
                return;
            }

            simState.isReady = false;
            resetSimulationStateForInit();
            minimapBase = null;
            mobManager = new MobManager();
            player = setupPlayer();

            setTimeout(() => {
                const result = generateAndValidateDungeon();
                if (!result.success) {
                    handleDungeonFailure(result.reason);
                    return;
                }

                initializeSimulation(result.dungeonData);
            }, 50);
        }
        function bootstrap() {
            const ticksPerSecond = CONFIG.ai.ticksPerSecond;
            speedSlider.value = ticksPerSecond;
            speedValue.textContent = `${ticksPerSecond} tps`;
            restartBtn.addEventListener('click', init);
            speedSlider.addEventListener('input', (e) => {
                simState.speed = parseInt(e.target.value, 10);
                speedValue.textContent = `${simState.speed} tps`;
            });
            window.addEventListener('resize', handleResize);
            window.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    e.preventDefault();
                    togglePause();
                }
            });
            initMinimapDOM();
            init();
        }
        // ===================== MINIMAP =====================
        let minimapBase = null;      // offscreen static layer (map tiles)
        let minimapScale = 1;        // pixels per tile inside the minimap canvas
        let minimapPadding = CONFIG.minimap.padding;      // visual padding around map in tiles

        const MINIMAP_COLORS = CONFIG.minimap.colors;

        function initMinimapDOM() {
          minimapModalEl = document.getElementById("minimapModal");
          minimapCanvas  = document.getElementById("minimapCanvas");
          minimapCtx     = minimapCanvas.getContext("2d");
          minimapCloseBtn= document.getElementById("minimapClose");

          minimapCloseBtn.addEventListener("click", closeMinimap);
          document.addEventListener("keydown", (e) => {
            if (e.key === "m" || e.key === "M") toggleMinimap();
            if (e.key === "Escape" && isMinimapOpen()) closeMinimap();
          });
        }

        function isMinimapOpen() {
          return minimapModalEl && minimapModalEl.style.display === "flex";
        }

        function openMinimap() {
          if (!minimapModalEl) initMinimapDOM();
          minimapModalEl.style.display = "flex";       // make it visible first
          
          // Defer canvas work until the browser has computed the new layout for the modal.
          // This prevents reading stale dimensions before the CSS `display:flex` is applied.
          requestAnimationFrame(() => {
            prepareMinimapCanvasBackingStore(); // Sets canvas resolution from CSS size
            renderMinimapDynamic(); // Renders map (and builds base texture if needed)
          });
        }

        function closeMinimap() {
          if (minimapModalEl) minimapModalEl.style.display = "none";
        }

        function toggleMinimap() {
          if (!simState.isReady) return;
          if (isMinimapOpen()) closeMinimap(); else openMinimap();
        }

        function getPlayerPos() {
          // Accept either player.x/y or player.pos.x/y
          if (!player) return { x: 0, y: 0 };
          if (typeof player.x === "number" && typeof player.y === "number") return { x: player.x, y: player.y };
          if (player.pos && typeof player.pos.x === "number" && typeof player.pos.y === "number") return { x: player.pos.x, y: player.pos.y };
          return { x: 0, y: 0 };
        }

        function prepareMinimapCanvasBackingStore() {
          // Use visible box size when the modal is open
          const rect = minimapCanvas.getBoundingClientRect();
          const dpr = window.devicePixelRatio || 1;

          // Fallback if somehow still zero (should not happen after display:flex)
          const cssW = rect.width  > 0 ? rect.width  : minimapCanvas.width  || MINIMAP_DEFAULT_DIMENSION;
          const cssH = rect.height > 0 ? rect.height : minimapCanvas.height || MINIMAP_DEFAULT_DIMENSION;

          minimapCanvas.width  = Math.max(1, Math.round(cssW * dpr));
          minimapCanvas.height = Math.max(1, Math.round(cssH * dpr));
        }

        function buildMinimapBase() {
          if (!mapState.grid || !mapState.grid.length) return;

          const pad = minimapPadding;
          const tilesW = mapState.width + pad * 2;
          const tilesH = mapState.height + pad * 2;

          // Use current canvas backing size (already set by prepareMinimapCanvasBackingStore on open)
          const targetW = minimapCanvas.width  || MINIMAP_DEFAULT_DIMENSION;
          const targetH = minimapCanvas.height || MINIMAP_DEFAULT_DIMENSION;

          minimapScale = Math.max(1, Math.floor(Math.min(
            targetW / tilesW,
            targetH / tilesH
          )));

          // Offscreen base
          minimapBase = document.createElement("canvas");
          minimapBase.width  = tilesW * minimapScale;
          minimapBase.height = tilesH * minimapScale;
          const ctx = minimapBase.getContext("2d");

          // Background (floors)
          ctx.fillStyle = MINIMAP_COLORS.floor;
          ctx.fillRect(0, 0, minimapBase.width, minimapBase.height);

          const ox = pad * minimapScale;
          const oy = pad * minimapScale;

          // Walls
          ctx.fillStyle = MINIMAP_COLORS.wall;
          for (let y = 0; y < mapState.height; y++) {
            for (let x = 0; x < mapState.width; x++) {
              if (mapState.grid[y][x] === TILE_WALL) {
                ctx.fillRect(ox + x * minimapScale, oy + y * minimapScale, minimapScale, minimapScale);
              }
            }
          }

          // Optional border to make the map bounds obvious
          ctx.strokeStyle = MINIMAP_COLORS.border;
          ctx.lineWidth = Math.max(1, Math.floor(minimapScale / 2));
          ctx.strokeRect(ox, oy, mapState.width * minimapScale, mapState.height * minimapScale);
        }

        /**
         * Draw dynamic overlay each time the minimap is shown or on demand:
         * - base layer (blit the offscreen)
         * - viewport rectangle
         * - player dot
         */
        function renderMinimapDynamic() {
            if (!minimapBase) buildMinimapBase();
            const ctx = minimapCtx;

            // Clear and blit base at 1:1 into the visible canvas, centered
            ctx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);

            // Compute draw position to center the base within canvas
            const dx = Math.floor((minimapCanvas.width  - minimapBase.width ) / 2);
            const dy = Math.floor((minimapCanvas.height - minimapBase.height) / 2);

            ctx.drawImage(minimapBase, dx, dy);
            
            // --- START: ACCURATE VIEWPORT CALCULATION (FIXED) ---
            // This logic mirrors the main `updateCamera` function to find the exact
            // top-left corner of the visible area in map coordinates.
            const mapPxW = mapState.width * CELL_SIZE;
            const mapPxH = mapState.height * CELL_SIZE;
            const vw = VIEW_W * CELL_SIZE;
            const vh = VIEW_H * CELL_SIZE;
            const playerPos = getPlayerPos();

            const desiredX = vw / 2 - (playerPos.x + 0.5) * CELL_SIZE;
            const desiredY = vh / 2 - (playerPos.y + 0.5) * CELL_SIZE;
            const canvasTranslateX = Math.round(Math.max(vw - mapPxW, Math.min(0, desiredX)));
            const canvasTranslateY = Math.round(Math.max(vh - mapPxH, Math.min(0, desiredY)));
            
            const rawViewportX = Math.round(-canvasTranslateX / CELL_SIZE);
            const rawViewportY = Math.round(-canvasTranslateY / CELL_SIZE);
            const maxViewportX = Math.max(0, mapState.width - VIEW_W);
            const maxViewportY = Math.max(0, mapState.height - VIEW_H);
            const viewportTopLeftX_map = Math.min(Math.max(0, rawViewportX), maxViewportX);
            const viewportTopLeftY_map = Math.min(Math.max(0, rawViewportY), maxViewportY);

            const viewportTilesWide = Math.min(VIEW_W, mapState.width);
            const viewportTilesHigh = Math.min(VIEW_H, mapState.height);

            // Overlay: viewport rectangle
            const pad = minimapPadding;
            const px0 = dx + (pad + viewportTopLeftX_map) * minimapScale;
            const py0 = dy + (pad + viewportTopLeftY_map) * minimapScale;
            // --- END: ACCURATE VIEWPORT CALCULATION ---

            const pw  = viewportTilesWide * minimapScale;
            const ph  = viewportTilesHigh * minimapScale;

            ctx.lineWidth = Math.max(1, Math.floor(minimapScale / 2));
            ctx.strokeStyle = MINIMAP_COLORS.viewport;
            ctx.strokeRect(px0, py0, pw, ph);

            // Overlay: player
            const p = getPlayerPos();
            const cx = dx + (pad + p.x + 0.5) * minimapScale;
            const cy = dy + (pad + p.y + 0.5) * minimapScale;
            const r  = Math.max(2, Math.floor(minimapScale / 1.5));

            ctx.fillStyle = MINIMAP_COLORS.player;
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();
        }

        // Optional: call this after each player move to keep an open minimap fresh
        function minimapMaybeRefreshOnTick() {
          if (isMinimapOpen()) renderMinimapDynamic();
        }

        // ===================== END MINIMAP =====================
        return {
            bootstrap,
            togglePause,
        };
        })();

        window.addEventListener('load', () => {
            Game.bootstrap();
        });
    </script>
</body>
</html>



