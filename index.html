<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Self-Playing Roguelike Dungeon Simulator</title>
    <style>
      body {
        font-family: monospace;
        background-color: #1a1a1a;
        color: #f0f0f0;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        margin: 0;
        padding: clamp(16px, 4vh, 40px) clamp(20px, 5vw, 80px);
        overflow: auto;
        box-sizing: border-box;
      }
      #app-container {
        display: flex;
        gap: clamp(16px, 3vw, 32px);
        align-items: stretch;
        justify-content: center;
        flex-wrap: wrap;
        width: min(1200px, 100%);
        margin: 0 auto;
        padding: clamp(12px, 2vw, 28px);
        box-sizing: border-box;
      }
      #container {
        text-align: center;
        background-color: #2b2b2b;
        padding: clamp(16px, 2.5vw, 28px);
        border-radius: 14px;
        box-shadow: 0 6px 24px rgba(0, 0, 0, 0.55);
        flex: 1 1 540px;
        max-width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        box-sizing: border-box;
      }
      h1 {
        margin-top: 0;
        color: #00bcd4;
      }
      #maze-viewport {
        overflow: hidden;
        position: relative;
        border: 2px solid #00bcd4;
        margin: 0 auto;
        border-radius: 12px;
        background-color: #111; /* Fallback for unexplored */
        transition:
          transform 0.25s ease-out,
          box-shadow 0.25s ease-out;
        box-shadow: 0 10px 28px rgba(0, 0, 0, 0.45);
      }
      #maze-canvas {
        position: absolute;
        top: 0;
        left: 0;
        will-change: transform;
        background-color: #111;
      }
      #status {
        font-size: clamp(16px, 1.8vw, 18px);
        color: #e0e0e0;
        min-height: 25px;
      }
      #controls {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 12px;
        color: #ccc;
        flex-wrap: wrap;
      }
      #speed-slider {
        width: clamp(140px, 16vw, 200px);
      }
      #pause-indicator {
        color: #ffeb3b;
        font-weight: bold;
        height: 20px;
        margin-top: 5px;
      }
      #restartBtn {
        margin-top: 5px;
        padding: 10px 20px;
        font-size: 16px;
        font-family: monospace;
        cursor: pointer;
        border: none;
        border-radius: 6px;
        background-color: #00bcd4;
        color: #1a1a1a;
        font-weight: bold;
        transition:
          background-color 0.2s,
          transform 0.2s;
      }
      #restartBtn:hover {
        background-color: #0097a7;
        transform: translateY(-1px);
      }
      /* UI Panel Styling */
      #ui-panel {
        width: min(320px, 100%);
        background-color: #2b2b2b;
        padding: clamp(16px, 2.4vw, 26px);
        border-radius: 14px;
        box-shadow: 0 6px 24px rgba(0, 0, 0, 0.55);
        flex: 1 1 280px;
        max-height: min(80vh, 720px);
        overflow: auto;
        box-sizing: border-box;
      }
      .ui-section h2 {
        color: #00bcd4;
        border-bottom: 1px solid #00bcd4;
        padding-bottom: 5px;
        margin-top: 0;
        margin-bottom: 10px;
      }
      .slot-container {
        display: grid;
        gap: clamp(8px, 1vw, 12px);
      }
      .equipment-slots {
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      }
      @media (max-width: 600px) {
        .equipment-slots {
          grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
        }
      }
      .inventory-slots {
        grid-template-columns: repeat(
          auto-fill,
          minmax(clamp(70px, 18vw, 110px), 1fr)
        );
        grid-auto-rows: minmax(60px, auto);
        grid-auto-flow: row;
      }
      .slot {
        min-height: 60px;
        background-color: #333;
        border: 1px solid #555;
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-size: clamp(12px, 1.3vw, 14px);
        padding: 6px;
        overflow: hidden;
        white-space: nowrap;
      }
      .slot-label {
        font-size: clamp(10px, 1vw, 11px);
        color: #aaa;
        width: 100%;
        text-align: left;
        margin-bottom: 4px;
      }
      .slot-item {
        font-weight: bold;
      }
      /* Minimap modal */
      #minimapModal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.65);
        display: none; /* toggled by JS */
        align-items: center;
        justify-content: center;
        z-index: 9999;
      }
      #minimapPanel {
        background: #222;
        border: 1px solid #00bcd4;
        border-radius: 10px;
        padding: 10px 10px 14px 10px;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6);
        max-width: 100vw;
        max-height: 100vh;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      #minimapHeader {
        display: flex;
        align-items: center;
        justify-content: space-between;
        color: #00bcd4;
        font-weight: bold;
        padding: 4px 2px 8px 2px;
      }
      #minimapClose {
        background: transparent;
        border: none;
        color: #ccc;
        font-size: 22px;
        cursor: pointer;
      }
      #minimapClose:hover {
        color: #fff;
      }

      #minimapCanvas {
        image-rendering: pixelated;
        width: min(94vw, 94vh); /* square that fits either width or height */
        height: min(94vw, 94vh);
        border: 1px solid #444;
        background: #111;
      }
      #minimapHint {
        color: #aaa;
        font-size: 12px;
        text-align: center;
      }

      @media (max-width: 1100px) {
        body {
          padding: clamp(16px, 6vh, 40px) clamp(16px, 5vw, 40px);
        }
        #app-container {
          flex-direction: column;
          align-items: center;
        }
        #container,
        #ui-panel {
          width: min(100%, 700px);
          max-width: 100%;
        }
        #ui-panel {
          max-height: none;
          order: 3;
        }
      }

      @media (max-width: 768px) {
        body {
          padding: 16px;
        }
        #container,
        #ui-panel {
          width: 100%;
        }
        #controls {
          justify-content: space-between;
        }
      }
    </style>
  </head>
  <body>
    <div id="app-container">
      <div id="container">
        <h1>Roguelike Dungeon Simulator</h1>
        <div id="maze-viewport">
          <canvas id="maze-canvas"></canvas>
        </div>
        <div id="status">Generating dungeon...</div>
        <div id="controls">
          <label for="speed-slider">Speed:</label>
          <input type="range" id="speed-slider" min="1" max="50" value="12" />
          <span id="speed-value">12 tps</span>
        </div>
        <div id="pause-indicator"></div>
        <button id="restartBtn" style="display: none">Restart</button>
      </div>
      <div id="ui-panel">
        <div class="ui-section">
          <h2>Equipment</h2>
          <div
            id="equipment-slots"
            class="slot-container equipment-slots"
          ></div>
        </div>
        <div class="ui-section" style="margin-top: 20px">
          <h2>Inventory</h2>
          <div
            id="inventory-slots"
            class="slot-container inventory-slots"
          ></div>
        </div>
      </div>
    </div>
    <!-- Minimap Modal -->
    <div id="minimapModal" aria-hidden="true">
      <div id="minimapPanel">
        <div id="minimapHeader">
          <span>Minimap</span>
          <button id="minimapClose" title="Close (Esc)">×</button>
        </div>
        <canvas id="minimapCanvas" width="640" height="640"></canvas>
        <div id="minimapHint">Press “m” to toggle, “Esc” to close</div>
      </div>
    </div>
    <script type="module">
      import {
        TILE_FLOOR,
        TILE_WALL,
        DEFAULT_LIGHT_RADIUS,
        DEFAULT_MOB_HP,
        DEFAULT_MOB_SPEED,
        DEFAULT_INVENTORY_CAPACITY,
        DEFAULT_MONSTER_AGGRO_RANGE,
        SHORT_TERM_MEMORY_PENALTY,
        MINIMAP_DEFAULT_DIMENSION,
        CARDINAL_DIRECTIONS,
        WEAPON_CATEGORY,
        ATTACK_KIND,
        THROW_CLASS,
        FOV_TRANSFORMS,
        DAMAGE_TYPE,
        STATUS_IDS,
        STACKING_RULE,
        SLOT,
        ALL_SLOTS_ORDER,
      } from "./js/constants.js";
      import {
        shuffle,
        posKey,
        posKeyFromCoords,
        randChoice,
        clamp,
        clamp01 as clamp01Normalized,
        colorStringToRgb,
        getNow,
        smoothstep01,
        chebyshevDistance,
        hasLineOfSight,
      } from "./js/utils.js";

      import {
        Item,
        ItemStack,
        makeItem,
        classifyThrowability,
        throwPenaltiesFor,
        buildEffectiveThrowProfile,
        getAttackModesForItem,
        getThrowProfileForItem,
      } from "./js/item-system.js";

      // Temporary alias so existing calls to clamp01(...) in this file keep working.
      // Remove this alias after migrating call sites to clamp01Normalized(...).
      const clamp01 = clamp01Normalized;
      const CONFIG = {
        visual: {
          view: { width: 41, height: 41 },
          cellSize: 20,
          minCellSize: 12,
          colors: {
            unseen: "#111",
            wall: "#3a2a23",
            floor: "#222",
            floorGlyph: "#444",
            defaultText: "#d3d3d3",
            start: "#4caf50",
            end: "#f44336",
            player: "#2196f3",
            playerGlyph: "#fff",
            visibleOverlay: "rgba(255,255,102,0.20)",
          },
          light: {
            fallbackColor: "#ffe9a6",
            fallbackFlickerRate: 0,
            baseOverlayAlpha: 0.2,
            flickerVariance: 0.12,
          },
        },
        ai: {
          ticksPerSecond: 12,
          shortTermMemory: 60,
          maxIdleTicks: 240,
          fallback: {
            unknownTileCost: 6,
            memoryRetainFraction: 0.4,
            randomWalk: {
              steps: 6,
              maxAttempts: 4,
            },
          },
        },
        generator: {
          hybrid: {
            large: {
              roomCountRange: [1, 11],
              areaRange: [300, 750],
              minSide: 8,
              minL1EdgeSpacing: 30,
              border: 15,
              maxAttemptsPerRoom: 600,
            },
            small: {
              candidateCount: 320,
              minSize: { w: 5, h: 5 },
              maxSize: { w: 14, h: 12 },
              separationIters: 80,
              keepRatio: 1.0,
              clearanceFromLarge: 2,
            },
            corridors: {
              extraEdgeFraction: 0.15,
              rescueConnectivity: true,
            },
          },
        },
        minimap: {
          padding: 1,
          colors: {
            wall: "#3a2a23",
            floor: "#111",
            floorExplored: "#1a1a1a",
            player: "#2196f3",
            viewport: "#00bcd4",
            border: "#333",
          },
        },
        general: {
          maxInitRetries: 10,
        },
      };

      function createEmptyDamageTypeMap() {
        return Object.create(null);
      }

      function createEmptyStatusDerivedMods() {
        return {
          moveAPDelta: 0,
          actionSpeedPct: 0,
          accuracyFlat: 0,
          critChancePct: 0,
          canAct: true,
          damageDealtMult: createEmptyDamageTypeMap(),
          damageTakenMult: createEmptyDamageTypeMap(),
          resistDelta: createEmptyDamageTypeMap(),
        };
      }

      function createDefaultStatusModCache() {
        return {
          inflictBonus: Object.create(null),
          inflictDurMult: Object.create(null),
          recvDurMult: Object.create(null),
          resistBonus: Object.create(null),
          freeAction: {
            ignore: new Set(),
          },
        };
      }

      function createDefaultModCache() {
        return {
          status: createDefaultStatusModCache(),
          offense: {
            affinities: Object.create(null),
            brandAdds: [],
            conversions: [],
            polarity: { onHitBias: { baseMult: 0, vs: Object.create(null) } },
          },
          defense: {
            resists: Object.create(null),
            immunities: new Set(),
          },
          polarity: {
            grant: {
              order: 0,
              growth: 0,
              chaos: 0,
              decay: 0,
              void: 0,
            },
            defenseBias: {
              baseResistPct: 0,
              vs: Object.create(null),
            },
          },
        };
      }

      const StatusRegistry = new Map();

      function registerStatus(def) {
        if (!def || !def.id) {
          throw new Error("registerStatus requires an id");
        }
        StatusRegistry.set(def.id, def);
      }

      function getStatus(id) {
        if (!StatusRegistry.has(id)) {
          throw new Error(`Unknown status definition: ${id}`);
        }
        return StatusRegistry.get(id);
      }

      function rebuildStatusDerivedCache(actor) {
        if (!actor) return;
        const agg = createEmptyStatusDerivedMods();
        const statuses = Array.isArray(actor.statuses) ? actor.statuses : [];
        for (const st of statuses) {
          const def = StatusRegistry.get(st.id);
          if (!def || typeof def.derive !== "function") continue;
          const derived = def.derive({
            target: actor,
            stacks: st.stacks ?? 1,
            potency: st.potency,
          });
          if (!derived) continue;
          if (typeof derived.canAct === "boolean") {
            agg.canAct = agg.canAct && derived.canAct;
          }
          if (typeof derived.moveAPDelta === "number") {
            agg.moveAPDelta += derived.moveAPDelta;
          }
          if (typeof derived.actionSpeedPct === "number") {
            agg.actionSpeedPct += derived.actionSpeedPct;
          }
          if (typeof derived.accuracyFlat === "number") {
            agg.accuracyFlat += derived.accuracyFlat;
          }
          if (typeof derived.critChancePct === "number") {
            agg.critChancePct += derived.critChancePct;
          }
          if (derived.damageDealtMult) {
            for (const [k, v] of Object.entries(derived.damageDealtMult)) {
              if (typeof v !== "number") continue;
              agg.damageDealtMult[k] = (agg.damageDealtMult[k] ?? 0) + v;
            }
          }
          if (derived.damageTakenMult) {
            for (const [k, v] of Object.entries(derived.damageTakenMult)) {
              if (typeof v !== "number") continue;
              agg.damageTakenMult[k] = (agg.damageTakenMult[k] ?? 0) + v;
            }
          }
          if (derived.resistDelta) {
            for (const [k, v] of Object.entries(derived.resistDelta)) {
              if (typeof v !== "number") continue;
              agg.resistDelta[k] = (agg.resistDelta[k] ?? 0) + v;
            }
          }
        }
        actor.statusDerived = agg;
      }

      function computeActorDelay(actor) {
        if (!actor) return 1;
        const base = typeof actor.baseDelay === "number" ? actor.baseDelay : 1;
        const pct = actor.statusDerived?.actionSpeedPct ?? 0;
        const delay = base * (1 + pct);
        return delay > 0 ? delay : 0.1;
      }

      function handleDeath(gameCtx, actor, ui = null) {
        if (!actor || actor.hp > 0) return false;
        if (actor.__dead) return true;
        actor.__dead = true;

        const manager = gameCtx?.mobManager;
        if (actor.kind !== "player" && manager?.removeById) {
          manager.removeById(actor.id);
        }

        if (actor.kind === "player" && ui) {
          clearTimeout(ui.simState?.timeout);
          if (ui.simState) {
            ui.simState.timeout = null;
            ui.simState.loopFn = null;
            ui.simState.isPaused = true;
          }
          if (ui.statusDiv) {
            ui.statusDiv.textContent = "You died";
          }
          if (ui.restartBtn) {
            ui.restartBtn.style.display = "block";
          }
        }

        return true;
      }

      function tickStatusesAtTurnStart(actor, turn, gameCtx = null) {
        if (!actor) return;
        if (!Array.isArray(actor.statuses)) {
          actor.statuses = [];
        }
        const expired = [];
        for (const st of actor.statuses) {
          const def = StatusRegistry.get(st.id);
          if (!def) continue;
          if (def.tickEvery && st.nextTickAt != null) {
            while (turn >= st.nextTickAt) {
              def.onTick?.({
                target: actor,
                source: st.source,
                stacks: st.stacks ?? 1,
                potency: st.potency,
                turn: st.nextTickAt,
              });
              actor.__log?.statusTick?.(st.id, {
                turn: st.nextTickAt,
                stacks: st.stacks ?? 1,
                potency: st.potency,
              });
              st.nextTickAt += def.tickEvery;
              if (gameCtx && handleDeath(gameCtx, actor, gameCtx.ui)) {
                return;
              }
            }
          }
          if (turn >= st.endsAtTurn) {
            def.onExpire?.({
              target: actor,
              source: st.source,
              stacks: st.stacks ?? 1,
              potency: st.potency,
              turn,
            });
            actor.__log?.statusExpire?.(st.id, {
              turn,
              stacks: st.stacks ?? 1,
              potency: st.potency,
            });
            expired.push(st);
          }
        }
        if (expired.length) {
          actor.statuses = actor.statuses.filter((s) => !expired.includes(s));
        }
        if (gameCtx && actor.__dead) {
          return;
        }
        rebuildStatusDerivedCache(actor);
      }

      function applyStatuses(ctx, S, D, turn) {
        if (!D) return [];
        if (!Array.isArray(D.statuses)) {
          D.statuses = [];
        }
        if (!D.modCache) {
          D.modCache = createDefaultModCache();
        }
        if (!S.modCache) {
          S.modCache = createDefaultModCache();
        }
        if (!D.modCache.status) {
          D.modCache.status = createDefaultStatusModCache();
        }
        if (!S.modCache.status) {
          S.modCache.status = createDefaultStatusModCache();
        }
        const applied = [];
        const attempts = ctx?.statusAttempts ?? [];
        const defenderStatusMods =
          D.modCache.status ?? createDefaultStatusModCache();

        const getModNumber = (container, key, fallback = 0) => {
          if (!container || typeof container !== "object") return fallback;
          const value = container[key];
          return typeof value === "number" ? value : fallback;
        };

        for (const a of attempts) {
          const def = StatusRegistry.get(a.id);
          if (!def) continue;

          let p = a.baseChance ?? 0;
          const attackerMods =
            S.modCache.status ?? createDefaultStatusModCache();
          p += getModNumber(attackerMods.inflictBonus, a.id);
          p -= getModNumber(defenderStatusMods.resistBonus, a.id);
          p = Math.max(0, Math.min(1, p));
          if (p <= 0) continue;

          if (
            defenderStatusMods.freeAction?.ignore instanceof Set &&
            defenderStatusMods.freeAction.ignore.has(a.id)
          ) {
            continue;
          }

          if (Math.random() >= p) continue;

          const attackerDurMult = getModNumber(
            attackerMods.inflictDurMult,
            a.id,
            1,
          );
          const defenderDurMult = getModNumber(
            defenderStatusMods.recvDurMult,
            a.id,
            1,
          );
          const baseDur = Math.max(
            1,
            Math.ceil(
              (a.baseDuration ?? 1) * attackerDurMult * defenderDurMult,
            ),
          );

          if (def.stacking === STACKING_RULE.INDEPENDENT) {
            const inst = {
              id: a.id,
              stacks: 1,
              potency: undefined,
              nextTickAt: def.tickEvery ? turn + def.tickEvery : undefined,
              endsAtTurn: turn + baseDur,
              source: S?.id,
            };
            const appliedData = def.onApply?.({
              target: D,
              source: S,
              stacks: 1,
              turn,
            });
            if (appliedData && appliedData.potency !== undefined) {
              inst.potency = appliedData.potency;
            }
            D.statuses.push(inst);
            applied.push(inst);
            D.__log?.statusApply?.(a.id, {
              chance: p,
              baseChance: a.baseChance ?? 0,
              duration: baseDur,
            });
          } else {
            let ex = D.statuses.find((s) => s.id === a.id);
            if (!ex) {
              const stacks = a.stacks ?? 1;
              ex = {
                id: a.id,
                stacks,
                potency: undefined,
                nextTickAt: def.tickEvery ? turn + def.tickEvery : undefined,
                endsAtTurn: turn + baseDur,
                source: S?.id,
              };
              const appliedData = def.onApply?.({
                target: D,
                source: S,
                stacks,
                turn,
              });
              if (appliedData && appliedData.potency !== undefined) {
                ex.potency = appliedData.potency;
              }
              D.statuses.push(ex);
              applied.push(ex);
              D.__log?.statusApply?.(a.id, {
                chance: p,
                baseChance: a.baseChance ?? 0,
                duration: baseDur,
                stacks,
              });
            } else {
              if (def.stacking === STACKING_RULE.REFRESH) {
                ex.endsAtTurn = Math.max(ex.endsAtTurn, turn + baseDur);
              } else if (def.stacking === STACKING_RULE.ADD_STACKS) {
                const addStacks = a.stacks ?? 1;
                const maxStacks = def.maxStacks ?? 999;
                ex.stacks = Math.min((ex.stacks ?? 1) + addStacks, maxStacks);
                ex.endsAtTurn = Math.max(ex.endsAtTurn, turn + baseDur);
              }
              D.__log?.statusApply?.(a.id, {
                chance: p,
                baseChance: a.baseChance ?? 0,
                duration: baseDur,
                stacks: ex.stacks,
              });
            }
          }
        }

        if (applied.length) {
          rebuildStatusDerivedCache(D);
        }
        return applied;
      }

      function resolveAttack(ctx) {
        const S = ctx.attacker ?? ctx.S;
        const D = ctx.defender ?? ctx.D;
        const turn = ctx.turn | 0;

        const packetsBeforeDefense = Object.create(null);
        const addPacket = (type, amount) => {
          if (!type) return;
          const value = Math.floor(amount ?? 0);
          if (!Number.isFinite(value) || value <= 0) return;
          packetsBeforeDefense[type] =
            (packetsBeforeDefense[type] || 0) + value;
        };

        const basePhysicalDescriptor = ctx.basePhysical;
        let basePhysicalPool = 0;
        let bonusPhysicalPool = Math.max(0, Math.floor(ctx.bonusPhysical ?? 0));

        if (typeof basePhysicalDescriptor === "number") {
          basePhysicalPool = Math.max(0, Math.floor(basePhysicalDescriptor));
        } else if (basePhysicalDescriptor && typeof basePhysicalDescriptor === "object") {
          for (const [key, raw] of Object.entries(basePhysicalDescriptor)) {
            const n = Math.floor(Number(raw ?? 0));
            if (!Number.isFinite(n) || n <= 0) continue;
            if (key === "flatFromStats") {
              bonusPhysicalPool += n;
            } else {
              basePhysicalPool += n;
            }
          }
        }

        const gather = (value) =>
          Array.isArray(value)
            ? value
            : value && typeof value === "object"
            ? [value]
            : [];

        const conversions = [
          ...gather(ctx.conversions),
          ...gather(S?.modCache?.offense?.conversions),
        ];
        const brands = [
          ...gather(ctx.brands),
          ...gather(S?.modCache?.offense?.brandAdds),
        ];

        for (const conv of conversions) {
          if (!conv) continue;
          const pct = Number(conv.pct ?? conv.percent ?? 0);
          if (!Number.isFinite(pct) || pct <= 0) continue;
          const toType = conv.to || conv.type;
          if (!toType) continue;
          let pool = basePhysicalPool;
          if (!conv.includeBaseOnly) {
            pool += bonusPhysicalPool;
          }
          if (pool <= 0) continue;
          let delta = Math.floor(pool * pct);
          if (!Number.isFinite(delta) || delta <= 0) continue;
          const baseShare = Math.min(delta, basePhysicalPool);
          basePhysicalPool -= baseShare;
          const bonusShare = delta - baseShare;
          if (!conv.includeBaseOnly && bonusShare > 0) {
            bonusPhysicalPool = Math.max(0, bonusPhysicalPool - bonusShare);
          }
          addPacket(toType, delta);
        }

        const remainingPhysical = basePhysicalPool + bonusPhysicalPool;
        if (remainingPhysical > 0) {
          addPacket("physical", remainingPhysical);
        }

        for (const brand of brands) {
          if (!brand) continue;
          const flat = Math.floor(Number(brand.flat ?? 0));
          if (!Number.isFinite(flat) || flat <= 0) continue;
          addPacket(brand.type || brand.damageType || "physical", flat);
        }

        const mulTyped = (packetMap, getMult) => {
          for (const type in packetMap) {
            const mult = getMult(type);
            if (mult) {
              const next = Math.max(
                0,
                Math.floor(packetMap[type] * (1 + mult)),
              );
              packetMap[type] = next;
            }
          }
        };

        mulTyped(
          packetsBeforeDefense,
          (t) => S?.modCache?.offense?.affinities?.[t] || 0,
        );

        const onHitBias =
          S?.modCache?.polarity?.onHitBias?.baseMult ??
          S?.modCache?.offense?.polarity?.onHitBias?.baseMult ??
          0;
        if (onHitBias) {
          for (const type in packetsBeforeDefense) {
            packetsBeforeDefense[type] = Math.floor(
              packetsBeforeDefense[type] * (1 + onHitBias),
            );
          }
        }

        mulTyped(
          packetsBeforeDefense,
          (t) => S?.statusDerived?.damageDealtMult?.[t] || 0,
        );
        mulTyped(
          packetsBeforeDefense,
          (t) => D?.statusDerived?.damageTakenMult?.[t] || 0,
        );

        const packetsAfterDefense = Object.create(null);
        for (const type in packetsBeforeDefense) {
          if (D?.modCache?.defense?.immunities?.has?.(type)) {
            continue;
          }
          const baseRes =
            (D?.modCache?.defense?.resists?.[type] || 0) +
            (D?.statusDerived?.resistDelta?.[type] || 0);
          const clampedRes = Math.max(-1, Math.min(0.95, baseRes));
          packetsAfterDefense[type] = Math.max(
            0,
            Math.floor(packetsBeforeDefense[type] * (1 - clampedRes)),
          );
        }

        const totalDamage = Object.values(packetsAfterDefense).reduce(
          (acc, value) => acc + value,
          0,
        );

        let statusApplied = [];
        if (ctx.statusAttempts?.length) {
          statusApplied = applyStatuses(
            { statusAttempts: ctx.statusAttempts },
            S,
            D,
            turn,
          );
        }

        return {
          packetsBeforeDefense,
          packetsAfterDefense,
          totalDamage,
          statusApplied,
        };
      }

      class RingBuffer {
        constructor(capacity = 64) {
          this.capacity = capacity;
          this.buffer = [];
        }
        push(value) {
          if (this.buffer.length >= this.capacity) {
            this.buffer.shift();
          }
          this.buffer.push(value);
        }
        toArray() {
          return this.buffer.slice();
        }
      }

      function attachDebug(mob) {
        if (!mob || mob.__log) return;
        const rb = new RingBuffer(128);
        mob.__log = {
          push: (event) => rb.push(event),
          attackStep: (step, data) =>
            rb.push({ kind: "attack_step", step, data }),
          statusApply: (id, data) =>
            rb.push({ kind: "status_apply", id, data }),
          statusTick: (id, data) => rb.push({ kind: "status_tick", id, data }),
          statusExpire: (id, data) =>
            rb.push({ kind: "status_expire", id, data }),
          dump: () => rb.toArray(),
        };
      }

      window.attachDebug = attachDebug;
      window.StatusRegistry = StatusRegistry;
      window.getStatus = getStatus;
      window.applyStatuses = applyStatuses;
      window.resolveAttack = resolveAttack;

      registerStatus({
        id: "burn",
        label: "Burning",
        harmful: true,
        stacking: STACKING_RULE.ADD_STACKS,
        maxStacks: 5,
        tickEvery: 1,
        onTick: ({ target, stacks = 1 }) => {
          const dot = 1 + stacks;
          if (typeof target.hp === "number") {
            target.hp -= dot;
          }
          target.__log?.statusTick?.("burn", { dot, stacks });
        },
        derive: ({ stacks = 1 }) => ({
          damageTakenMult: { cold: -0.1, fire: 0.25 },
        }),
      });

      registerStatus({
        id: "poisoned",
        label: "Poisoned",
        harmful: true,
        stacking: STACKING_RULE.INDEPENDENT,
        tickEvery: 1,
        onTick: ({ target, potency = 1 }) => {
          const dot = Math.ceil(1.5 * potency);
          if (typeof target.hp === "number") {
            target.hp -= dot;
          }
          target.__log?.statusTick?.("poisoned", { dot, potency });
        },
        onApply: () => ({ potency: 1 }),
      });

      registerStatus({
        id: "slowed",
        label: "Slowed",
        harmful: true,
        stacking: STACKING_RULE.REFRESH,
        derive: ({ stacks = 1 }) => ({
          actionSpeedPct: 0.1 * stacks,
          moveAPDelta: 0.1,
        }),
      });

      registerStatus({
        id: "stunned",
        label: "Stunned",
        harmful: true,
        stacking: STACKING_RULE.REFRESH,
        derive: () => ({ canAct: false }),
      });

      registerStatus({
        id: "haste",
        label: "Haste",
        harmful: false,
        stacking: STACKING_RULE.REFRESH,
        derive: ({ stacks = 1 }) => ({ actionSpeedPct: 0.15 * stacks }),
      });

      const Game = (() => {
        const viewportEl = document.getElementById("maze-viewport");
        const canvas = document.getElementById("maze-canvas");
        const ctx = canvas.getContext("2d");
        const statusDiv = document.getElementById("status");
        const restartBtn = document.getElementById("restartBtn");
        const equipmentSlotsDiv = document.getElementById("equipment-slots");
        const inventorySlotsDiv = document.getElementById("inventory-slots");
        const speedSlider = document.getElementById("speed-slider");
        const speedValue = document.getElementById("speed-value");
        const pauseIndicator = document.getElementById("pause-indicator");
        const containerEl = document.getElementById("container");

        let minimapModalEl, minimapCanvas, minimapCtx, minimapCloseBtn;

        const simState = {
          timeout: null,
          loopFn: null,
          isPaused: false,
          speed: CONFIG.ai.ticksPerSecond,
          isReady: false,
          turnCounter: 0,
        };

        const uiHooks = { simState, statusDiv, restartBtn };

        const mapState = {
          width: 0,
          height: 0,
          grid: [],
          explored: [],
          known: [],
        };

        const fovState = {
          currentVisible: new Set(),
          prevVisible: new Set(),
          lastCache: { key: null, radius: null, visible: null },
          overlayStyle: CONFIG.visual.colors.visibleOverlay,
          overlayRgb: null,
        };

        const explorationState = {
          frontiers: new Set(),
          newlyExplored: [],
        };

        let player = {};
        let mobManager = null;
        let isEndRendered = false;
        const INVALID_POSITION_COORD = -1;
        let prevPlayerPos = {
          x: INVALID_POSITION_COORD,
          y: INVALID_POSITION_COORD,
        };
        let hasPrevPlayerPos = false;
        let currentEndPos = null;
        let initRetries = 0;

        const rawLightConfig = CONFIG.visual.light || {};
        const LIGHT_CONFIG = {
          fallbackColor: rawLightConfig.fallbackColor || "#ffe9a6",
          fallbackFlickerRate:
            typeof rawLightConfig.fallbackFlickerRate === "number"
              ? rawLightConfig.fallbackFlickerRate
              : 0,
          baseOverlayAlpha:
            typeof rawLightConfig.baseOverlayAlpha === "number"
              ? rawLightConfig.baseOverlayAlpha
              : 0.2,
          flickerVariance:
            typeof rawLightConfig.flickerVariance === "number"
              ? rawLightConfig.flickerVariance
              : 0.12,
          flickerNearDeadZoneTiles:
            typeof rawLightConfig.flickerNearDeadZoneTiles === "number"
              ? rawLightConfig.flickerNearDeadZoneTiles
              : 1,
          flickerFalloffPower:
            typeof rawLightConfig.flickerFalloffPower === "number"
              ? rawLightConfig.flickerFalloffPower
              : 1.75,
        };

        const VIEW_W = CONFIG.visual.view.width;
        const VIEW_H = CONFIG.visual.view.height;
        const MIN_CELL_SIZE = CONFIG.visual.minCellSize;
        let CELL_SIZE = CONFIG.visual.cellSize;
        let HALF_CELL = CELL_SIZE / 2;
        const MAX_INIT_RETRIES = CONFIG.general.maxInitRetries;

        // ===================== EQUIPMENT MODEL =====================

        // ---- Slot enum (canonical names)
        const SLOT = {
          Head: "Head",
          LeftHand: "LeftHand",
          RightHand: "RightHand",
          LeftRing: "LeftRing",
          RightRing: "RightRing",
          Amulet: "Amulet",
          BodyArmor: "BodyArmor",
          Cloak: "Cloak",
          Boots: "Boots",
          Gloves: "Gloves",
          Belt: "Belt", // the belt garment itself
          Belt1: "Belt1", // attachments on belt
          Belt2: "Belt2",
          Belt3: "Belt3",
          Belt4: "Belt4",
          Backpack: "Backpack",
          Quiver: "Quiver",
        };

        // Legacy aliases so existing UI keeps showing something
        const LEGACY_SLOT_ALIAS = new Map([
          ["Left", SLOT.LeftHand],
          ["Right", SLOT.RightHand],
          ["Body", SLOT.BodyArmor],
        ]);

        // Order for rendering later
        const ALL_SLOTS_ORDER = [
          SLOT.Head,
          SLOT.Amulet,
          SLOT.LeftRing,
          SLOT.RightRing,
          SLOT.Cloak,
          SLOT.BodyArmor,
          SLOT.Gloves,
          SLOT.Boots,
          SLOT.LeftHand,
          SLOT.RightHand,
          SLOT.Belt,
          SLOT.Belt1,
          SLOT.Belt2,
          SLOT.Belt3,
          SLOT.Belt4,
          SLOT.Backpack,
          SLOT.Quiver,
        ];

        const SLOT_LABELS = {
          [SLOT.Head]: "Head",
          [SLOT.Amulet]: "Amulet",
          [SLOT.LeftRing]: "Left Ring",
          [SLOT.RightRing]: "Right Ring",
          [SLOT.Cloak]: "Cloak",
          [SLOT.BodyArmor]: "Body",
          [SLOT.Gloves]: "Gloves",
          [SLOT.Boots]: "Boots",
          [SLOT.LeftHand]: "Left Hand",
          [SLOT.RightHand]: "Right Hand",
          [SLOT.Belt]: "Belt",
          [SLOT.Belt1]: "Belt Slot 1",
          [SLOT.Belt2]: "Belt Slot 2",
          [SLOT.Belt3]: "Belt Slot 3",
          [SLOT.Belt4]: "Belt Slot 4",
          [SLOT.Backpack]: "Backpack",
          [SLOT.Quiver]: "Quiver",
        };

        function labelForSlot(slot) {
          if (SLOT_LABELS[slot]) return SLOT_LABELS[slot];
          return slot
            .replace(/([a-z])([A-Z])/g, "$1 $2")
            .replace(/\b(\w)/g, (_, c) => c.toUpperCase());
        }

        // ---- Inventory ----
        // This represents the carried inventory. Capacity is enforced by the equipped Backpack.

        class Inventory {
          constructor(slotCount = 20) {
            this.capacitySlots = slotCount; // UI slots; you can raise this later
            this.stacks = Array.from({ length: slotCount }, () => null);
            this.constraints = null; // set from equipped backpack
          }
          setConstraints(c) {
            this.constraints = c ? { ...c } : null;
          }
          list() {
            return this.stacks;
          }

          usedMassKg() {
            let m = 0;
            for (const s of this.stacks) if (s) m += s.totalMassKg();
            return m;
          }
          usedVolumeL() {
            let v = 0;
            for (const s of this.stacks) if (s) v += s.totalVolumeL();
            return v;
          }
          longestItemCm() {
            let L = 0;
            for (const s of this.stacks)
              if (s) L = Math.max(L, s.item.longestCm());
            return L;
          }

          // capacity check vs backpack constraints
          fitsConstraints(stack) {
            if (!this.constraints) return true; // no backpack equipped => unrestricted (you may change this)
            const cap = this.constraints;
            const massAfter = this.usedMassKg() + stack.totalMassKg();
            const volAfter = this.usedVolumeL() + stack.totalVolumeL();
            const longest = Math.max(
              this.longestItemCm(),
              stack.item.longestCm(),
            );
            if (massAfter > cap.maxMassKg) return false;
            if (volAfter > cap.volumeL) return false;
            if (longest > cap.maxItemLengthCm) return false;
            if (typeof cap.accepts === "function" && !cap.accepts(stack.item))
              return false;
            return true;
          }

          add(itemOrStack) {
            const incoming =
              itemOrStack instanceof ItemStack
                ? itemOrStack
                : new ItemStack(itemOrStack, 1);
            const merges = [];
            const newSlots = [];
            let mergedTotalQty = 0;
            let placedTotalQty = 0;
            const rollback = () => {
              for (const { index, added } of merges) {
                const stack = this.stacks[index];
                if (stack) {
                  stack.qty -= added;
                  if (stack.qty === 0) this.stacks[index] = null;
                }
              }
              for (const { index } of newSlots) {
                this.stacks[index] = null;
              }
              incoming.qty += mergedTotalQty + placedTotalQty;
              merges.length = 0;
              newSlots.length = 0;
              mergedTotalQty = 0;
              placedTotalQty = 0;
            };
            // Try merge first
            if (incoming.stackable) {
              for (let i = 0; i < this.stacks.length && incoming.qty > 0; i++) {
                const s = this.stacks[i];
                if (s && s.canMerge(incoming) && s.qty < s.maxStack) {
                  const space = s.maxStack - s.qty;
                  const moved = Math.min(space, incoming.qty);
                  const tmp = new ItemStack(incoming.item.clone(), moved);
                  if (!this.fitsConstraints(tmp)) {
                    rollback();
                    return false;
                  }
                  s.qty += moved;
                  merges.push({ index: i, added: moved });
                  mergedTotalQty += moved;
                  incoming.qty -= moved;
                }
              }
              if (incoming.qty <= 0) return true;
            }
            // Place into free slots, respecting stack limits
            for (let i = 0; i < this.stacks.length && incoming.qty > 0; i++) {
              if (!this.stacks[i]) {
                const maxPerSlot =
                  typeof incoming.maxStack === "number" && incoming.maxStack > 0
                    ? incoming.maxStack
                    : 1;
                const qtyToStore = Math.min(incoming.qty, maxPerSlot);
                if (qtyToStore <= 0) {
                  rollback();
                  return false;
                }
                const tmp = new ItemStack(incoming.item.clone(), qtyToStore);
                if (!this.fitsConstraints(tmp)) {
                  rollback();
                  return false;
                }
                this.stacks[i] = tmp;
                newSlots.push({ index: i });
                placedTotalQty += qtyToStore;
                incoming.qty -= qtyToStore;
              }
            }
            if (incoming.qty <= 0) return true;
            rollback();
            return false;
          }

          removeByIndex(idx, qty = Infinity) {
            const s = this.stacks[idx];
            if (!s) return null;
            const take = Math.min(qty, s.qty);
            s.qty -= take;
            if (s.qty <= 0) this.stacks[idx] = null;
            return new ItemStack(s.item.clone(), take);
          }
          findStack(predicate) {
            if (typeof predicate !== "function") return null;
            for (let i = 0; i < this.stacks.length; i++) {
              const stack = this.stacks[i];
              if (stack && predicate(stack, i)) {
                return { index: i, stack };
              }
            }
            return null;
          }
          consumeAt(index, qty = 1) {
            if (index < 0 || index >= this.stacks.length) return false;
            const stack = this.stacks[index];
            if (!stack) return false;
            if (qty <= 0) return true;
            if (stack.qty < qty) return false;
            stack.qty -= qty;
            if (stack.qty === 0) this.stacks[index] = null;
            return true;
          }
          consumeMatching(predicate, qty = 1) {
            const found = this.findStack(predicate);
            if (!found) return false;
            return this.consumeAt(found.index, qty);
          }
        }

        // ---- Equipment ----
        // Enforces slot compatibility and 2H weapon occupancy.

        class Equipment {
          constructor() {
            this.slots = new Map();
            for (const s of ALL_SLOTS_ORDER) this.slots.set(s, null);
            // Derived occupancy marker for two-handed
            this._twoHandOccupantId = null;
          }

          get(slot) {
            return this.slots.get(slot) || null;
          }
          all() {
            return Array.from(this.slots.entries());
          }

          // For legacy UI; maps to the 5 old labels
          asLegacyRecord() {
            return {
              Head: this.get(SLOT.Head),
              Body: this.get(SLOT.BodyArmor),
              Left: this.get(SLOT.LeftHand),
              Right: this.get(SLOT.RightHand),
              Belt: this.get(SLOT.Belt),
            };
          }

          canEquipTo(slot, item) {
            if (!(item instanceof Item)) return false;
            if (!this.slots.has(slot)) return false;
            if (!item.canEquipTo(slot)) return false;
            const isHandSlot =
              slot === SLOT.LeftHand || slot === SLOT.RightHand;
            if (!isHandSlot) return true;

            const left = this.get(SLOT.LeftHand);
            const right = this.get(SLOT.RightHand);
            const hasTwoHandEquipped =
              (left && left.handsRequired === 2 && left !== item) ||
              (right && right.handsRequired === 2 && right !== item);

            if (item.handsRequired === 2) {
              const other =
                slot === SLOT.LeftHand ? SLOT.RightHand : SLOT.LeftHand;
              if (
                (this.get(slot) && this.get(slot) !== item) ||
                (this.get(other) && this.get(other) !== item)
              ) {
                return false;
              }
              if (
                (left && left !== item) ||
                (right && right !== item)
              ) {
                return false;
              }
            } else if (hasTwoHandEquipped) {
              return false;
            }
            return true;
          }

          equipTo(slot, item) {
            if (!this.canEquipTo(slot, item)) return false;
            const isHandSlot =
              slot === SLOT.LeftHand || slot === SLOT.RightHand;

            if (isHandSlot && item.handsRequired === 2) {
              this.slots.set(SLOT.LeftHand, item);
              this.slots.set(SLOT.RightHand, item);
              this._twoHandOccupantId = item.id;
              return true;
            }

            if (isHandSlot && this._twoHandOccupantId) {
              // Unequip the two-handed item before equipping the one-handed item
              this.unequip(SLOT.LeftHand);
            }

            this.slots.set(slot, item);
            if (isHandSlot) {
              this._twoHandOccupantId = null;
            }
            return true;
          }

          unequip(slot) {
            const it = this.get(slot);
            // If removing a 2H item from either hand, clear both
            if (
              it &&
              (slot === SLOT.LeftHand || slot === SLOT.RightHand) &&
              it.handsRequired === 2
            ) {
              this.slots.set(SLOT.LeftHand, null);
              this.slots.set(SLOT.RightHand, null);
              this._twoHandOccupantId = null;
              return it;
            }
            this.slots.set(slot, null);
            return it;
          }
          removeItemInstance(item) {
            if (!item) return false;
            for (const [slot, equipped] of this.slots.entries()) {
              if (equipped === item) {
                this.unequip(slot);
                return true;
              }
            }
            return false;
          }

          getLightSourceProperties(defaults = null) {
            const fallback = defaults
              ? { ...defaults }
              : {
                  radius: DEFAULT_LIGHT_RADIUS,
                  color: LIGHT_CONFIG.fallbackColor,
                  flickerRate: LIGHT_CONFIG.fallbackFlickerRate,
                };
            let best = { ...fallback };
            let usingFallback = true;
            for (const [, it] of this.slots) {
              if (!it || !it.lightRadius) continue;
              const candidate = {
                radius: it.lightRadius,
                color: it.lightColor || fallback.color,
                flickerRate:
                  typeof it.flickerRate === "number"
                    ? it.flickerRate
                    : fallback.flickerRate,
              };
              if (
                candidate.radius > best.radius ||
                (usingFallback && candidate.radius === best.radius)
              ) {
                best = candidate;
                usingFallback = false;
              }
            }
            return best;
          }

          getLightRadius() {
            return this.getLightSourceProperties().radius;
          }

          getLightColor() {
            return this.getLightSourceProperties().color;
          }

          getLightFlickerRate() {
            return this.getLightSourceProperties().flickerRate;
          }

          currentBackpackConstraints() {
            const pack = this.get(SLOT.Backpack);
            return pack && pack.container
              ? {
                  volumeL: pack.container.volumeL,
                  maxMassKg: pack.container.maxMassKg,
                  maxItemLengthCm: pack.container.maxItemLengthCm,
                  accepts: pack.container.accepts || null,
                }
              : null;
          }
        }

        // ---- Mobs ----

        let __mobAutoId = 1;

        class Mob {
          constructor(o) {
            this.id = __mobAutoId++;
            this.kind = o.kind;
            this.name = o.name;
            this.x = o.x | 0;
            this.y = o.y | 0;
            this.hp = o.hp ?? DEFAULT_MOB_HP;
            this.maxHp = this.hp;
            this.speed = o.speed ?? DEFAULT_MOB_SPEED;
            this.baseDelay = o.baseDelay ?? 1;
            this.nextActAt = o.nextActAt ?? 0;
            this.glyph = o.glyph ?? "?";
            this.color = o.color ?? "#fff";
            this.equipment = new Equipment();
            this.inventory = new Inventory(DEFAULT_INVENTORY_CAPACITY);
            this.statuses = [];
            this.statusDerived = createEmptyStatusDerivedMods();
            this.modCache = createDefaultModCache();
            this.__log = null;
          }
          get pos() {
            return { x: this.x, y: this.y };
          }
          set pos(p) {
            this.x = p.x | 0;
            this.y = p.y | 0;
          }
          lightRadius() {
            return this.equipment.getLightRadius();
          }

          canOccupy(x, y, maze, mobManager = null) {
            if (y < 0 || y >= maze.length || x < 0 || x >= maze[0].length)
              return false;
            if (maze[y][x] === TILE_WALL) return false;
            if (mobManager && mobManager.getMobAt(x, y)) return false;
            return true;
          }
          tryMove(dx, dy, maze, mobManager = null) {
            const nx = this.x + dx,
              ny = this.y + dy;
            if (this.canOccupy(nx, ny, maze, mobManager)) {
              this.x = nx;
              this.y = ny;
              return true;
            }
            return false;
          }
          takeTurn(gameCtx) {
            /* no-op base */
          }
        }

        class Player extends Mob {
          constructor(o) {
            super({ kind: "player", glyph: "@", color: "#fff", ...o });
          }
        }

        class Monster extends Mob {
          constructor(o) {
            super({ kind: "monster", glyph: "m", color: "#f99", ...o });
            this.aggroRange = o.aggroRange ?? DEFAULT_MONSTER_AGGRO_RANGE;
          }
          takeTurn(gameCtx) {
            const { player, maze } = gameCtx;
            const dx = player.x - this.x,
              dy = player.y - this.y;
            const dist = Math.abs(dx) + Math.abs(dy);
            if (dist === 0) return;
            if (dist <= this.aggroRange) {
              const step =
                Math.abs(dx) > Math.abs(dy)
                  ? { dx: Math.sign(dx), dy: 0 }
                  : { dx: 0, dy: Math.sign(dy) };
              if (!this.tryMove(step.dx, step.dy, maze, gameCtx.mobManager)) {
                const alt =
                  step.dx !== 0
                    ? { dx: 0, dy: Math.sign(dy) }
                    : { dx: Math.sign(dx), dy: 0 };
                this.tryMove(alt.dx, alt.dy, maze, gameCtx.mobManager);
              }
            } else {
              const { dx, dy } =
                CARDINAL_DIRECTIONS[
                  (Math.random() * CARDINAL_DIRECTIONS.length) | 0
                ];
              this.tryMove(dx, dy, maze, gameCtx.mobManager);
            }
          }
        }

        class MobManager {
          constructor() {
            this.list = [];
            this.index = new Map();
          }
          add(m) {
            if (!m) return null;

            // Avoid tracking the same instance twice. The simulation used to add the
            // player both during setup and on the first tick, which left duplicate
            // references in the list and caused inconsistent indexing/AI behaviour.
            if (this.list.includes(m)) {
              return m;
            }

            this.list.push(m);
            this.reindex();
            return m;
          }
          removeById(id) {
            const existing = this.list.find((x) => x.id === id);
            if (!existing) return null;
            const key = `${existing.x},${existing.y}`;
            this.list = this.list.filter((x) => x.id !== id);
            this.index.delete(key);
            return existing;
          }
          getMobAt(x, y) {
            return this.index.get(`${x},${y}`) || null;
          }
          reindex() {
            this.index.clear();
            for (const m of this.list) this.index.set(`${m.x},${m.y}`, m);
          }
          tick(gameCtx, turn) {
            // Ensure our spatial index reflects any changes that happened between
            // ticks (for example actors being added or removed externally).
            this.reindex();

            const startIndex = new Map(this.index);
            const plannedMoves = [];
            const mobsThisTurn = [...this.list];

            const occupancyView = {
              getMobAt: (x, y) => startIndex.get(`${x},${y}`) || null,
            };

            for (const m of mobsThisTurn) {
              const startKey = `${m.x},${m.y}`;

              if (!this.list.includes(m)) {
                startIndex.delete(startKey);
                continue;
              }
              if (m.kind === "player") continue;

              if (handleDeath(gameCtx, m, gameCtx?.ui)) {
                startIndex.delete(startKey);
                continue;
              }

              tickStatusesAtTurnStart(m, turn, gameCtx);

              if (!this.list.includes(m) || m.__dead) {
                startIndex.delete(startKey);
                continue;
              }

              if (handleDeath(gameCtx, m, gameCtx?.ui)) {
                startIndex.delete(startKey);
                continue;
              }

              if (m.statusDerived?.canAct === false) {
                continue;
              }

              const nextActAt =
                typeof m.nextActAt === "number" ? m.nextActAt : 0;
              if (turn < nextActAt) {
                continue;
              }

              const from = { x: m.x, y: m.y };
              const turnCtx = { ...gameCtx, mobManager: occupancyView };
              m.takeTurn(turnCtx);
              const to = { x: m.x, y: m.y };

              if (to.x !== from.x || to.y !== from.y) {
                plannedMoves.push({ mob: m, from, to });
              }

              const delay = computeActorDelay(m);
              m.nextActAt = turn + delay;
            }

            const occupancy = new Map(startIndex);
            for (const move of plannedMoves) {
              if (!this.list.includes(move.mob) || move.mob.__dead) continue;
              const fromKey = `${move.from.x},${move.from.y}`;
              const toKey = `${move.to.x},${move.to.y}`;
              if (occupancy.get(fromKey) !== move.mob) continue;
              if (occupancy.has(toKey)) continue;

              occupancy.delete(fromKey);
              occupancy.set(toKey, move.mob);
              move.mob.x = move.to.x;
              move.mob.y = move.to.y;
            }

            this.reindex();
          }
        }

        // ===================== RANGED COMBAT HELPERS =====================

        function isRangedWeapon(item) {
          return item instanceof Item && item.isRangedWeapon();
        }

        function damageExpectation(dmgProfile) {
          if (!dmgProfile)
            return {
              min: 0,
              max: 0,
              avg: 0,
              diceCount: 0,
              diceSides: 0,
              bonus: 0,
            };
          const { diceCount, diceSides, bonus } = dmgProfile;
          const min = diceCount * 1 + bonus;
          const max = diceCount * diceSides + bonus;
          const avg = (diceCount * (diceSides + 1)) / 2 + bonus;
          return { min, max, avg, diceCount, diceSides, bonus };
        }

        function rollDamage(dmgProfile) {
          const { diceCount, diceSides, bonus } = dmgProfile || {
            diceCount: 0,
            diceSides: 0,
            bonus: 0,
          };
          const rolls = [];
          let total = bonus;
          for (let i = 0; i < diceCount; i++) {
            const roll = 1 + Math.floor(Math.random() * Math.max(1, diceSides));
            rolls.push(roll);
            total += roll;
          }
          return { total, rolls, bonus };
        }

        function describeDamage(dmgProfile) {
          if (!dmgProfile) return "";
          const { diceCount, diceSides, bonus } = dmgProfile;
          let parts = "";
          if (diceCount > 0) {
            parts = `${diceCount}d${diceSides}`;
          }
          if (bonus) {
            parts += bonus > 0 ? `+${bonus}` : `${bonus}`;
          }
          return parts || `${bonus || 0}`;
        }

        function describeAmmo(ammoProfile) {
          if (!ammoProfile) return "";
          if (ammoProfile.label) return ammoProfile.label;
          if (ammoProfile.itemId) return ammoProfile.itemId;
          if (ammoProfile.type) return ammoProfile.type;
          if (ammoProfile.typePrefix) return `${ammoProfile.typePrefix}*`;
          return "";
        }

        function ammoMatchesProfile(ammoProfile, stack) {
          if (!ammoProfile || !stack) return false;
          const id = stack.item.id;
          if (ammoProfile.itemId) return id === ammoProfile.itemId;
          if (ammoProfile.type) return id === ammoProfile.type;
          if (ammoProfile.typePrefix)
            return id.startsWith(ammoProfile.typePrefix);
          return false;
        }

        function findAmmoStackForProfile(mob, weaponProfile) {
          if (!weaponProfile?.ammo) return null;
          if (
            !mob ||
            !mob.inventory ||
            typeof mob.inventory.findStack !== "function"
          )
            return null;
          return mob.inventory.findStack((stack) =>
            ammoMatchesProfile(weaponProfile.ammo, stack),
          );
        }

        function consumeThrownItemFromAttacker(attacker, item, context = {}) {
          if (!attacker) return false;
          if (context && typeof context.consumeSource === "function") {
            const result = context.consumeSource();
            if (result) return true;
          }
          if (
            context &&
            typeof context.inventoryIndex === "number" &&
            attacker.inventory
          ) {
            if (attacker.inventory.consumeAt(context.inventoryIndex, 1))
              return true;
          }
          if (
            context &&
            context.stack &&
            typeof context.stack.consume === "function"
          ) {
            const consumed = context.stack.consume(1);
            if (consumed) return true;
          }
          if (context && context.equipmentSlot && attacker.equipment) {
            const equipped = attacker.equipment.get(context.equipmentSlot);
            if (equipped && (equipped === item || equipped.id === item.id)) {
              attacker.equipment.unequip(context.equipmentSlot);
              return true;
            }
          }
          if (attacker.equipment && attacker.equipment.slots instanceof Map) {
            for (const [slot, equipped] of attacker.equipment.slots.entries()) {
              if (!equipped) continue;
              if (equipped === item || equipped.id === item.id) {
                attacker.equipment.unequip(slot);
                return true;
              }
            }
          }
          if (
            attacker.inventory &&
            typeof attacker.inventory.consumeMatching === "function"
          ) {
            if (
              attacker.inventory.consumeMatching(
                (stack) => stack.item === item || stack.item.id === item.id,
                1,
              )
            )
              return true;
          }
          return false;
        }

        function evaluateRangedAttack(attacker, target, weapon, context = {}) {
          if (!isRangedWeapon(weapon)) {
            return { ok: false, reason: "not_ranged" };
          }
          if (!attacker || !target) {
            return { ok: false, reason: "invalid_actor" };
          }
          const profile = weapon.weaponProfile;
          const distance = chebyshevDistance(attacker.pos, target.pos);
          const result = {
            ok: false,
            weapon,
            profile,
            distance,
            reason: null,
          };
          if (distance < profile.range.min) {
            result.reason = "too_close";
            return result;
          }
          if (distance > profile.range.max) {
            result.reason = "out_of_range";
            return result;
          }
          const requireLoS = context.requireLineOfSight !== false;
          const mazeRef = context.maze || context.grid || null;
          if (
            requireLoS &&
            mazeRef &&
            !hasLineOfSight(mazeRef, attacker.pos, target.pos)
          ) {
            result.reason = "no_los";
            return result;
          }
          if (profile.ammo) {
            const ammoStack = findAmmoStackForProfile(attacker, profile);
            if (!ammoStack) {
              result.reason = "no_ammo";
              return result;
            }
            result.ammoStack = ammoStack;
          }
          result.damage = damageExpectation(profile.damage);
          result.timeCost =
            profile.aimTime + profile.reloadTime + Math.max(1, profile.volley);
          result.ok = true;
          return result;
        }

        function applyAttackOutcome({
          evaluation,
          attackCtx,
          baseRoll,
          target,
          onTargetDefeated,
        }) {
          const attackResult = resolveAttack(attackCtx);
          evaluation.roll = baseRoll;
          evaluation.damageApplied = attackResult.totalDamage;
          evaluation.packetsBeforeDefense =
            attackResult.packetsBeforeDefense;
          evaluation.packetsAfterDefense = attackResult.packetsAfterDefense;
          evaluation.statusApplied = attackResult.statusApplied;
          evaluation.attackResult = attackResult;

          const damageAfterDefense = attackResult.totalDamage ?? 0;
          if (typeof target.hp === "number") {
            target.hp -= damageAfterDefense;
            evaluation.targetHp = target.hp;
            evaluation.targetDefeated = target.hp <= 0;
            if (evaluation.targetDefeated) {
              if (typeof onTargetDefeated === "function") {
                onTargetDefeated();
              } else {
                handleDeath(target);
              }
            }
          }

          return evaluation;
        }

        function performRangedAttack(attacker, target, weapon, context = {}) {
          const evaluation = evaluateRangedAttack(
            attacker,
            target,
            weapon,
            context,
          );
          if (!evaluation.ok) return evaluation;
          const profile = weapon.weaponProfile;
          if (profile.ammo) {
            const ammoInfo =
              evaluation.ammoStack ||
              findAmmoStackForProfile(attacker, profile);
            if (!ammoInfo) {
              return { ok: false, reason: "no_ammo" };
            }
            if (!attacker.inventory) {
              return { ok: false, reason: "no_inventory" };
            }
            const consumed = attacker.inventory.consumeAt?.(
              ammoInfo.index,
              profile.ammo.perShot ?? 1,
            );
            if (!consumed) {
              return { ok: false, reason: "no_ammo" };
            }
            evaluation.ammoUsed = profile.ammo.perShot ?? 1;
          }
          const baseRoll = rollDamage(profile.damage);
          const diceTotal = Array.isArray(baseRoll.rolls)
            ? baseRoll.rolls.reduce((acc, value) => acc + value, 0)
            : 0;
          const attackCtx = {
            S: attacker,
            D: target,
            attacker,
            defender: target,
            turn: context.turn ?? 0,
            basePhysical: {
              diceTotal,
              flatFromWeapon: baseRoll.bonus ?? 0,
              flatFromStats: 0,
            },
            attackKind: "ranged",
            source: { item: weapon, weaponProfile: profile },
          };
          if (Array.isArray(context.statusAttempts) && context.statusAttempts.length) {
            attackCtx.statusAttempts = context.statusAttempts;
          }
          if (Array.isArray(context.conversions) && context.conversions.length) {
            attackCtx.conversions = context.conversions;
          }
          if (Array.isArray(context.brands) && context.brands.length) {
            attackCtx.brands = context.brands;
          }
          const deathCtx =
            context?.gameCtx ||
            (context?.mobManager ? { mobManager: context.mobManager } : context) ||
            null;
          applyAttackOutcome({
            evaluation,
            attackCtx,
            baseRoll,
            target,
            onTargetDefeated: () => handleDeath(deathCtx, target, deathCtx?.ui),
          });
          if (
            profile.category === WEAPON_CATEGORY.THROWN &&
            profile.consumeWeaponOnUse
          ) {
            const consumed = consumeThrownItemFromAttacker(
              attacker,
              weapon,
              context,
            );
            evaluation.weaponConsumed = consumed;
          }
          return evaluation;
        }

        function describeRangedWeapon(item) {
          if (!isRangedWeapon(item)) {
            return item ? item.name : "";
          }
          const profile = item.weaponProfile;
          const parts = [item.name, `(${profile.category})`];
          const rangePart =
            `Range ${profile.range.min}-${profile.range.max}` +
            (profile.range.optimal !== profile.range.min &&
            profile.range.optimal !== profile.range.max
              ? ` (opt ${profile.range.optimal})`
              : "");
          parts.push(rangePart);
          parts.push(`Damage ${describeDamage(profile.damage)}`);
          if (profile.ammo) {
            const ammoPart = describeAmmo(profile.ammo);
            if (ammoPart)
              parts.push(`Ammo ${ammoPart}×${profile.ammo.perShot ?? 1}`);
          }
          if (
            profile.category === WEAPON_CATEGORY.THROWN &&
            profile.consumeWeaponOnUse
          ) {
            const recover =
              profile.recoveryChance > 0
                ? ` (recover ${Math.round(profile.recoveryChance * 100)}%)`
                : "";
            parts.push(`Consumes weapon${recover}`);
          }
          if (profile.reloadTime) {
            parts.push(`Reload ${profile.reloadTime}t`);
          }
          if (profile.volley > 1) {
            parts.push(`Volley ${profile.volley}`);
          }
          if (profile.notes) {
            parts.push(profile.notes);
          }
          return parts.join(" • ");
        }

        const RangedCombat = {
          isRangedWeapon,
          chebyshevDistance,
          hasLineOfSight,
          damageExpectation,
          rollDamage,
          describeDamage,
          describeAmmo,
          findAmmoStackForProfile,
          evaluateRangedAttack,
          performRangedAttack,
          describeRangedWeapon,
        };

        function getThrowProfileForItem(item) {
          if (!(item instanceof Item)) return null;
          return item.getThrowProfile?.() || null;
        }

        function describeThrowProfile(profile) {
          if (!profile) return "";
          const parts = [];
          if (profile.range) {
            parts.push(
              `Range ${profile.range.min}/${profile.range.optimal}/${profile.range.max}`,
            );
          }
          if (profile.damage) {
            parts.push(`Damage ${describeDamage(profile.damage)}`);
          }
          if (profile.consumesItem) {
            const recover =
              profile.recoveryChance > 0
                ? ` (recover ${Math.round(profile.recoveryChance * 100)}%)`
                : "";
            parts.push(`Consumes item${recover}`);
          }
          if (!profile.consumesItem) {
            parts.push("Reusable");
          }
          if (profile.notes) {
            parts.push(profile.notes);
          }
          return parts.join(" • ");
        }

        function describeThrowable(item) {
          const profile = getThrowProfileForItem(item);
          if (!profile) return "";
          return describeThrowProfile(profile);
        }

        function evaluateThrow(attacker, target, item, context = {}) {
          if (!(item instanceof Item)) {
            return { ok: false, reason: "invalid_item" };
          }
          if (!attacker || !target) {
            return { ok: false, reason: "invalid_actor" };
          }
          const profile = getThrowProfileForItem(item);
          if (!profile) {
            return { ok: false, reason: "not_throwable" };
          }
          const distance = chebyshevDistance(attacker.pos, target.pos);
          const result = {
            ok: false,
            item,
            profile,
            distance,
            throwClass: profile.throwClass || classifyThrowability(item),
            reason: null,
          };
          if (profile.allowed === false) {
            result.reason = "unsuitable";
            return result;
          }
          if (distance < profile.range.min) {
            result.reason = "too_close";
            return result;
          }
          if (distance > profile.range.max) {
            result.reason = "out_of_range";
            return result;
          }
          const requireLoS = context.requireLineOfSight !== false;
          const mazeRef = context.maze || context.grid || null;
          if (
            requireLoS &&
            mazeRef &&
            !hasLineOfSight(mazeRef, attacker.pos, target.pos)
          ) {
            result.reason = "no_los";
            return result;
          }
          result.damage = damageExpectation(profile.damage);
          result.timeCost = Math.max(1, Math.floor(context.timeCost ?? 1));
          result.ok = true;
          return result;
        }

        function performThrow(attacker, target, item, context = {}) {
          const evaluation = evaluateThrow(attacker, target, item, context);
          if (!evaluation.ok) return evaluation;
          const profile = evaluation.profile;
          const baseRoll = rollDamage(profile.damage);
          const diceTotal = Array.isArray(baseRoll.rolls)
            ? baseRoll.rolls.reduce((acc, value) => acc + value, 0)
            : 0;
          const attackCtx = {
            S: attacker,
            D: target,
            attacker,
            defender: target,
            turn: context.turn ?? 0,
            basePhysical: {
              diceTotal,
              flatFromWeapon: baseRoll.bonus ?? 0,
              flatFromStats: 0,
            },
            attackKind: "throw",
            source: { item, throwProfile: profile },
          };
          if (Array.isArray(context.statusAttempts) && context.statusAttempts.length) {
            attackCtx.statusAttempts = context.statusAttempts;
          }
          if (Array.isArray(context.conversions) && context.conversions.length) {
            attackCtx.conversions = context.conversions;
          }
          if (Array.isArray(context.brands) && context.brands.length) {
            attackCtx.brands = context.brands;
          }
          applyAttackOutcome({
            evaluation,
            attackCtx,
            baseRoll,
            target,
          });
          if (profile.consumesItem) {
            evaluation.itemConsumed = consumeThrownItemFromAttacker(
              attacker,
              item,
              context,
            );
          }
          return evaluation;
        }

        function evaluateAttack(attacker, target, item, mode, context = {}) {
          if (!mode || !mode.kind) {
            return { ok: false, reason: "invalid_mode" };
          }
          if (mode.kind === ATTACK_KIND.RANGED) {
            return evaluateRangedAttack(attacker, target, item, context);
          }
          if (mode.kind === ATTACK_KIND.THROW) {
            return evaluateThrow(attacker, target, item, context);
          }
          return { ok: false, reason: "unknown_mode" };
        }

        function performAttack(attacker, target, item, mode, context = {}) {
          if (!mode || !mode.kind) {
            return { ok: false, reason: "invalid_mode" };
          }
          if (mode.kind === ATTACK_KIND.RANGED) {
            return performRangedAttack(attacker, target, item, context);
          }
          if (mode.kind === ATTACK_KIND.THROW) {
            return performThrow(attacker, target, item, context);
          }
          return { ok: false, reason: "unknown_mode" };
        }

        function chooseAttackMode(attacker, target, item, context = {}) {
          const modes = getAttackModesForItem(item);
          let best = null;
          let bestScore = -Infinity;
          for (const mode of modes) {
            const ev = evaluateAttack(attacker, target, item, mode, context);
            if (!ev.ok) continue;
            const expectedDamage = ev.damage?.avg ?? 0;
            const timeCost = Math.max(1, ev.timeCost ?? 1);
            const dps = expectedDamage / timeCost;
            const ammoPenalty =
              mode.kind === ATTACK_KIND.RANGED &&
              !!ev.profile?.ammo
                ? 0.05
                : 0;
            const resourcePenalty =
              mode.kind === ATTACK_KIND.THROW && ev.profile?.consumesItem
                ? 0.02
                : 0;
            const score = dps - ammoPenalty - resourcePenalty;
            if (score > bestScore) {
              bestScore = score;
              best = mode;
            }
          }
          return best;
        }

        const Throwing = {
          ATTACK_KIND,
          THROW_CLASS,
          classifyThrowability,
          throwPenaltiesFor,
          buildEffectiveThrowProfile,
          getAttackModesForItem,
          getThrowProfile: getThrowProfileForItem,
          describeThrowProfile,
          describeThrowable,
          evaluateThrow,
          performThrow,
        };

        const Combat = {
          ATTACK_KIND,
          THROW_CLASS,
          getAttackModesForItem,
          evaluateAttack,
          performAttack,
          chooseAttackMode,
        };

        // --- ITEM TEMPLATES ---

        function getLightProperties() {
          const defaults = {
            radius: DEFAULT_LIGHT_RADIUS,
            color: LIGHT_CONFIG.fallbackColor,
            flickerRate: LIGHT_CONFIG.fallbackFlickerRate,
          };
          if (
            !player ||
            !player.equipment ||
            typeof player.equipment.getLightSourceProperties !== "function"
          ) {
            return defaults;
          }
          return player.equipment.getLightSourceProperties(defaults);
        }

        function computeTileOverlayAlpha(x, y, lightCtx) {
          const baseA = Math.max(0, Math.min(1, LIGHT_CONFIG.baseOverlayAlpha));
          const variance = Math.max(0, LIGHT_CONFIG.flickerVariance || 0);
          if (!lightCtx || variance <= 0) {
            return baseA;
          }
          const radius = Number.isFinite(lightCtx.radius)
            ? Math.max(0, lightCtx.radius)
            : 0;
          if (radius <= 0) {
            return baseA;
          }
          const osc = lightCtx.osc || 0;
          if (osc === 0) {
            return baseA;
          }
          const dx = x - lightCtx.playerX;
          const dy = y - lightCtx.playerY;
          const dist = Math.max(Math.abs(dx), Math.abs(dy));
          const dead = LIGHT_CONFIG.flickerNearDeadZoneTiles;
          const denom = Math.max(1e-6, radius - dead);
          const u0 = (dist - dead) / denom;
          const u = smoothstep01(u0);
          const amp =
            variance * Math.pow(u, LIGHT_CONFIG.flickerFalloffPower);
          const alpha = baseA + osc * amp;
          if (alpha <= 0) return 0;
          if (alpha >= 1) return 1;
          return alpha;
        }

        function createLightOverlayContext() {
          const radius =
            typeof player?.lightRadius === "function"
              ? player.lightRadius()
              : 0;
          const rate =
            typeof player?.equipment?.getLightFlickerRate === "function"
              ? player.equipment.getLightFlickerRate()
              : 0;
          const flickerRate =
            typeof rate === "number" && Number.isFinite(rate) ? Math.max(0, rate) : 0;
          const tSec = getNow() / 1000;
          const osc =
            flickerRate > 0 ? Math.sin(tSec * 2 * Math.PI * flickerRate) : 0;
          const playerX = typeof player?.x === "number" ? player.x : 0;
          const playerY = typeof player?.y === "number" ? player.y : 0;
          return {
            radius,
            osc,
            playerX,
            playerY,
          };
        }

        function computeLightOverlayVisuals() {
          const props = getLightProperties();
          const rgb = colorStringToRgb(
            props.color,
            LIGHT_CONFIG.fallbackColor,
          );
          const baseA = Math.max(0, Math.min(1, LIGHT_CONFIG.baseOverlayAlpha));
          return {
            style: `rgba(${rgb.r},${rgb.g},${rgb.b},${baseA.toFixed(3)})`,
            rgb,
          };
        }

        function refreshLightingVisuals() {
          const overlay = computeLightOverlayVisuals();
          fovState.overlayStyle = overlay.style;
          fovState.overlayRgb = overlay.rgb;
        }

        function getLightRadius() {
          return getLightProperties().radius;
        }

        function tileBlocksLight(x, y, useKnownGrid = false) {
          if (x < 0 || x >= mapState.width || y < 0 || y >= mapState.height)
            return true;
          const grid = useKnownGrid ? mapState.known : mapState.grid;
          const row = grid[y];
          if (!row) return true;
          const val = row[x];
          if (useKnownGrid && val === -1) return false;
          return val === TILE_WALL;
        }
        function computeFieldOfView(pos, radius, useKnownGrid = false) {
          const visible = new Set();
          const radiusSq = radius * radius;
          visible.add(posKey(pos));
          const setVisible = (x, y) => {
            if (x < 0 || x >= mapState.width || y < 0 || y >= mapState.height)
              return;
            visible.add(posKey({ x, y }));
          };
          function castLight(row, startSlope, endSlope, xx, xy, yx, yy) {
            if (startSlope < endSlope) return;
            for (let i = row; i <= radius; i++) {
              let dx = -i - 1;
              let dy = -i;
              let blocked = false;
              let newStart = startSlope;
              while (dx <= 0) {
                dx += 1;
                const mx = pos.x + dx * xx + dy * xy;
                const my = pos.y + dx * yx + dy * yy;
                const lSlope = (dx - 0.5) / (dy + 0.5);
                const rSlope = (dx + 0.5) / (dy - 0.5);
                if (startSlope < rSlope) {
                  continue;
                }
                if (endSlope > lSlope) {
                  break;
                }
                const distSq = dx * dx + dy * dy;
                if (distSq <= radiusSq) {
                  setVisible(mx, my);
                }
                const blockedTile = tileBlocksLight(mx, my, useKnownGrid);
                if (blocked) {
                  if (blockedTile) {
                    newStart = rSlope;
                    continue;
                  }
                  blocked = false;
                  startSlope = newStart;
                } else if (blockedTile && i < radius) {
                  blocked = true;
                  castLight(i + 1, startSlope, lSlope, xx, xy, yx, yy);
                  newStart = rSlope;
                }
              }
              if (blocked) {
                break;
              }
            }
          }
          for (let oct = 0; oct < 8; oct++) {
            const [xx, xy, yx, yy] = FOV_TRANSFORMS[oct];
            castLight(1, 1.0, 0.0, xx, xy, yx, yy);
          }
          return visible;
        }
        function computeVisibleCells(pos) {
          const key = posKey(pos);
          const radius = getLightRadius();
          if (
            fovState.lastCache.visible &&
            fovState.lastCache.key === key &&
            fovState.lastCache.radius === radius
          ) {
            return fovState.lastCache.visible;
          }
          const visible = computeFieldOfView(pos, radius, false);
          fovState.lastCache = { key, radius, visible };
          return visible;
        }
        // --- A* PATHFINDING FOR MAP VALIDATION ---
        function inBounds(grid, x, y) {
          return y >= 0 && y < grid.length && x >= 0 && x < grid[0].length;
        }
        function aStarPath(grid, start, end) {
          // Straightforward A* over the 4-connected grid. The map generator only uses this to
          // verify connectivity, so we prioritise readability over micro-optimisations – the
          // grids are small enough that the classic textbook implementation is plenty fast.
          const heuristic = (a, b) => Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
          const openSet = [];
          const closedSet = new Set();
          const cameFrom = new Map();
          const gScore = new Map();
          const fScore = new Map();
          const startKey = posKey(start);
          gScore.set(startKey, 0);
          fScore.set(startKey, heuristic(start, end));
          openSet.push(start);
          while (openSet.length > 0) {
            let lowestIndex = 0;
            for (let i = 1; i < openSet.length; i++) {
              const fA = fScore.get(posKey(openSet[i])) || Infinity;
              const fB = fScore.get(posKey(openSet[lowestIndex])) || Infinity;
              if (fA < fB) {
                lowestIndex = i;
              }
            }
            const current = openSet.splice(lowestIndex, 1)[0];
            const currentKey = posKey(current);
            if (current.x === end.x && current.y === end.y) {
              const path = [];
              let temp = current;
              while (temp) {
                path.unshift(temp);
                temp = cameFrom.get(posKey(temp));
              }
              return path;
            }
            closedSet.add(currentKey);
            const neighbors = [
              { x: current.x, y: current.y - 1 },
              { x: current.x, y: current.y + 1 },
              { x: current.x - 1, y: current.y },
              { x: current.x + 1, y: current.y },
            ];
            for (const neighbor of neighbors) {
              if (
                !inBounds(grid, neighbor.x, neighbor.y) ||
                grid[neighbor.y][neighbor.x] === TILE_WALL
              ) {
                continue;
              }
              const neighborKey = posKey(neighbor);
              if (closedSet.has(neighborKey)) {
                continue;
              }
              const tentativeGScore = (gScore.get(currentKey) || 0) + 1;
              if (
                !openSet.some((node) => posKey(node) === neighborKey) ||
                tentativeGScore < (gScore.get(neighborKey) || Infinity)
              ) {
                cameFrom.set(neighborKey, current);
                gScore.set(neighborKey, tentativeGScore);
                fScore.set(
                  neighborKey,
                  tentativeGScore + heuristic(neighbor, end),
                );
                if (!openSet.some((node) => posKey(node) === neighborKey)) {
                  openSet.push(neighbor);
                }
              }
            }
          }
          return null; // No path found
        }

        // --- DUNGEON SHAPE GENERATION HELPERS ---
        function manhattanEdgeDistanceRect(A, B) {
          const dx = Math.max(0, B.x0 - A.x1, A.x0 - B.x1);
          const dy = Math.max(0, B.y0 - A.y1, A.y0 - B.y1);
          return dx + dy;
        }
        function pointInPoly(x, y, poly) {
          let inside = false;
          for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
            const xi = poly[i].x,
              yi = poly[i].y;
            const xj = poly[j].x,
              yj = poly[j].y;
            const intersect =
              yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;
            if (intersect) inside = !inside;
          }
          return inside;
        }
        function finalizeRoomShape(kind, widthHint, heightHint, tiles) {
          const normalizedTiles = tiles.map((t) => ({ x: t.x, y: t.y }));
          if (normalizedTiles.length === 0) {
            const safeW = Math.max(
              0,
              typeof widthHint === "number" ? widthHint : 0,
            );
            const safeH = Math.max(
              0,
              typeof heightHint === "number" ? heightHint : 0,
            );
            const x1 = safeW > 0 ? safeW - 1 : -1;
            const y1 = safeH > 0 ? safeH - 1 : -1;
            return {
              kind,
              w: safeW,
              h: safeH,
              tiles: normalizedTiles,
              center: {
                x: safeW > 0 ? (safeW - 1) / 2 : 0,
                y: safeH > 0 ? (safeH - 1) / 2 : 0,
              },
              bbox: { x0: 0, y0: 0, x1, y1 },
            };
          }
          let x0 = normalizedTiles[0].x;
          let y0 = normalizedTiles[0].y;
          let x1 = normalizedTiles[0].x;
          let y1 = normalizedTiles[0].y;
          for (const t of normalizedTiles) {
            if (t.x < x0) x0 = t.x;
            if (t.y < y0) y0 = t.y;
            if (t.x > x1) x1 = t.x;
            if (t.y > y1) y1 = t.y;
          }
          const derivedW = x1 - x0 + 1;
          const derivedH = y1 - y0 + 1;
          const centerX = x0 + (derivedW - 1) / 2;
          const centerY = y0 + (derivedH - 1) / 2;
          return {
            kind,
            w: derivedW,
            h: derivedH,
            tiles: normalizedTiles,
            center: { x: centerX, y: centerY },
            bbox: { x0, y0, x1, y1 },
          };
        }
        function rasterizeRegularPolygon(
          n,
          targetArea,
          minSide,
          kindLabel = `poly${n}`,
        ) {
          const twoPi = Math.PI * 2;
          const sin = Math.sin;
          const areaToR = (A) => Math.sqrt((2 * A) / (n * sin(twoPi / n)));
          const Rmin = minSide / (2 * sin(Math.PI / n));
          let R = Math.max(areaToR(targetArea), Rmin);
          const tryBuild = (Rtry) => {
            const w = Math.ceil(2 * Rtry) + 2;
            const h = w;
            const cx = w / 2,
              cy = h / 2;
            const verts = [];
            for (let i = 0; i < n; i++) {
              const ang = (twoPi * i) / n - Math.PI / n;
              verts.push({
                x: cx + Rtry * Math.cos(ang),
                y: cy + Rtry * Math.sin(ang),
              });
            }
            const tiles = [];
            for (let ty = 0; ty < h; ty++) {
              for (let tx = 0; tx < w; tx++) {
                const cxCell = tx + 0.5,
                  cyCell = ty + 0.5;
                if (pointInPoly(cxCell, cyCell, verts)) {
                  tiles.push({ x: tx, y: ty });
                }
              }
            }
            return finalizeRoomShape(kindLabel, w, h, tiles);
          };
          let out = tryBuild(R);
          const measured = out.tiles.length;
          if (measured < 0.9 * targetArea || measured > 1.1 * targetArea) {
            const scale = Math.sqrt(targetArea / Math.max(1, measured));
            R = Math.max(R * scale, Rmin);
            out = tryBuild(R);
          }
          return out;
        }
        function rasterizeDisc(targetArea, minSide) {
          let R = Math.sqrt(targetArea / Math.PI);
          R = Math.max(R, minSide);
          const w = Math.ceil(2 * R) + 2;
          const h = w;
          const cx = w / 2,
            cy = h / 2;
          const R2 = R * R;
          const tiles = [];
          for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
              const dx = x + 0.5 - cx;
              const dy = y + 0.5 - cy;
              if (dx * dx + dy * dy <= R2) tiles.push({ x, y });
            }
          }
          const measured = tiles.length;
          if (measured < 0.9 * targetArea || measured > 1.1 * targetArea) {
            const scale = Math.sqrt(targetArea / Math.max(1, measured));
            const R2b = Math.max(R * scale, minSide);
            return rasterizeDisc(Math.PI * R2b * R2b, minSide);
          }
          return finalizeRoomShape("round", w, h, tiles);
        }
        function rasterizeRectLike(targetArea, minSide, kind) {
          let w, h;
          if (kind === "square") {
            const s = Math.max(minSide, Math.round(Math.sqrt(targetArea)));
            w = s;
            h = s;
          } else {
            const ratio = 1 + Math.random() * 1.5; // 1.0..2.5
            w = Math.max(minSide, Math.round(Math.sqrt(targetArea * ratio)));
            h = Math.max(minSide, Math.round(targetArea / w));
            if (w * h < targetArea) {
              if (w < h) w = Math.max(w + 1, minSide);
              else h = Math.max(h + 1, minSide);
            }
          }
          const tiles = [];
          for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) tiles.push({ x, y });
          }
          return finalizeRoomShape(kind, w, h, tiles);
        }
        function rasterizeCross(targetArea, minSide) {
          const armWidth = Math.max(3, Math.round(clamp(minSide / 2, 3, 10)));
          // Area = 2 * L * armWidth - armWidth^2
          const L = Math.round(
            (targetArea + armWidth * armWidth) / (2 * armWidth),
          );
          const size = Math.max(L, minSide, armWidth * 3);
          const halfSize = Math.floor(size / 2);
          const halfArm = Math.floor(armWidth / 2);

          const tiles = [];
          for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
              const isHorizontal = Math.abs(y - halfSize) <= halfArm;
              const isVertical = Math.abs(x - halfSize) <= halfArm;
              if (isHorizontal || isVertical) {
                tiles.push({ x, y });
              }
            }
          }
          return finalizeRoomShape("cross", size, size, tiles);
        }
        function rasterizeX(targetArea, minSide) {
          let size = Math.max(minSide, Math.round(Math.sqrt(targetArea * 0.9))); // Initial guess

          const countFor = (S) => {
            const armWidth = Math.max(3, Math.round(clamp(S / 5, 3, 9)));
            const tiles = new Set();
            const halfArm = Math.floor(armWidth / 2);
            for (let i = 0; i < S; i++) {
              for (let w = -halfArm; w <= halfArm; w++) {
                // Main diagonal segment
                if (i + w >= 0 && i + w < S) tiles.add(`${i},${i + w}`);
                // Anti-diagonal segment
                if (S - 1 - i + w >= 0 && S - 1 - i + w < S)
                  tiles.add(`${i},${S - 1 - i + w}`);
              }
            }
            return tiles.size;
          };

          let areaNow = countFor(size);
          let guard = 0;
          const within = (val, tgt) =>
            Math.abs(val - tgt) <= Math.max(15, Math.floor(tgt * 0.15));
          while (!within(areaNow, targetArea) && guard++ < 50) {
            const ratio = Math.sqrt(targetArea / areaNow);
            let nextSize = Math.round(size * ratio);
            if (nextSize === size)
              nextSize = areaNow < targetArea ? size + 1 : size - 1;
            size = Math.max(minSide, nextSize);
            areaNow = countFor(size);
          }

          const finalTiles = [];
          const armWidth = Math.max(3, Math.round(clamp(size / 5, 3, 9)));
          const tileSet = new Set();
          const halfArm = Math.floor(armWidth / 2);
          for (let i = 0; i < size; i++) {
            for (let w = -halfArm; w <= halfArm; w++) {
              if (i + w >= 0 && i + w < size) tileSet.add(`${i},${i + w}`);
              if (size - 1 - i + w >= 0 && size - 1 - i + w < size)
                tileSet.add(`${i},${size - 1 - i + w}`);
            }
          }
          tileSet.forEach((key) => {
            const [x, y] = key.split(",").map(Number);
            finalTiles.push({ x, y });
          });

          return finalizeRoomShape("x", size, size, finalTiles);
        }
        function rasterizeRingHub(targetArea, minSide) {
          const orient = randChoice(["h", "v"]);
          const cw = Math.max(1, Math.floor(Math.max(2, minSide / 6)));

          let R = Math.max(minSide, Math.ceil(Math.sqrt(targetArea / Math.PI)));

          const chooseParams = (R) => {
            const w = clamp(
              Math.floor(R / 4),
              2,
              Math.max(2, Math.floor(minSide / 2)),
            );
            const rcMax = Math.max(2, R - w - 3);
            const rc = clamp(Math.floor(R / 3), 2, rcMax);
            return { w, rc };
          };

          const countFor = (R) => {
            const { w, rc } = chooseParams(R);
            const S = 2 * R + 1;
            const half = R;
            let c = 0;

            const tInner2 = (R - w) * (R - w);
            const tOuter2 = R * R;
            const hub2 = rc * rc;
            const halfCW = Math.floor((cw - 1) / 2);

            if (orient === "h") {
              for (let y = -half; y <= half; y++) {
                for (let x = -half; x <= half; x++) {
                  const r2 = x * x + y * y;
                  const inRing = r2 <= tOuter2 && r2 >= tInner2;
                  const inHub = r2 <= hub2;
                  const inCorr = Math.abs(y) <= halfCW && x >= rc && x <= R - w;
                  if (inRing || inHub || inCorr) c++;
                }
              }
            } else {
              for (let y = -half; y <= half; y++) {
                for (let x = -half; x <= half; x++) {
                  const r2 = x * x + y * y;
                  const inRing = r2 <= tOuter2 && r2 >= tInner2;
                  const inHub = r2 <= hub2;
                  const inCorr = Math.abs(x) <= halfCW && y >= rc && y <= R - w;
                  if (inRing || inHub || inCorr) c++;
                }
              }
            }
            return c;
          };

          const within = (val, tgt) =>
            Math.abs(val - tgt) <= Math.max(12, Math.floor(tgt * 0.1));
          let areaNow = countFor(R);
          let guard = 0;
          while (!within(areaNow, targetArea) && guard++ < 200) {
            if (areaNow < targetArea) R += 1;
            else if (R > minSide + 2) R -= 1;
            else break;
            areaNow = countFor(R);
          }

          const { w, rc } = chooseParams(R);
          const S = 2 * R + 1;
          const half = R;
          const tiles = [];

          const tInner2 = (R - w) * (R - w);
          const tOuter2 = R * R;
          const hub2 = rc * rc;
          const halfCW = Math.floor((cw - 1) / 2);

          if (orient === "h") {
            for (let y = -half; y <= half; y++) {
              for (let x = -half; x <= half; x++) {
                const r2 = x * x + y * y;
                const inRing = r2 <= tOuter2 && r2 >= tInner2;
                const inHub = r2 <= hub2;
                const inCorr = Math.abs(y) <= halfCW && x >= rc && x <= R - w;
                if (inRing || inHub || inCorr)
                  tiles.push({ x: x + half, y: y + half });
              }
            }
          } else {
            for (let y = -half; y <= half; y++) {
              for (let x = -half; x <= half; x++) {
                const r2 = x * x + y * y;
                const inRing = r2 <= tOuter2 && r2 >= tInner2;
                const inHub = r2 <= hub2;
                const inCorr = Math.abs(x) <= halfCW && y >= rc && y <= R - w;
                if (inRing || inHub || inCorr)
                  tiles.push({ x: x + half, y: y + half });
              }
            }
          }

          return finalizeRoomShape("ringhub", S, S, tiles);
        }
        function makeShape(targetArea, minSide) {
          const shape = randChoice([
            "square",
            "rectangle",
            "round",
            "hex",
            "oct",
            "cross",
            "x",
            "ringhub",
          ]);
          if (shape === "square")
            return rasterizeRectLike(targetArea, minSide, "square");
          if (shape === "rectangle")
            return rasterizeRectLike(targetArea, minSide, "rectangle");
          if (shape === "round") return rasterizeDisc(targetArea, minSide);
          if (shape === "hex")
            return rasterizeRegularPolygon(6, targetArea, minSide, "hex");
          if (shape === "oct")
            return rasterizeRegularPolygon(8, targetArea, minSide, "oct");
          if (shape === "cross") return rasterizeCross(targetArea, minSide);
          if (shape === "x") return rasterizeX(targetArea, minSide);
          return rasterizeRingHub(targetArea, minSide);
        }
        function canPlace(bbox, placed, minSpacing) {
          for (const r of placed) {
            const other = r.bbox;
            const overlap = !(
              bbox.x1 < other.x0 ||
              bbox.x0 > other.x1 ||
              bbox.y1 < other.y0 ||
              bbox.y0 > other.y1
            );
            if (overlap) return false;
            const l1 = manhattanEdgeDistanceRect(bbox, other);
            if (l1 < minSpacing) return false;
          }
          return true;
        }

        // -------------------------------------------------------------
        // Large-Rooms-Only Dungeon Generator (dynamic map, wall buffer)
        // Floors = 0, Walls = 1
        // -------------------------------------------------------------
        function generateLargeRoomsMap(options = {}) {
          /*
           * High level algorithm:
           *   1. Randomly pick a target area and silhouette for each desired room (square,
           *      round, polygonal, etc.) using the rasterize helpers above.
           *   2. Scatter the rooms in an expanding search radius until they no longer overlap,
           *      keeping a large Manhattan buffer so big chambers do not bleed into each other.
           *   3. After all rooms are placed, normalise the co-ordinates so the outer border is
           *      padded with solid walls and emit a single grid where 0 = floor, 1 = wall.
           *
           * The function returns both the finished tile grid and metadata about every room so
           * downstream systems (path validation, loot placement, etc.) do not need to reverse
           * engineer the layout again.
           */
          const cfg = {
            roomCountRange: [1, 11],
            areaRange: [300, 750],
            minSide: 8, // tiles; for round => diameter >= 2*minSide
            minL1EdgeSpacing: 30, // tiles; Manhattan edge-to-edge distance
            border: 15, // outer wall buffer thickness
            maxAttemptsPerRoom: 600,
            ...options,
          };
          const randInt = (a, b) => a + Math.floor(Math.random() * (b - a + 1));

          const desiredRooms = randInt(
            cfg.roomCountRange[0],
            cfg.roomCountRange[1],
          );
          const bigRooms = [];
          for (let i = 0; i < desiredRooms; i++) {
            const area = randInt(cfg.areaRange[0], cfg.areaRange[1]);
            bigRooms.push(makeShape(area, cfg.minSide));
          }
          const placed = [];
          let searchRadius = 0;
          for (const room of bigRooms) {
            let placedOK = false;
            const baseR = (searchRadius +=
              Math.max(room.w, room.h) + cfg.minL1EdgeSpacing);
            for (let attempt = 0; attempt < cfg.maxAttemptsPerRoom; attempt++) {
              const R = baseR + Math.floor(attempt / 10) * 10;
              const tx = randInt(-R, R);
              const ty = randInt(-R, R);
              const bbox = {
                x0: tx + room.bbox.x0,
                y0: ty + room.bbox.y0,
                x1: tx + room.bbox.x1,
                y1: ty + room.bbox.y1,
              };
              if (!canPlace(bbox, placed, cfg.minL1EdgeSpacing)) continue;
              const translatedTiles = room.tiles.map((t) => ({
                x: tx + t.x,
                y: ty + t.y,
              }));
              const placedRoom = {
                kind: room.kind,
                w: room.w,
                h: room.h,
                bbox,
                center: { x: tx + room.center.x, y: ty + room.center.y },
                tiles: translatedTiles,
              };
              placed.push(placedRoom);
              placedOK = true;
              break;
            }
          }
          if (placed.length === 0) {
            const fallback = rasterizeRectLike(
              clamp((cfg.areaRange[0] + cfg.areaRange[1]) >> 1, 300, 750),
              cfg.minSide,
              "square",
            );
            const fallbackRoom = {
              kind: fallback.kind,
              w: fallback.w,
              h: fallback.h,
              bbox: {
                x0: fallback.bbox.x0,
                y0: fallback.bbox.y0,
                x1: fallback.bbox.x1,
                y1: fallback.bbox.y1,
              },
              center: { x: fallback.center.x, y: fallback.center.y },
              tiles: fallback.tiles.map((t) => ({ x: t.x, y: t.y })),
            };
            placed.push(fallbackRoom);
          }
          let minX = Infinity,
            minY = Infinity,
            maxX = -Infinity,
            maxY = -Infinity;
          for (const r of placed) {
            minX = Math.min(minX, r.bbox.x0);
            minY = Math.min(minY, r.bbox.y0);
            maxX = Math.max(maxX, r.bbox.x1);
            maxY = Math.max(maxY, r.bbox.y1);
          }
          const innerW = maxX - minX + 1;
          const innerH = maxY - minY + 1;
          const W = innerW + 2 * cfg.border;
          const H = innerH + 2 * cfg.border;
          const grid = Array.from({ length: H }, () =>
            Array(W).fill(TILE_WALL),
          );
          const ox = -minX + cfg.border;
          const oy = -minY + cfg.border;
          for (const r of placed) {
            for (const t of r.tiles) {
              const gx = t.x + ox;
              const gy = t.y + oy;
              if (gy >= 0 && gy < H && gx >= 0 && gx < W)
                grid[gy][gx] = TILE_FLOOR;
            }
          }
          const deriveBBox = (tiles) => {
            if (!tiles || tiles.length === 0)
              return { x0: 0, y0: 0, x1: -1, y1: -1 };
            let x0 = tiles[0].x;
            let y0 = tiles[0].y;
            let x1 = tiles[0].x;
            let y1 = tiles[0].y;
            for (const t of tiles) {
              if (t.x < x0) x0 = t.x;
              if (t.y < y0) y0 = t.y;
              if (t.x > x1) x1 = t.x;
              if (t.y > y1) y1 = t.y;
            }
            return { x0, y0, x1, y1 };
          };
          const rooms = placed.map((r) => {
            const shape = r.room ?? r;
            const tiles = Array.isArray(r.tiles)
              ? r.tiles
              : Array.isArray(shape.tiles)
              ? shape.tiles
              : [];
            const rawBBox = r.bbox ?? shape.bbox ?? deriveBBox(tiles);
            const width =
              typeof shape.w === "number"
                ? shape.w
                : rawBBox.x1 >= rawBBox.x0
                ? rawBBox.x1 - rawBBox.x0 + 1
                : 0;
            const height =
              typeof shape.h === "number"
                ? shape.h
                : rawBBox.y1 >= rawBBox.y0
                ? rawBBox.y1 - rawBBox.y0 + 1
                : 0;
            const center = r.center ?? shape.center ?? {
              x: rawBBox.x0 + (width - 1) / 2,
              y: rawBBox.y0 + (height - 1) / 2,
            };
            return {
              kind: shape.kind ?? "unknown",
              w: width,
              h: height,
              bbox: {
                x0: rawBBox.x0 + ox,
                y0: rawBBox.y0 + oy,
                x1: rawBBox.x1 + ox,
                y1: rawBBox.y1 + oy,
              },
              center: { x: center.x + ox, y: center.y + oy },
              tiles: tiles.map((t) => ({ x: t.x + ox, y: t.y + oy })),
            };
          });
          return {
            grid,
            width: W,
            height: H,
            rooms,
            meta: {
              border: cfg.border,
              minL1EdgeSpacing: cfg.minL1EdgeSpacing,
              minSide: cfg.minSide,
              requestedRooms: desiredRooms,
              placedRooms: placed.length,
            },
          };
        }
        // --- DELAUNAY TRIANGULATION IMPLEMENTATION ---
        class Vertex {
          constructor(x, y) {
            this.x = x;
            this.y = y;
          }
          equals(vertex) {
            return this.x === vertex.x && this.y === vertex.y;
          }
        }

        class Edge {
          constructor(v0, v1) {
            this.v0 = v0;
            this.v1 = v1;
          }
          equals(edge) {
            return (
              (this.v0.equals(edge.v0) && this.v1.equals(edge.v1)) ||
              (this.v0.equals(edge.v1) && this.v1.equals(edge.v0))
            );
          }
        }

        class Triangle {
          constructor(v0, v1, v2) {
            this.v0 = v0;
            this.v1 = v1;
            this.v2 = v2;
            this.circumCircle = calcCircumCircle(v0, v1, v2);
          }
        }

        function calcCircumCircle(v0, v1, v2) {
          const ax = v0.x,
            ay = v0.y;
          const bx = v1.x,
            by = v1.y;
          const cx = v2.x,
            cy = v2.y;
          const d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));
          if (d === 0)
            return {
              center: { x: 0, y: 0 },
              radius: Infinity,
              contains() {
                return true;
              },
            }; // collinear
          const ux =
            ((ax * ax + ay * ay) * (by - cy) +
              (bx * bx + by * by) * (cy - ay) +
              (cx * cx + cy * cy) * (ay - by)) /
            d;
          const uy =
            ((ax * ax + ay * ay) * (cx - bx) +
              (bx * bx + by * by) * (ax - cx) +
              (cx * cx + cy * cy) * (bx - ax)) /
            d;
          const center = { x: ux, y: uy };
          const radius = Math.sqrt((ax - ux) ** 2 + (ay - uy) ** 2);
          return {
            center,
            radius,
            contains(point) {
              const dx = center.x - point.x;
              const dy = center.y - point.y;
              return Math.sqrt(dx * dx + dy * dy) <= radius;
            },
          };
        }

        function superTriangle(vertices) {
          var minx = Infinity,
            miny = Infinity,
            maxx = -Infinity,
            maxy = -Infinity;
          vertices.forEach(function (vertex) {
            minx = Math.min(minx, vertex.x);
            miny = Math.min(miny, vertex.y);
            maxx = Math.max(maxx, vertex.x);
            maxy = Math.max(maxy, vertex.y);
          });
          var dx = (maxx - minx) * 10,
            dy = (maxy - miny) * 10;
          var v0 = new Vertex(minx - dx, miny - dy * 3),
            v1 = new Vertex(minx - dx, maxy + dy),
            v2 = new Vertex(maxx + dx * 3, maxy + dy);
          return new Triangle(v0, v1, v2);
        }
        function addVertex(vertex, triangles) {
          var edges = [];
          triangles = triangles.filter(function (triangle) {
            if (triangle.circumCircle.contains(vertex)) {
              edges.push(new Edge(triangle.v0, triangle.v1));
              edges.push(new Edge(triangle.v1, triangle.v2));
              edges.push(new Edge(triangle.v2, triangle.v0));
              return false;
            }
            return true;
          });
          edges = uniqueEdges(edges);
          edges.forEach(function (edge) {
            triangles.push(new Triangle(edge.v0, edge.v1, vertex));
          });
          return triangles;
        }
        function uniqueEdges(edges) {
          const uniqueEdgesMap = new Map();
          for (const edge of edges) {
            // Create a consistent key regardless of vertex order
            const key =
              edge.v0.x < edge.v1.x ||
              (edge.v0.x === edge.v1.x && edge.v0.y < edge.v1.y)
                ? `${posKey(edge.v0)}-${posKey(edge.v1)}`
                : `${posKey(edge.v1)}-${posKey(edge.v0)}`;

            if (uniqueEdgesMap.has(key)) {
              uniqueEdgesMap.delete(key); // Found a pair, so it's not unique
            } else {
              uniqueEdgesMap.set(key, edge); // First time seeing this edge
            }
          }
          return Array.from(uniqueEdgesMap.values());
        }
        function triangulate(vertices) {
          var st = superTriangle(vertices);
          var triangles = [st];
          vertices.forEach(function (vertex) {
            triangles = addVertex(vertex, triangles);
          });
          triangles = triangles.filter(function (triangle) {
            return !(
              triangle.v0.equals(st.v0) ||
              triangle.v0.equals(st.v1) ||
              triangle.v0.equals(st.v2) ||
              triangle.v1.equals(st.v0) ||
              triangle.v1.equals(st.v1) ||
              triangle.v1.equals(st.v2) ||
              triangle.v2.equals(st.v0) ||
              triangle.v2.equals(st.v1) ||
              triangle.v2.equals(st.v2)
            );
          });
          return triangles;
        }
        // ============================================================
        // HYBRID DUNGEON GENERATOR
        // Combines a large-room scaffold pass with the smaller-room filler and finally
        // adds connecting corridors. (Previous prototypes lived in test.html/test2 but
        // the logic is now embedded directly in index.html.)
        // Floors = 0, Walls = 1
        // ============================================================
        // ----- CONFIG -----
        const HYBRID_CFG = CONFIG.generator.hybrid;
        // Utility
        // clamp01Normalized helper imported earlier handles the normalization; reuse it here.
        const manhattan = (a, b) => Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        // -------------------------
        // Phase A: Large rooms
        // -------------------------
        function generateLargeRoomsScaffold(cfg = HYBRID_CFG.large) {
          // This is adapted from the old test2 prototype's generateLargeRoomsMap helper,
          // but now lives directly in the production code so we can return both the
          // grid and normalized room descriptors.
          const out = generateLargeRoomsMap({
            roomCountRange: cfg.roomCountRange,
            areaRange: cfg.areaRange,
            minSide: cfg.minSide,
            minL1EdgeSpacing: cfg.minL1EdgeSpacing,
            border: cfg.border,
            maxAttemptsPerRoom: cfg.maxAttemptsPerRoom,
          });
          // Normalize large rooms to a common format
          const largeRooms = out.rooms.map((r) => ({
            kind: r.kind,
            w: r.w,
            h: r.h,
            bbox: {
              x0: r.bbox.x0,
              y0: r.bbox.y0,
              x1: r.bbox.x1,
              y1: r.bbox.y1,
            },
            center: { x: r.center.x, y: r.center.y },
            tiles: r.tiles.map((t) => ({ x: t.x, y: t.y })),
          }));
          return {
            grid: out.grid,
            width: out.width,
            height: out.height,
            border: cfg.border,
            largeRooms,
          };
        }
        // -------------------------
        // Phase B: Fill with small rooms
        // -------------------------
        function rectsGenerateCandidates(count, sizeMin, sizeMax, spawnRadius) {
          // Preserve the biased sizing curve from the earlier prototype but keep it here
          // so readers don't have to chase down the old test.html snippet.
          const normal = () =>
            (Math.random() + Math.random() + Math.random()) / 3; // 0..1
          const rects = [];
          for (let i = 0; i < count; i++) {
            const w =
              sizeMin.w + Math.round(normal() * (sizeMax.w - sizeMin.w));
            const h =
              sizeMin.h + Math.round(normal() * (sizeMax.h - sizeMin.h));
            rects.push({
              x: Math.random() * spawnRadius - spawnRadius / 2,
              y: Math.random() * spawnRadius - spawnRadius / 2,
              w: Math.max(sizeMin.w, w),
              h: Math.max(sizeMin.h, h),
            });
          }
          return rects;
        }
        function rectsSeparate(rects, iterations = 80) {
          // Push-apart pass, then round to ints
          for (let iter = 0; iter < iterations; iter++) {
            let moved = false;
            for (let j = 0; j < rects.length; j++) {
              const r1 = rects[j];
              for (let k = j + 1; k < rects.length; k++) {
                const r2 = rects[k];
                const dx = r1.x + r1.w / 2 - (r2.x + r2.w / 2);
                const dy = r1.y + r1.h / 2 - (r2.y + r2.h / 2);
                const halfW = (r1.w + r2.w) / 2;
                const halfH = (r1.h + r2.h) / 2;
                if (Math.abs(dx) < halfW && Math.abs(dy) < halfH) {
                  moved = true;
                  const ox = halfW - Math.abs(dx);
                  const oy = halfH - Math.abs(dy);
                  if (ox < oy) {
                    const m = (ox / 2) * (dx > 0 ? 1 : -1);
                    r1.x += m;
                    r2.x -= m;
                  } else {
                    const m = (oy / 2) * (dy > 0 ? 1 : -1);
                    r1.y += m;
                    r2.y -= m;
                  }
                }
              }
            }
            if (!moved && iter > 10) break;
          }
          // Round to integer grid
          return rects.map((r) => ({
            x: Math.round(r.x),
            y: Math.round(r.y),
            w: Math.max(1, Math.round(r.w)),
            h: Math.max(1, Math.round(r.h)),
          }));
        }
        function rectIntersects(a, b) {
          return !(
            a.x + a.w - 1 < b.x ||
            b.x + b.w - 1 < a.x ||
            a.y + a.h - 1 < b.y ||
            b.y + b.h - 1 < a.y
          );
        }
        function inflateRect(r, d) {
          return { x: r.x - d, y: r.y - d, w: r.w + 2 * d, h: r.h + 2 * d };
        }
        function carveRoomIntoGrid(grid, r) {
          const H = grid.length,
            W = grid[0].length;
          for (let y = r.y + 1; y < r.y + r.h - 1; y++) {
            if (y <= 0 || y >= H - 1) continue;
            for (let x = r.x + 1; x < r.x + r.w - 1; x++) {
              if (x <= 0 || x >= W - 1) continue;
              grid[y][x] = TILE_FLOOR; // floor
            }
          }
        }
        function smallRoomsFillIntoGrid(
          grid,
          largeRooms,
          border,
          cfg = HYBRID_CFG.small,
        ) {
          const H = grid.length,
            W = grid[0].length;
          // Inflate large rooms by clearance and treat them as blocked for small room placement
          const inflatedLarge = largeRooms.map((L) =>
            inflateRect(
              { x: L.bbox.x0, y: L.bbox.y0, w: L.w, h: L.h },
              cfg.clearanceFromLarge,
            ),
          );
          // Build a combined forbidden mask = outside interior OR within clearance of any large room
          const forbidden = (x, y) => {
            if (x < border || y < border || x >= W - border || y >= H - border)
              return true;
            return inflatedLarge.some(
              (L) =>
                x >= L.x &&
                x <= L.x + L.w - 1 &&
                y >= L.y &&
                y <= L.y + L.h - 1,
            );
          };
          // Spawn candidates in a radius around map center
          const spawnRadius = Math.max(W, H);
          let candidates = rectsGenerateCandidates(
            cfg.candidateCount,
            cfg.minSize,
            cfg.maxSize,
            spawnRadius,
          );
          candidates = rectsSeparate(candidates, cfg.separationIters);
          // Translate candidates from local space to map space: center them roughly at map center
          const ox = Math.floor(W / 2),
            oy = Math.floor(H / 2);
          candidates = candidates.map((r) => ({
            x: r.x + ox,
            y: r.y + oy,
            w: r.w,
            h: r.h,
          }));
          // Filter candidates:
          const kept = [];
          for (const r of candidates) {
            // 1) Intersects interior?
            const violatesBorder =
              forbidden(r.x, r.y) || // top-left
              forbidden(r.x + r.w - 1, r.y) || // top-right
              forbidden(r.x, r.y + r.h - 1) || // bottom-left
              forbidden(r.x + r.w - 1, r.y + r.h - 1); // bottom-right
            if (violatesBorder) continue;
            // 2) Avoid overlap with any inflated large room
            const overlapsLarge = inflatedLarge.some((L) =>
              rectIntersects({ x: r.x, y: r.y, w: r.w, h: r.h }, L),
            );
            if (overlapsLarge) continue;
            // 3) Avoid carving into existing floors poorly: optional
            // We allow overlap with empty space; it is fine to merge.
            kept.push(r);
          }
          // Optionally thin out density
          const targetCount = Math.round(
            kept.length * clamp01Normalized(cfg.keepRatio),
          );
          const smallRooms = shuffle(kept).slice(0, targetCount);
          // Carve
          for (const r of smallRooms) carveRoomIntoGrid(grid, r);
          // Return normalized descriptors for graph building
          const smallNormalized = smallRooms.map((r) => {
            const tiles = [];
            for (let dy = 0; dy < r.h; dy++) {
              for (let dx = 0; dx < r.w; dx++) {
                tiles.push({ x: r.x + dx, y: r.y + dy });
              }
            }
            return {
              kind: "rect",
              w: r.w,
              h: r.h,
              bbox: { x0: r.x, y0: r.y, x1: r.x + r.w - 1, y1: r.y + r.h - 1 },
              center: {
                x: r.x + Math.floor(r.w / 2),
                y: r.y + Math.floor(r.h / 2),
              },
              tiles,
            };
          });
          return smallNormalized;
        }
        // -------------------------
        // Phase C: Corridors and connectivity
        // -------------------------
        function kruskal(edges, pointCount) {
          const mst = [];
          const parent = Array.from({ length: pointCount }, (_, i) => i);
          const find = (i) =>
            parent[i] === i ? i : (parent[i] = find(parent[i]));
          const unite = (i, j) => {
            const a = find(i),
              b = find(j);
            if (a !== b) {
              parent[a] = b;
              return true;
            }
            return false;
          };
          edges.sort((a, b) => a.dist - b.dist);
          for (const e of edges) if (unite(e.p1, e.p2)) mst.push(e);
          return mst;
        }
        function buildEdgesFromDelaunay(points) {
          const vertices = points.map((p, i) => {
            const v = new Vertex(p.x, p.y);
            v.id = i;
            return v;
          });
          const triangleObjects = triangulate(vertices);
          const tri = [];
          for (const t of triangleObjects) {
            tri.push(t.v0.id, t.v1.id, t.v2.id);
          }
          const set = new Map();
          for (let i = 0; i < tri.length; i += 3) {
            const a = tri[i],
              b = tri[i + 1],
              c = tri[i + 2];
            const add = (i1, i2) => {
              const key = i1 < i2 ? `${i1}-${i2}` : `${i2}-${i1}`;
              if (!set.has(key)) {
                const p = points[i1],
                  q = points[i2];
                set.set(key, {
                  p1: i1,
                  p2: i2,
                  dist: Math.hypot(p.x - q.x, p.y - q.y),
                });
              }
            };
            add(a, b);
            add(b, c);
            add(c, a);
          }
          return Array.from(set.values());
        }
        function carveLCorridor(grid, p1, p2) {
          let x = Math.round(p1.x),
            y = Math.round(p1.y);
          const tx = Math.round(p2.x),
            ty = Math.round(p2.y);

          if (inBounds(grid, x, y)) grid[y][x] = TILE_FLOOR;

          if (Math.random() > 0.5) {
            // Go X then Y
            while (x !== tx) {
              if (inBounds(grid, x, y)) grid[y][x] = TILE_FLOOR;
              x += Math.sign(tx - x);
            }
            while (y !== ty) {
              if (inBounds(grid, x, y)) grid[y][x] = TILE_FLOOR; // x is now tx
              y += Math.sign(ty - y);
            }
          } else {
            // Go Y then X
            while (y !== ty) {
              if (inBounds(grid, x, y)) grid[y][x] = TILE_FLOOR;
              y += Math.sign(ty - y);
            }
            while (x !== tx) {
              if (inBounds(grid, x, y)) grid[y][x] = TILE_FLOOR; // y is now ty
              x += Math.sign(tx - x);
            }
          }
          // Always carve the final destination tile to guarantee connection
          if (inBounds(grid, tx, ty)) grid[ty][tx] = TILE_FLOOR;
        }
        function floodFillOpen(grid, start) {
          const H = grid.length,
            W = grid[0].length;
          const key = (x, y) => `${x},${y}`;
          const seen = new Set();
          const q = [];
          if (start.x < 0 || start.y < 0 || start.x >= W || start.y >= H)
            return seen;
          if (grid[start.y][start.x] === TILE_WALL) return seen;
          q.push(start);
          seen.add(key(start.x, start.y));
          while (q.length) {
            const p = q.shift();
            for (const { dx, dy } of CARDINAL_DIRECTIONS) {
              const nx = p.x + dx;
              const ny = p.y + dy;
              const k = key(nx, ny);
              if (nx < 0 || ny < 0 || nx >= W || ny >= H) continue;
              if (grid[ny][nx] === TILE_FLOOR && !seen.has(k)) {
                seen.add(k);
                q.push({ x: nx, y: ny });
              }
            }
          }
          return seen;
        }
        function ensureConnectivity(grid, nodes) {
          // BFS from first node center; if a node is isolated, connect it to nearest reachable cell.
          if (nodes.length === 0) return;
          const start = nodes[0];
          let reachable = floodFillOpen(grid, {
            x: Math.round(start.center.x),
            y: Math.round(start.center.y),
          });
          const key = (x, y) => `${x},${y}`;
          const has = (p) =>
            reachable.has(key(Math.round(p.center.x), Math.round(p.center.y)));
          for (const n of nodes) {
            if (has(n)) continue;
            // find nearest reachable cell
            let best = null,
              bestD = Infinity;
            for (const k of reachable) {
              const [x, y] = k.split(",").map(Number);
              const d =
                Math.abs(x - Math.round(n.center.x)) +
                Math.abs(y - Math.round(n.center.y));
              if (d < bestD) {
                bestD = d;
                best = { x, y };
              }
            }
            if (best) {
              carveLCorridor(
                grid,
                { x: Math.round(n.center.x), y: Math.round(n.center.y) },
                best,
              );
              reachable = floodFillOpen(grid, {
                x: Math.round(start.center.x),
                y: Math.round(start.center.y),
              });
            }
          }
        }

        function ensureFloorAt(grid, pos) {
          if (!grid || !pos) return;
          const rowIndex = Math.round(pos.y);
          if (rowIndex < 0 || rowIndex >= grid.length) return;
          const row = grid[rowIndex];
          if (!Array.isArray(row)) return;
          const colIndex = Math.round(pos.x);
          if (colIndex < 0 || colIndex >= row.length) return;
          if (row[colIndex] === TILE_WALL) {
            row[colIndex] = TILE_FLOOR;
          }
        }
        // -------------------------
        // Master generator
        // -------------------------
        function generateDungeon() {
          // Phase A: large-room scaffold
          const largeOut = generateLargeRoomsScaffold(HYBRID_CFG.large);
          // Adopt dynamic map sizing from scaffold
          mapState.width = largeOut.width;
          mapState.height = largeOut.height;
          const grid = largeOut.grid.map((row) => row.slice()); // copy
          const allLarge = largeOut.largeRooms;
          // Phase B: small rooms filling
          const smallRooms = smallRoomsFillIntoGrid(
            grid,
            allLarge,
            largeOut.border,
            HYBRID_CFG.small,
          );
          // Unified node list (centers)
          const largeRoomNodes = allLarge.map((R) => ({
            kind: R.kind,
            center: { x: R.center.x, y: R.center.y },
          }));
          const smallRoomNodes = smallRooms.map((r) => ({
            kind: r.kind,
            center: { x: r.center.x, y: r.center.y },
          }));
          const allRooms = largeRoomNodes.concat(smallRoomNodes);
          // Phase C: corridors (only now)
          const points = allRooms.map((r) => ({
            x: r.center.x,
            y: r.center.y,
          }));
          const edges = buildEdgesFromDelaunay(points);
          const mst = kruskal(edges, points.length);
          // Add sparse extra edges
          const extrasCount = Math.floor(
            edges.length * HYBRID_CFG.corridors.extraEdgeFraction,
          );
          const extraEdges = shuffle(
            edges.filter((e) => !mst.includes(e)),
          ).slice(0, extrasCount);
          const finalEdges = mst.concat(extraEdges);
          // Carve corridors
          for (const e of finalEdges) {
            carveLCorridor(grid, points[e.p1], points[e.p2]);
          }
          // Rescue connectivity if any isolated parts remain
          if (HYBRID_CFG.corridors.rescueConnectivity) {
            ensureConnectivity(grid, allRooms);
          }
          // Choose start/end on far rooms
          const start = allRooms[0]?.center || {
            x: Math.floor(mapState.width / 2),
            y: Math.floor(mapState.height / 2),
          };
          let farIdx = 0,
            farDist = -1;
          for (let i = 0; i < allRooms.length; i++) {
            const d = manhattan(start, allRooms[i].center);
            if (d > farDist) {
              farDist = d;
              farIdx = i;
            }
          }
          const end = allRooms[farIdx]?.center || start;
          // Force floors at start/end
          ensureFloorAt(grid, start);
          ensureFloorAt(grid, end);
          return {
            grid,
            start: { x: Math.round(start.x), y: Math.round(start.y) },
            end: { x: Math.round(end.x), y: Math.round(end.y) },
          };
        }
        function applyCellSize(size) {
          const clamped = Math.max(MIN_CELL_SIZE, Math.floor(size));
          CELL_SIZE = clamped;
          HALF_CELL = CELL_SIZE / 2;
          if (viewportEl) {
            viewportEl.style.width = `${VIEW_W * CELL_SIZE}px`;
            viewportEl.style.height = `${VIEW_H * CELL_SIZE}px`;
          }
          if (canvas) {
            canvas.width = mapState.width * CELL_SIZE;
            canvas.height = mapState.height * CELL_SIZE;
          }
        }
        function updateResponsiveLayout(forceRedraw = true) {
          if (!mapState.width || !mapState.height) return;
          if (!containerEl || !viewportEl || !canvas) return;
          const appContainer = document.getElementById("app-container");
          const uiPanel = document.getElementById("ui-panel");
          if (!appContainer || !uiPanel) return;

          const measure = () => {
            const containerRect = containerEl.getBoundingClientRect();
            const viewportRect = viewportEl.getBoundingClientRect();
            const appRect = appContainer.getBoundingClientRect();
            const uiRect = uiPanel.getBoundingClientRect();
            return { containerRect, viewportRect, appRect, uiRect };
          };

          applyCellSize(CONFIG.visual.cellSize);
          let metrics = measure();
          const viewportWidth =
            metrics.viewportRect.width || VIEW_W * CELL_SIZE;
          const viewportHeight =
            metrics.viewportRect.height || VIEW_H * CELL_SIZE;
          const nonViewportWidth = metrics.appRect.width - viewportWidth;
          const nonViewportHeight =
            metrics.containerRect.height - viewportHeight;

          const widthBudget = window.innerWidth - nonViewportWidth;
          const heightBudget = window.innerHeight - nonViewportHeight;

          const widthRatio =
            viewportWidth > 0 ? Math.max(0, widthBudget / viewportWidth) : 1;
          const heightRatio =
            viewportHeight > 0 ? Math.max(0, heightBudget / viewportHeight) : 1;
          let scale = Math.min(1, widthRatio, heightRatio);
          if (!Number.isFinite(scale) || scale <= 0) {
            const safeWidth = widthRatio > 0 ? widthRatio : 1;
            const safeHeight = heightRatio > 0 ? heightRatio : 1;
            scale = Math.min(1, safeWidth, safeHeight);
          }

          const targetSize = Math.max(
            MIN_CELL_SIZE,
            Math.min(
              CONFIG.visual.cellSize,
              Math.floor(CONFIG.visual.cellSize * scale),
            ),
          );
          applyCellSize(targetSize);
          metrics = measure();

          let safety = 0;
          while (safety < 25) {
            const totalWidth = metrics.appRect.width;
            const totalHeight = Math.max(
              metrics.containerRect.height,
              metrics.uiRect.height,
            );
            if (
              (totalWidth <= window.innerWidth || CELL_SIZE <= MIN_CELL_SIZE) &&
              (totalHeight <= window.innerHeight || CELL_SIZE <= MIN_CELL_SIZE)
            ) {
              break;
            }
            if (CELL_SIZE <= MIN_CELL_SIZE) break;
            applyCellSize(CELL_SIZE - 1);
            metrics = measure();
            safety++;
          }

          if (forceRedraw) redrawAfterResize();
        }
        function redrawAfterResize() {
          if (!mapState.grid || !mapState.grid.length) return;
          if (!player || !player.pos) return;
          refreshLightingVisuals();
          const lightCtx = createLightOverlayContext();
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          for (let y = 0; y < mapState.height; y++) {
            for (let x = 0; x < mapState.width; x++) {
              if (!mapState.explored[y][x]) continue;
              const key = posKey({ x, y });
              const isVisible = fovState.currentVisible.has(key);
              const isStart =
                player.startPos &&
                x === player.startPos.x &&
                y === player.startPos.y;
              const isEnd =
                currentEndPos &&
                x === currentEndPos.x &&
                y === currentEndPos.y &&
                isEndRendered;
              drawCell(x, y, isVisible, false, isStart, isEnd, lightCtx);
            }
          }
          const playerKey = posKey(player.pos);
          const isPlayerVisible = fovState.currentVisible.has(playerKey);
          const isStart =
            player.startPos &&
            player.pos.x === player.startPos.x &&
            player.pos.y === player.startPos.y;
          const isEnd =
            currentEndPos &&
            player.pos.x === currentEndPos.x &&
            player.pos.y === currentEndPos.y;
          drawCell(
            player.pos.x,
            player.pos.y,
            isPlayerVisible,
            true,
            isStart,
            isEnd,
            lightCtx,
          );
          updateCamera(player.pos);
          if (minimapModalEl && minimapModalEl.style.display === "flex") {
            renderMinimapDynamic();
          }
        }
        function handleResize() {
          if (!mapState.grid || !mapState.grid.length) return;
          updateResponsiveLayout(true);
          if (isMinimapOpen()) {
            minimapBase = null;
            prepareMinimapCanvasBackingStore();
            renderMinimapDynamic();
          }
        }
        // --- UI & RENDER FUNCTIONS ---
        function setupDOM() {
          equipmentSlotsDiv.innerHTML = "";
          inventorySlotsDiv.innerHTML = "";
          ALL_SLOTS_ORDER.forEach((slotName) => {
            const slot = document.createElement("div");
            slot.classList.add("slot");
            slot.id = `equip-${slotName}`;
            slot.dataset.slot = slotName;
            const label = labelForSlot(slotName);
            slot.innerHTML = `<div class="slot-label">${label}</div><div class="slot-item"></div>`;
            equipmentSlotsDiv.appendChild(slot);
          });
          const inventory = player?.inventory;
          const capacity =
            typeof inventory?.capacitySlots === "number"
              ? inventory.capacitySlots
              : 0;
          const stackLength = Array.isArray(inventory?.stacks)
            ? inventory.stacks.length
            : 0;
          const invCapacity = Math.max(capacity, stackLength);
          for (let i = 0; i < invCapacity; i++) {
            const slot = document.createElement("div");
            slot.classList.add("slot");
            slot.id = `inv-${i}`;
            inventorySlotsDiv.appendChild(slot);
          }
          updateResponsiveLayout(false);
        }

        function tooltipForItem(item) {
          if (!item) return "";
          const throwInfo = describeThrowable(item);
          if (isRangedWeapon(item)) {
            const base = RangedCombat.describeRangedWeapon(item);
            return throwInfo ? `${base}\nThrow: ${throwInfo}` : base;
          }
          const name = item.name || "";
          return throwInfo ? `${name}\nThrow: ${throwInfo}` : name;
        }

        function tooltipForStack(stack) {
          if (!stack) return "";
          return tooltipForItem(stack.item);
        }

        function updateSlotElement(
          slotEl,
          { item = null, stack = null, emptyText = "-", clearWhenEmpty = false } = {},
        ) {
          if (!slotEl) return;

          const itemDiv = slotEl.querySelector(".slot-item");
          let textContent = emptyText;
          let title = "";

          if (stack) {
            textContent = `${stack.name}${
              stack.item?.stackable ? ` ×${stack.qty}` : ""
            }`;
            title = tooltipForStack(stack);
          } else if (item) {
            textContent = item.name ?? emptyText;
            title = tooltipForItem(item);
          }

          if (stack || item || !clearWhenEmpty) {
            if (itemDiv) {
              itemDiv.textContent = textContent;
            } else {
              slotEl.innerHTML = `<div class="slot-item">${textContent}</div>`;
            }
          } else if (clearWhenEmpty) {
            slotEl.innerHTML = "";
          }

          if (title) {
            slotEl.title = title;
          } else {
            slotEl.removeAttribute("title");
          }
        }

        function renderUI() {
          for (const slotName of ALL_SLOTS_ORDER) {
            const slotEl = document.getElementById(`equip-${slotName}`);
            const it = player.equipment.get(slotName);
            updateSlotElement(slotEl, { item: it, emptyText: "-" });
          }
          for (let i = 0; i < player.inventory.capacitySlots; i++) {
            const slotEl = document.getElementById(`inv-${i}`);
            if (!slotEl) break;
            const st = player.inventory.stacks[i];
            updateSlotElement(slotEl, {
              stack: st,
              emptyText: "",
              clearWhenEmpty: true,
            });
          }
        }

        function calculateViewportTransform(playerPos) {
          const mapPxW = mapState.width * CELL_SIZE;
          const mapPxH = mapState.height * CELL_SIZE;
          const vw = VIEW_W * CELL_SIZE;
          const vh = VIEW_H * CELL_SIZE;
          const desiredX = vw / 2 - (playerPos.x + 0.5) * CELL_SIZE;
          const desiredY = vh / 2 - (playerPos.y + 0.5) * CELL_SIZE;
          const tx = Math.round(Math.max(vw - mapPxW, Math.min(0, desiredX)));
          const ty = Math.round(Math.max(vh - mapPxH, Math.min(0, desiredY)));
          return { tx, ty };
        }

        // Keep the viewport centred on the player without allowing the camera to
        // drift past the map edges. This is effectively a clamped translation
        // that mimics a traditional roguelike "camera" following the hero.
        function updateCamera(playerPos) {
          const { tx, ty } = calculateViewportTransform(playerPos);
          canvas.style.transform = `translate3d(${tx}px, ${ty}px, 0)`;
        }
        // Render a single map tile. The function intentionally duplicates a bit
        // of style logic (instead of delegating to CSS classes) so we can keep
        // rendering on the canvas fast and free from layout thrashing.
        function drawCell(
          x,
          y,
          isVisible,
          isPlayer = false,
          isStart = false,
          isEnd = false,
          lightCtx = null,
        ) {
          const cellX = x * CELL_SIZE;
          const cellY = y * CELL_SIZE;
          if (!mapState.explored[y][x]) return; // Unexplored cells retain the base background color
          const { colors } = CONFIG.visual;
          let bgColor = colors.unseen;
          let text = "";
          let textColor = colors.defaultText;
          let fontWeight = "";
          const isWall = mapState.grid[y][x] === TILE_WALL;
          if (isWall) {
            bgColor = colors.wall;
            textColor = "transparent";
          } else {
            bgColor = colors.floor;
            text = "·";
            textColor = colors.floorGlyph;
          }
          if (isStart) bgColor = colors.start;
          if (isEnd) bgColor = colors.end;
          if (isPlayer) {
            bgColor = colors.player;
            text = "@";
            textColor = colors.playerGlyph;
            fontWeight = "bold ";
          }
          ctx.fillStyle = bgColor;
          if (isPlayer) {
            ctx.beginPath();
            ctx.arc(
              cellX + HALF_CELL,
              cellY + HALF_CELL,
              HALF_CELL,
              0,
              2 * Math.PI,
            );
            ctx.fill();
          } else {
            ctx.fillRect(cellX, cellY, CELL_SIZE, CELL_SIZE);
          }
          if (text) {
            const glyphSize = Math.max(10, Math.floor(CELL_SIZE * 0.85));
            ctx.font = `${fontWeight}${glyphSize}px monospace`;
            ctx.fillStyle = textColor;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(text, cellX + HALF_CELL, cellY + HALF_CELL);
          }
          if (isVisible) {
            const overlayRgb = fovState.overlayRgb;
            if (overlayRgb) {
              const alpha = computeTileOverlayAlpha(x, y, lightCtx);
              ctx.fillStyle = `rgba(${overlayRgb.r},${overlayRgb.g},${overlayRgb.b},${alpha.toFixed(
                3,
              )})`;
            } else {
              ctx.fillStyle = fovState.overlayStyle;
            }
            ctx.fillRect(cellX, cellY, CELL_SIZE, CELL_SIZE);
          }
        }
        // Updates the persistent fog-of-war state as the player moves. This both
        // records which tiles were ever seen (explorationState) and promotes nearby
        // floor cells to "frontiers" so the explorer knows where to head next.
        function updateVisionAndExploration(pos) {
          const lightRadius = getLightRadius();
          const radiusSq = lightRadius * lightRadius;
          explorationState.newlyExplored = [];
          const visibleCells = computeFieldOfView(pos, lightRadius, false);
          fovState.lastCache = {
            key: posKey(pos),
            radius: lightRadius,
            visible: visibleCells,
          };
          const cellsToUpdate = new Set(visibleCells);
          for (const cellKey of visibleCells) {
            const [x, y] = cellKey.split(",").map(Number);
            if (mapState.grid[y][x] === TILE_FLOOR) {
              for (const { dx, dy } of CARDINAL_DIRECTIONS) {
                const n = { x: x + dx, y: y + dy };
                const withinRadius =
                  (n.x - pos.x) * (n.x - pos.x) +
                    (n.y - pos.y) * (n.y - pos.y) <=
                  radiusSq;
                if (
                  withinRadius &&
                  n.x >= 0 &&
                  n.x < mapState.width &&
                  n.y >= 0 &&
                  n.y < mapState.height &&
                  mapState.grid[n.y][n.x] === TILE_WALL
                ) {
                  cellsToUpdate.add(posKey(n));
                }
              }
            }
          }
          for (const cellKey of cellsToUpdate) {
            const [x, y] = cellKey.split(",").map(Number);
            if (!mapState.explored[y][x]) {
              explorationState.newlyExplored.push({ x, y });
            }
            mapState.explored[y][x] = true;
            mapState.known[y][x] = mapState.grid[y][x];
            if (mapState.known[y][x] === TILE_FLOOR) {
              const neighbors = [
                { x: x, y: y - 1 },
                { x: x, y: y + 1 },
                { x: x - 1, y: y },
                { x: x + 1, y: y },
                { x: x - 1, y: y - 1 },
                { x: x - 1, y: y + 1 },
                { x: x + 1, y: y - 1 },
                { x: x + 1, y: y + 1 },
              ];
              const hasUnknown = neighbors.some(
                (n) =>
                  n.x >= 0 &&
                  n.x < mapState.width &&
                  n.y >= 0 &&
                  n.y < mapState.height &&
                  mapState.known[n.y][n.x] === -1,
              );
              if (hasUnknown) {
                explorationState.frontiers.add(posKey({ x, y }));
              } else {
                explorationState.frontiers.delete(posKey({ x, y }));
              }
            }
          }
        }
        // Heuristic scoring for neighbouring tiles when no direct goal is
        // available. Higher scores favour cells that reveal new territory while
        // penalising ones we recently stepped on (shortTermMemory) to reduce
        // aimless oscillation.
        function explorationScore(pos, shortTermMemory) {
          let score = 0;
          const lightRadius = getLightRadius();
          const visibleCells = computeFieldOfView(pos, lightRadius, true);
          for (const cellKey of visibleCells) {
            const [x, y] = cellKey.split(",").map(Number);
            if (mapState.known[y][x] === -1) {
              score++;
            }
          }
          if (shortTermMemory.includes(posKey(pos))) {
            score -= SHORT_TERM_MEMORY_PENALTY;
          }
          return score;
        }
        function reconstructPath(parents, startKey, targetKey, strategyName) {
          const path = [];
          let key = targetKey;
          while (key !== startKey) {
            const parentKey = parents.get(key);
            if (!parentKey) {
              throw new Error(
                `${strategyName} logic error: No parent found for key ${key} when reconstructing path from ${startKey} to ${targetKey}`,
              );
            }
            const [x, y] = key.split(",").map(Number);
            path.unshift({ x, y });
            key = parentKey;
          }
          return path;
        }

        function findPath(
          start,
          target,
          shortTermMemory,
          options = {},
          strategyFactory,
        ) {
          const effectiveOptions = options ?? {};
          const startKey = posKey(start);
          const targetKey = posKey(target);
          if (startKey === targetKey) {
            return [];
          }

          const {
            ignoreShortTermMemory = false,
          } = effectiveOptions;

          const restricted =
            !ignoreShortTermMemory &&
            shortTermMemory &&
            shortTermMemory.length > 0
              ? new Set(shortTermMemory)
              : null;

          const parents = new Map();
          const strategy = strategyFactory({
            start,
            target,
            startKey,
            targetKey,
            options: effectiveOptions,
            restricted,
          });

          const strategyName = strategy?.name || "Pathfinding";
          if (
            !strategy ||
            typeof strategy.getNextNode !== "function" ||
            typeof strategy.processNeighbor !== "function"
          ) {
            throw new Error(
              `${strategyName} strategy must define getNextNode and processNeighbor`,
            );
          }

          while (true) {
            const current = strategy.getNextNode();
            if (!current) {
              break;
            }

            const currentPos = current.pos || current;
            const currentKey = current.key || posKey(currentPos);

            if (currentKey === targetKey) {
              return reconstructPath(parents, startKey, targetKey, strategyName);
            }

            for (const { dx, dy } of CARDINAL_DIRECTIONS) {
              const neighbor = { x: currentPos.x + dx, y: currentPos.y + dy };
              if (
                neighbor.x < 0 ||
                neighbor.x >= mapState.width ||
                neighbor.y < 0 ||
                neighbor.y >= mapState.height
              ) {
                continue;
              }

              const neighborKey = posKey(neighbor);
              if (restricted && restricted.has(neighborKey)) {
                continue;
              }

              if (
                strategy.canTraverse &&
                !strategy.canTraverse({
                  neighbor,
                  neighborKey,
                  current,
                  currentKey,
                  parents,
                })
              ) {
                continue;
              }

              strategy.processNeighbor({
                neighbor,
                neighborKey,
                current,
                currentKey,
                parents,
              });
            }
          }

          return null;
        }

        function createBfsStrategy({ start, startKey }) {
          const queue = [{ pos: start, key: startKey }];
          let head = 0;
          const visited = new Set([startKey]);

          return {
            name: "BFS",
            getNextNode() {
              if (head >= queue.length) {
                return null;
              }
              return queue[head++];
            },
            canTraverse({ neighbor, neighborKey }) {
              if (visited.has(neighborKey)) {
                return false;
              }
              return mapState.known[neighbor.y][neighbor.x] === TILE_FLOOR;
            },
            processNeighbor({ neighbor, neighborKey, currentKey, parents }) {
              visited.add(neighborKey);
              parents.set(neighborKey, currentKey);
              queue.push({ pos: neighbor, key: neighborKey });
            },
          };
        }

        function createWeightedSearchStrategy({ start, startKey, options }) {
          const unknownTileCost =
            options.unknownTileCost ?? CONFIG.ai.fallback.unknownTileCost;
          const open = [{ pos: start, key: startKey, cost: 0 }];
          const costs = new Map([[startKey, 0]]);
          const processed = new Set();

          return {
            name: "Weighted search",
            getNextNode() {
              while (open.length > 0) {
                open.sort((a, b) => a.cost - b.cost);
                const node = open.shift();
                if (!node) {
                  break;
                }
                if (processed.has(node.key)) {
                  continue;
                }
                processed.add(node.key);
                return node;
              }
              return null;
            },
            canTraverse({ neighbor, neighborKey }) {
              if (processed.has(neighborKey)) {
                return false;
              }
              return mapState.grid[neighbor.y][neighbor.x] === TILE_FLOOR;
            },
            processNeighbor({ neighbor, neighborKey, current, currentKey, parents }) {
              const currentCost = current.cost ?? 0;
              let stepCost = 1;
              if (mapState.known[neighbor.y][neighbor.x] !== TILE_FLOOR) {
                stepCost += Math.max(0, unknownTileCost);
              }
              const newCost = currentCost + stepCost;
              if (!costs.has(neighborKey) || newCost < costs.get(neighborKey)) {
                costs.set(neighborKey, newCost);
                parents.set(neighborKey, currentKey);
                open.push({ pos: neighbor, key: neighborKey, cost: newCost });
              }
            },
          };
        }

        // Classic breadth-first search that respects the knowledge gathered so
        // far. We allow the caller to provide a short-term memory blacklist so
        // the AI can temporarily avoid tiles that caused recent backtracking.
        // Callers can explicitly disable this penalty via the ignoreShortTermMemory
        // option when a full backtrack is desired.
        function bfsToTarget(start, target, shortTermMemory, options = {}) {
          return findPath(start, target, shortTermMemory, options, createBfsStrategy);
        }

        function weightedSearchToTarget(
          start,
          target,
          shortTermMemory,
          options = {},
        ) {
          const mergedOptions = {
            unknownTileCost: CONFIG.ai.fallback.unknownTileCost,
            ...options,
          };
          return findPath(
            start,
            target,
            shortTermMemory,
            mergedOptions,
            createWeightedSearchStrategy,
          );
        }

        function prioritizeFrontiers(origin, seed = 0) {
          const frontiers = [];
          for (const fKey of explorationState.frontiers) {
            const [fx, fy] = fKey.split(",").map(Number);
            const dist =
              Math.abs(origin.x - fx) + Math.abs(origin.y - fy);
            const noise =
              Math.sin(
                fx * 73856093 + fy * 19349663 + seed * 83492791,
              ) * 0.5 + 0.5;
            frontiers.push({ pos: { x: fx, y: fy }, dist, noise });
          }
          frontiers.sort((a, b) => {
            if (a.dist !== b.dist) return a.dist - b.dist;
            return a.noise - b.noise;
          });
          return frontiers;
        }

        function generateRandomWalkPath(start, steps, maxAttempts = 3) {
          for (let attempt = 0; attempt < maxAttempts; attempt++) {
            const path = [];
            let current = { x: start.x, y: start.y };
            let failed = false;
            for (let i = 0; i < steps; i++) {
              const neighbors = CARDINAL_DIRECTIONS.map(({ dx, dy }) => ({
                x: current.x + dx,
                y: current.y + dy,
              })).filter((n) => {
                if (
                  n.x < 0 ||
                  n.x >= mapState.width ||
                  n.y < 0 ||
                  n.y >= mapState.height
                ) {
                  return false;
                }
                return mapState.grid[n.y][n.x] === TILE_FLOOR;
              });

              if (neighbors.length === 0) {
                failed = true;
                break;
              }

              const next = neighbors[Math.floor(Math.random() * neighbors.length)];
              path.push(next);
              current = next;
            }

            if (!failed && path.length > 0) {
              return path;
            }
          }
          return [];
        }
        function renderInitial(playerPos, startPos, endPos) {
          refreshLightingVisuals();
          const lightCtx = createLightOverlayContext();
          fovState.currentVisible = computeVisibleCells(playerPos);
          // Draw all initially explored cells
          for (const pos of explorationState.newlyExplored) {
            const key = posKey(pos);
            const isVis = fovState.currentVisible.has(key);
            const isS = pos.x === startPos.x && pos.y === startPos.y;
            const isE = pos.x === endPos.x && pos.y === endPos.y;
            if (isE) isEndRendered = true;
            drawCell(pos.x, pos.y, isVis, false, isS, isE, lightCtx);
          }
          // Draw player
          drawCell(playerPos.x, playerPos.y, true, true, true, false, lightCtx); // Start is player pos initially
        }
        function renderDelta(prevPlayerPos, playerPos, endPos) {
          refreshLightingVisuals();
          const lightCtx = createLightOverlayContext();
          // Redraw cells where visibility turned off
          for (const key of fovState.prevVisible) {
            if (!fovState.currentVisible.has(key)) {
              const [x, y] = key.split(",").map(Number);
              const isS = x === player.startPos.x && y === player.startPos.y;
              const isE = x === endPos.x && y === endPos.y;
              drawCell(x, y, false, false, isS, isE, lightCtx);
            }
          }
          // Redraw old player position (without player)
          if (prevPlayerPos) {
            const oldKey = posKey(prevPlayerPos);
            const isVis = fovState.currentVisible.has(oldKey);
            const isS =
              prevPlayerPos.x === player.startPos.x &&
              prevPlayerPos.y === player.startPos.y;
            const isE =
              prevPlayerPos.x === endPos.x && prevPlayerPos.y === endPos.y;
            drawCell(prevPlayerPos.x, prevPlayerPos.y, isVis, false, isS, isE, lightCtx);
          }
          // Draw newly explored cells
          for (const pos of explorationState.newlyExplored) {
            const key = posKey(pos);
            const isVis = fovState.currentVisible.has(key);
            const isS =
              pos.x === player.startPos.x && pos.y === player.startPos.y;
            let isE = pos.x === endPos.x && pos.y === endPos.y;
            if (isE && !isEndRendered) {
              isEndRendered = true;
            }
            drawCell(pos.x, pos.y, isVis, false, isS, isE, lightCtx);
          }
          // Draw newly visible cells that were already explored
          for (const key of fovState.currentVisible) {
            if (!fovState.prevVisible.has(key)) {
              const [x, y] = key.split(",").map(Number);
              const alreadyNew = explorationState.newlyExplored.some(
                (p) => p.x === x && p.y === y,
              );
              if (!alreadyNew) {
                const isS = x === player.startPos.x && y === player.startPos.y;
                const isE = x === endPos.x && y === endPos.y;
                drawCell(x, y, true, false, isS, isE, lightCtx);
              }
            }
          }
          // Draw new player position
          const newKey = posKey(playerPos);
          const isVis = fovState.currentVisible.has(newKey);
          const isS =
            playerPos.x === player.startPos.x &&
            playerPos.y === player.startPos.y;
          const isE = playerPos.x === endPos.x && playerPos.y === endPos.y;
          drawCell(playerPos.x, playerPos.y, isVis, true, isS, isE, lightCtx);
        }
        // --- SIMULATION LOGIC ---
        // Main autonomous exploration loop. The routine alternates between three
        // behaviours: beeline to the exit once discovered, opportunistically
        // explore high-value neighbours, and finally backtrack via the frontier
        // stack when no better move exists.
        function simulate(startPos, endPos) {
          statusDiv.textContent = "AI exploring...";
          restartBtn.style.display = "none";
          player.x = startPos.x;
          player.y = startPos.y;
          player.nextActAt = 0;
          const aiState = {
            stack: [],
            visitedForPathfinding: new Set([
              posKeyFromCoords(player.x, player.y),
            ]),
            shortTermMemory: [],
            randomWalkQueue: [],
            idleTicksWithoutProgress: 0,
            frontierNoiseSeed: Math.random() * 1000,
            lastProgressTurn: 0,
          };
          explorationState.frontiers.clear();
          simState.turnCounter = 0;
          if (!mobManager) {
            mobManager = new MobManager();
            // Removed redundant mobManager.add(player); to prevent duplicate addition
          }
          const gameCtx = {
            player,
            mobManager,
            maze: mapState.grid,
            ui: uiHooks,
          };

          function processPlayerTurn() {
            const currentPlayerX = player.x;
            const currentPlayerY = player.y;
            const currentPos = { x: currentPlayerX, y: currentPlayerY };

            const currentKey = posKeyFromCoords(
              currentPlayerX,
              currentPlayerY,
            );
            aiState.shortTermMemory.push(currentKey);
            if (aiState.shortTermMemory.length > CONFIG.ai.shortTermMemory) {
              aiState.shortTermMemory.shift();
            }

            let nextMove = null;
            let nextPos = currentPos;
            let attemptedFrontiers = false;

            if (mapState.known[endPos.y][endPos.x] === TILE_FLOOR) {
              const pathToExit = bfsToTarget(
                currentPos,
                endPos,
                aiState.shortTermMemory,
                { ignoreShortTermMemory: true },
              );
              if (pathToExit && pathToExit.length > 0) {
                nextMove = pathToExit[0];
                aiState.randomWalkQueue = [];
              }
            }

            if (!nextMove && aiState.randomWalkQueue.length > 0) {
              while (aiState.randomWalkQueue.length > 0 && !nextMove) {
                const candidate = aiState.randomWalkQueue.shift();
                if (
                  candidate &&
                  candidate.x >= 0 &&
                  candidate.x < mapState.width &&
                  candidate.y >= 0 &&
                  candidate.y < mapState.height &&
                  mapState.grid[candidate.y][candidate.x] === TILE_FLOOR
                ) {
                  nextMove = candidate;
                }
              }
            }

            if (!nextMove) {
              const neighbors = CARDINAL_DIRECTIONS.map(({ dx, dy }) => ({
                x: currentPlayerX + dx,
                y: currentPlayerY + dy,
              }));
              const unvisitedNeighbors = neighbors.filter(
                (n) =>
                  n.x >= 0 &&
                  n.x < mapState.width &&
                  n.y >= 0 &&
                  n.y < mapState.height &&
                  mapState.known[n.y][n.x] === TILE_FLOOR &&
                  !aiState.visitedForPathfinding.has(posKey(n)),
              );
              const potentialMoves = unvisitedNeighbors.map((n) => ({
                pos: n,
                score: explorationScore(n, aiState.shortTermMemory),
              }));
              potentialMoves.sort(
                (a, b) => b.score - a.score + (Math.random() - 0.5),
              );
              if (potentialMoves.length > 0 && potentialMoves[0].score > 0) {
                aiState.stack.push({ x: currentPlayerX, y: currentPlayerY });
                nextMove = potentialMoves[0].pos;
              }
            }

            if (!nextMove && explorationState.frontiers.size > 0) {
              const prioritized = prioritizeFrontiers(
                currentPos,
                aiState.frontierNoiseSeed,
              );
              const currentFrontierKey = posKey(currentPos);
              if (explorationState.frontiers.has(currentFrontierKey)) {
                explorationState.frontiers.delete(currentFrontierKey);
              }
              for (const candidate of prioritized) {
                attemptedFrontiers = true;
                const path = bfsToTarget(
                  currentPos,
                  candidate.pos,
                  aiState.shortTermMemory,
                  { ignoreShortTermMemory: true },
                );
                if (path && path.length > 0) {
                  nextMove = path[0];
                  break;
                }
              }

              if (!nextMove && attemptedFrontiers) {
                for (const candidate of prioritized) {
                  const path = weightedSearchToTarget(
                    currentPos,
                    candidate.pos,
                    aiState.shortTermMemory,
                    { ignoreShortTermMemory: true },
                  );
                  if (path && path.length > 0) {
                    nextMove = path[0];
                    break;
                  }
                }
              }

              if (!nextMove && attemptedFrontiers) {
                if (aiState.shortTermMemory.length > 0) {
                  const retain = Math.max(
                    0,
                    Math.floor(
                      aiState.shortTermMemory.length *
                        CONFIG.ai.fallback.memoryRetainFraction,
                    ),
                  );
                  aiState.shortTermMemory = retain
                    ? aiState.shortTermMemory.slice(-retain)
                    : [];
                }
                for (const candidate of prioritized) {
                  const path = bfsToTarget(
                    currentPos,
                    candidate.pos,
                    aiState.shortTermMemory,
                    { ignoreShortTermMemory: true },
                  );
                  if (path && path.length > 0) {
                    nextMove = path[0];
                    break;
                  }
                }
              }
            }

            if (!nextMove && aiState.stack.length > 0) {
              nextMove = aiState.stack.pop();
            }

            if (!nextMove) {
              if (aiState.randomWalkQueue.length === 0) {
                const { steps, maxAttempts } = CONFIG.ai.fallback.randomWalk;
                const randomPath = generateRandomWalkPath(
                  currentPos,
                  steps,
                  maxAttempts,
                );
                aiState.randomWalkQueue = randomPath.slice();
              }
              while (!nextMove && aiState.randomWalkQueue.length > 0) {
                const candidate = aiState.randomWalkQueue.shift();
                if (
                  candidate &&
                  candidate.x >= 0 &&
                  candidate.x < mapState.width &&
                  candidate.y >= 0 &&
                  candidate.y < mapState.height &&
                  mapState.grid[candidate.y][candidate.x] === TILE_FLOOR
                ) {
                  aiState.stack.push({ x: currentPlayerX, y: currentPlayerY });
                  nextMove = candidate;
                }
              }
            }

            if (!nextMove) {
              clearTimeout(simState.timeout);
              simState.timeout = null;
              simState.loopFn = null;
              statusDiv.textContent = "AI is trapped!";
              restartBtn.style.display = "block";
              return { ended: true };
            }

            prevPlayerPos.x = currentPlayerX;
            prevPlayerPos.y = currentPlayerY;
            if (!hasPrevPlayerPos) hasPrevPlayerPos = true;
            player.pos = nextMove;
            player.x = nextMove.x;
            player.y = nextMove.y;
            if (mobManager) {
              mobManager.reindex();
            }
            const nextX = player.x;
            const nextY = player.y;
            nextPos = { x: nextX, y: nextY };
            const stepKey = posKeyFromCoords(nextX, nextY);
            if (!aiState.visitedForPathfinding.has(stepKey)) {
              aiState.visitedForPathfinding.add(stepKey);
            }

            updateVisionAndExploration(nextPos);
            if (explorationState.newlyExplored.length > 0) {
              aiState.idleTicksWithoutProgress = 0;
              aiState.randomWalkQueue = [];
              aiState.lastProgressTurn = simState.turnCounter;
            } else {
              aiState.idleTicksWithoutProgress++;
              if (
                CONFIG.ai.maxIdleTicks > 0 &&
                aiState.idleTicksWithoutProgress >= CONFIG.ai.maxIdleTicks
              ) {
                aiState.idleTicksWithoutProgress = 0;
                aiState.visitedForPathfinding = new Set([posKey(nextPos)]);
                aiState.frontierNoiseSeed = Math.random() * 1000;
                if (aiState.shortTermMemory.length > 0) {
                  const retain = Math.max(
                    0,
                    Math.floor(
                      aiState.shortTermMemory.length *
                        CONFIG.ai.fallback.memoryRetainFraction,
                    ),
                  );
                  aiState.shortTermMemory = retain
                    ? aiState.shortTermMemory.slice(-retain)
                    : [];
                }
                aiState.randomWalkQueue = [];
              }
            }
            fovState.currentVisible = computeVisibleCells(nextPos);
            renderDelta(
              hasPrevPlayerPos ? prevPlayerPos : null,
              nextPos,
              endPos,
            );
            updateCamera(nextPos);
            fovState.prevVisible = new Set(fovState.currentVisible);
            minimapMaybeRefreshOnTick();

            return { acted: true };
          }
          function gameLoop() {
            clearTimeout(simState.timeout);
            if (!simState.isPaused) {
              if (handleDeath(gameCtx, player, gameCtx.ui)) {
                return;
              }

              const turn = ++simState.turnCounter;
              tickStatusesAtTurnStart(player, turn, gameCtx);
              if (handleDeath(gameCtx, player, gameCtx.ui)) {
                return;
              }
              if (mobManager) {
                mobManager.tick(gameCtx, turn);
              }
              if (handleDeath(gameCtx, player, gameCtx.ui)) {
                return;
              }
              const currentPlayerX = player.x;
              const currentPlayerY = player.y;
              const currentPos = { x: currentPlayerX, y: currentPlayerY };
              if (currentPlayerX === endPos.x && currentPlayerY === endPos.y) {
                clearTimeout(simState.timeout);
                simState.timeout = null;
                simState.loopFn = null;
                statusDiv.textContent = "Exit found!";
                renderDelta(
                  hasPrevPlayerPos ? prevPlayerPos : null,
                  currentPos,
                  endPos,
                );
                restartBtn.style.display = "block";
                return;
              }

              const playerCanAct =
                (player.statusDerived?.canAct ?? true) &&
                turn >=
                  (typeof player.nextActAt === "number"
                    ? player.nextActAt
                    : 0);

              if (playerCanAct) {
                const result = processPlayerTurn();
                if (result?.ended) {
                  return;
                }
                if (result?.acted) {
                  const delay = computeActorDelay(player);
                  player.nextActAt = turn + delay;
                }
              }
            }
            const delay = Math.max(16, 1000 / simState.speed);
            simState.timeout = setTimeout(gameLoop, delay);
          }
          simState.loopFn = gameLoop;
          gameLoop();
        }
        function togglePause() {
          simState.isPaused = !simState.isPaused;
          if (simState.isPaused) {
            pauseIndicator.textContent = "PAUSED";
          } else {
            pauseIndicator.textContent = "";
            if (typeof simState.loopFn === "function") {
              simState.timeout = setTimeout(
                simState.loopFn,
                1000 / simState.speed,
              ); // Resume the loop
            }
          }
        }
        function resetSimulationStateForInit() {
          clearTimeout(simState.timeout);
          simState.loopFn = null;
          simState.isPaused = false;
          pauseIndicator.textContent = "";
          statusDiv.textContent = "Generating dungeon...";
          restartBtn.style.display = "none";
          currentEndPos = null;
          hasPrevPlayerPos = false;
          simState.turnCounter = 0;
        }

        function setupPlayer() {
          const newPlayer = new Player({ name: "Player", x: 0, y: 0 });

          if (!mobManager) {
            throw new Error(
              "mobManager is not initialized before setupPlayer() is called.",
            );
          }
          mobManager.add(newPlayer);

          // Wearables
          newPlayer.equipment.equipTo(SLOT.Head, makeItem("leather_cap"));
          newPlayer.equipment.equipTo(
            SLOT.BodyArmor,
            makeItem("basic_clothes"),
          );
          newPlayer.equipment.equipTo(SLOT.Cloak, makeItem("cloak"));
          newPlayer.equipment.equipTo(SLOT.Belt, makeItem("belt_leather"));
          newPlayer.equipment.equipTo(SLOT.Backpack, makeItem("pack_rucksack")); // choose pack
          newPlayer.equipment.equipTo(SLOT.LeftHand, makeItem("torch"));
          newPlayer.equipment.equipTo(SLOT.RightHand, makeItem("short_sword"));
          // Belt attachments
          newPlayer.equipment.equipTo(SLOT.Belt1, makeItem("pouch_small"));
          newPlayer.equipment.equipTo(SLOT.Belt2, makeItem("bow_short"));
          newPlayer.equipment.equipTo(SLOT.Quiver, makeItem("quiver_std"));

          // Inventory constraints come from backpack
          newPlayer.inventory = new Inventory(DEFAULT_INVENTORY_CAPACITY);
          newPlayer.inventory.setConstraints(
            newPlayer.equipment.currentBackpackConstraints(),
          );

          // Seed inventory
          newPlayer.inventory.add(new ItemStack(makeItem("torch"), 3));
          newPlayer.inventory.add(new ItemStack(makeItem("arrow_wood"), 20));
          newPlayer.inventory.add(new ItemStack(makeItem("bolt_wood"), 15));
          newPlayer.inventory.add(new ItemStack(makeItem("sling_stone"), 40));
          newPlayer.inventory.add(new ItemStack(makeItem("dagger")));
          newPlayer.inventory.add(makeItem("crossbow_light"));
          newPlayer.inventory.add(new ItemStack(makeItem("sling_leather")));
          newPlayer.inventory.add(new ItemStack(makeItem("throwing_knife"), 4));
          newPlayer.inventory.add(new ItemStack(makeItem("javelin"), 3));
          newPlayer.inventory.add(new ItemStack(makeItem("boots")));
          newPlayer.inventory.add(new ItemStack(makeItem("gloves")));
          newPlayer.inventory.add(new ItemStack(makeItem("amulet_simple")));
          newPlayer.inventory.add(new ItemStack(makeItem("pouch_small")));

          return newPlayer;
        }

        function generateAndValidateDungeon() {
          statusDiv.textContent = "Generating dungeon...";
          const dungeonData = generateDungeon();
          if (!dungeonData) {
            return { success: false, reason: "generation" };
          }

          mapState.grid = dungeonData.grid;
          mapState.width = mapState.grid[0].length;
          mapState.height = mapState.grid.length;

          const isConnected = !!aStarPath(
            mapState.grid,
            dungeonData.start,
            dungeonData.end,
          );
          if (!isConnected) {
            return { success: false, reason: "connectivity" };
          }

          return { success: true, dungeonData };
        }

        function handleDungeonFailure(reason) {
          if (reason === "generation") {
            statusDiv.textContent = "Map generation failed, retrying...";
            initRetries++;
            setTimeout(startNewSimulation, 100);
          } else if (reason === "connectivity") {
            statusDiv.textContent =
              "Map is not fully connected, regenerating...";
            initRetries++;
            setTimeout(startNewSimulation, 50);
          }
        }

        function initializeSimulation(dungeonData) {
          const startPos = dungeonData.start;
          const endPos = dungeonData.end;
          currentEndPos = endPos;

          mapState.explored = Array.from({ length: mapState.height }, () =>
            Array(mapState.width).fill(false),
          );
          mapState.known = Array.from({ length: mapState.height }, () =>
            Array(mapState.width).fill(-1),
          );

          setupDOM();

          player.pos = startPos;
          player.startPos = startPos;
          isEndRendered = false;
          fovState.prevVisible = new Set();
          hasPrevPlayerPos = false;
          fovState.currentVisible = new Set();
          explorationState.newlyExplored = [];
          fovState.lastCache = { key: null, radius: null, visible: null };

          updateVisionAndExploration(player.startPos);
          renderInitial(player.startPos, player.startPos, endPos);
          updateCamera(player.startPos);
          renderUI();
          fovState.prevVisible = computeVisibleCells(player.startPos);
          prevPlayerPos.x = player.startPos.x;
          prevPlayerPos.y = player.startPos.y;
          hasPrevPlayerPos = true;
          initRetries = 0;
          simState.isReady = true;

          setTimeout(() => simulate(player.startPos, endPos), 500);
        }

        function startNewSimulation() {
          if (initRetries > MAX_INIT_RETRIES) {
            statusDiv.textContent =
              "Fatal Error: Map generation failed repeatedly.";
            console.error("Map generation failed after multiple retries.");
            return;
          }

          simState.isReady = false;
          resetSimulationStateForInit();
          minimapBase = null;
          mobManager = new MobManager();
          player = setupPlayer();

          setTimeout(() => {
            const result = generateAndValidateDungeon();
            if (!result.success) {
              handleDungeonFailure(result.reason);
              return;
            }

            initializeSimulation(result.dungeonData);
          }, 50);
        }
        function bootstrap() {
          const ticksPerSecond = CONFIG.ai.ticksPerSecond;
          speedSlider.value = ticksPerSecond;
          speedValue.textContent = `${ticksPerSecond} tps`;
          restartBtn.addEventListener("click", startNewSimulation);
          speedSlider.addEventListener("input", (e) => {
            simState.speed = parseInt(e.target.value, 10);
            speedValue.textContent = `${simState.speed} tps`;
          });
          window.addEventListener("resize", handleResize);
          window.addEventListener("keydown", (e) => {
            if (e.code === "Space") {
              e.preventDefault();
              togglePause();
            }
          });
          initMinimapDOM();
          startNewSimulation();
        }
        // ===================== MINIMAP =====================
        let minimapBase = null; // offscreen static layer (map tiles)
        let minimapScale = 1; // pixels per tile inside the minimap canvas
        let minimapPadding = CONFIG.minimap.padding; // visual padding around map in tiles

        const MINIMAP_COLORS = CONFIG.minimap.colors;

        function initMinimapDOM() {
          minimapModalEl = document.getElementById("minimapModal");
          minimapCanvas = document.getElementById("minimapCanvas");
          minimapCtx = minimapCanvas.getContext("2d");
          minimapCloseBtn = document.getElementById("minimapClose");

          minimapCloseBtn.addEventListener("click", closeMinimap);
          document.addEventListener("keydown", (e) => {
            if (e.key === "m" || e.key === "M") toggleMinimap();
            if (e.key === "Escape" && isMinimapOpen()) closeMinimap();
          });
        }

        function isMinimapOpen() {
          return minimapModalEl && minimapModalEl.style.display === "flex";
        }

        function openMinimap() {
          if (!minimapModalEl) initMinimapDOM();
          minimapModalEl.style.display = "flex"; // make it visible first

          // Defer canvas work until the browser has computed the new layout for the modal.
          // This prevents reading stale dimensions before the CSS `display:flex` is applied.
          requestAnimationFrame(() => {
            prepareMinimapCanvasBackingStore(); // Sets canvas resolution from CSS size
            renderMinimapDynamic(); // Renders map (and builds base texture if needed)
          });
        }

        function closeMinimap() {
          if (minimapModalEl) minimapModalEl.style.display = "none";
        }

        function toggleMinimap() {
          if (!simState.isReady) return;
          if (isMinimapOpen()) closeMinimap();
          else openMinimap();
        }

        function handleMinimapResize() {
          if (!isMinimapOpen()) return;
          prepareMinimapCanvasBackingStore();
          minimapBase = null;
          renderMinimapDynamic();
        }

        window.addEventListener("resize", () => {
          if (!minimapModalEl) return;
          handleMinimapResize();
        });

        function getPlayerPos() {
          // Accept either player.x/y or player.pos.x/y
          if (!player) return { x: 0, y: 0 };
          if (typeof player.x === "number" && typeof player.y === "number")
            return { x: player.x, y: player.y };
          if (
            player.pos &&
            typeof player.pos.x === "number" &&
            typeof player.pos.y === "number"
          )
            return { x: player.pos.x, y: player.pos.y };
          return { x: 0, y: 0 };
        }

        function prepareMinimapCanvasBackingStore() {
          // Use visible box size when the modal is open
          const rect = minimapCanvas.getBoundingClientRect();
          const dpr = window.devicePixelRatio || 1;

          // Fallback if somehow still zero (should not happen after display:flex)
          const cssW =
            rect.width > 0
              ? rect.width
              : minimapCanvas.width || MINIMAP_DEFAULT_DIMENSION;
          const cssH =
            rect.height > 0
              ? rect.height
              : minimapCanvas.height || MINIMAP_DEFAULT_DIMENSION;

          minimapCanvas.width = Math.max(1, Math.round(cssW * dpr));
          minimapCanvas.height = Math.max(1, Math.round(cssH * dpr));
        }

        function buildMinimapBase() {
          if (!mapState.grid || !mapState.grid.length) return;

          const pad = minimapPadding;
          const tilesW = mapState.width + pad * 2;
          const tilesH = mapState.height + pad * 2;

          // Use current canvas backing size (already set by prepareMinimapCanvasBackingStore on open)
          const targetW = minimapCanvas.width || MINIMAP_DEFAULT_DIMENSION;
          const targetH = minimapCanvas.height || MINIMAP_DEFAULT_DIMENSION;

          minimapScale = Math.max(
            1,
            Math.floor(Math.min(targetW / tilesW, targetH / tilesH)),
          );

          // Offscreen base
          minimapBase = document.createElement("canvas");
          minimapBase.width = tilesW * minimapScale;
          minimapBase.height = tilesH * minimapScale;
          const ctx = minimapBase.getContext("2d");

          // Background (floors)
          ctx.fillStyle = MINIMAP_COLORS.floor;
          ctx.fillRect(0, 0, minimapBase.width, minimapBase.height);

          const ox = pad * minimapScale;
          const oy = pad * minimapScale;

          // Walls
          ctx.fillStyle = MINIMAP_COLORS.wall;
          for (let y = 0; y < mapState.height; y++) {
            for (let x = 0; x < mapState.width; x++) {
              if (mapState.grid[y][x] === TILE_WALL) {
                ctx.fillRect(
                  ox + x * minimapScale,
                  oy + y * minimapScale,
                  minimapScale,
                  minimapScale,
                );
              }
            }
          }

          // Optional border to make the map bounds obvious
          ctx.strokeStyle = MINIMAP_COLORS.border;
          ctx.lineWidth = Math.max(1, Math.floor(minimapScale / 2));
          ctx.strokeRect(
            ox,
            oy,
            mapState.width * minimapScale,
            mapState.height * minimapScale,
          );
        }

        /**
         * Draw dynamic overlay each time the minimap is shown or on demand:
         * - base layer (blit the offscreen)
         * - viewport rectangle
         * - player dot
         */
        function renderMinimapDynamic() {
          if (!minimapBase) buildMinimapBase();
          const ctx = minimapCtx;

          // Clear and blit base at 1:1 into the visible canvas, centered
          ctx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);

          // Compute draw position to center the base within canvas
          const dx = Math.floor((minimapCanvas.width - minimapBase.width) / 2);
          const dy = Math.floor(
            (minimapCanvas.height - minimapBase.height) / 2,
          );

          ctx.drawImage(minimapBase, dx, dy);

          // --- START: ACCURATE VIEWPORT CALCULATION (FIXED) ---
          // This logic mirrors the main `updateCamera` function to find the exact
          // top-left corner of the visible area in map coordinates.
          const playerPos = getPlayerPos();
          const { tx: canvasTranslateX, ty: canvasTranslateY } =
            calculateViewportTransform(playerPos);

          const rawViewportX = Math.round(-canvasTranslateX / CELL_SIZE);
          const rawViewportY = Math.round(-canvasTranslateY / CELL_SIZE);
          const maxViewportX = Math.max(0, mapState.width - VIEW_W);
          const maxViewportY = Math.max(0, mapState.height - VIEW_H);
          const viewportTopLeftX_map = Math.min(
            Math.max(0, rawViewportX),
            maxViewportX,
          );
          const viewportTopLeftY_map = Math.min(
            Math.max(0, rawViewportY),
            maxViewportY,
          );

          const viewportTilesWide = Math.min(VIEW_W, mapState.width);
          const viewportTilesHigh = Math.min(VIEW_H, mapState.height);

          // Overlay: viewport rectangle
          const pad = minimapPadding;
          const px0 = dx + (pad + viewportTopLeftX_map) * minimapScale;
          const py0 = dy + (pad + viewportTopLeftY_map) * minimapScale;
          // --- END: ACCURATE VIEWPORT CALCULATION ---

          const pw = viewportTilesWide * minimapScale;
          const ph = viewportTilesHigh * minimapScale;

          ctx.lineWidth = Math.max(1, Math.floor(minimapScale / 2));
          ctx.strokeStyle = MINIMAP_COLORS.viewport;
          ctx.strokeRect(px0, py0, pw, ph);

          // Overlay: player
          const p = getPlayerPos();
          const cx = dx + (pad + p.x + 0.5) * minimapScale;
          const cy = dy + (pad + p.y + 0.5) * minimapScale;
          const r = Math.max(2, Math.floor(minimapScale / 1.5));

          ctx.fillStyle = MINIMAP_COLORS.player;
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, Math.PI * 2);
          ctx.fill();
        }

        // Optional: call this after each player move to keep an open minimap fresh
        function minimapMaybeRefreshOnTick() {
          if (isMinimapOpen()) renderMinimapDynamic();
        }

        // ===================== END MINIMAP =====================
        return {
          bootstrap,
          togglePause,
        };
      })();

      window.addEventListener("load", () => {
        Game.bootstrap();
      });
    </script>
  </body>
</html>
